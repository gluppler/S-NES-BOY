# 1.2 6502 CPU Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES**: Primary focus (Ricoh 2A03 CPU)
- ✅ **Famicom**: Fully compatible (same Ricoh 2A03 CPU)
- ⚠️ **SNES**: Partially applicable (SNES uses 65816 CPU which is backward compatible with 6502 in emulation mode, but has 16-bit capabilities and different addressing modes)

**Note**: SNES developers should understand 6502 fundamentals as the 65816 operates in 6502 emulation mode on reset, but SNES-specific 65816 features (16-bit registers, new addressing modes) are beyond this document's scope.

## Physical Hardware Overview

The NES and Famicom use a **Ricoh 2A03**, a 6502 variant with integrated APU. The CPU operates at:
* **NTSC**: 1.789773 MHz (21.477272 MHz master clock ÷ 12)
* **PAL**: 1.662607 MHz (26.601712 MHz master clock ÷ 16)

The 6502 is an 8-bit processor with:
* 16-bit address bus (64 KB addressable)
* 8-bit data bus
* 8-bit accumulator (A)
* 8-bit index registers (X, Y)
* 8-bit stack pointer (SP, points to $0100–$01FF)
* 16-bit program counter (PC)
* 8-bit status register (P: N V - B D I Z C)

## NES/Famicom Terminology Definitions

* **Accumulator (A)**: Primary arithmetic/logic register
* **Index Registers (X, Y)**: Used for indexing memory and loops
* **Stack Pointer (SP)**: Points to $0100–$01FF (hardware stack)
* **Status Register (P)**: Flags (N=Negative, V=Overflow, B=Break, D=Decimal, I=Interrupt, Z=Zero, C=Carry)
* **Zero Page**: First 256 bytes ($0000–$00FF), faster addressing
* **Addressing Mode**: How an instruction determines its operand address
* **Page**: 256-byte block (e.g., $0100–$01FF is "page 1")
* **Page Boundary**: Crossing from $XXFF to $XX00 incurs cycle penalty

## Core Rules and Invariants

### Registers

* **A**: Accumulator, used by most arithmetic/logic operations
* **X**: Index register, used for loops, indexing, stack manipulation
* **Y**: Index register, used for loops and indexing
* **SP**: Stack pointer (8-bit, wraps at $00/$FF), points to $0100–$01FF
* **PC**: Program counter (16-bit), points to current instruction
* **P**: Status register, updated by most instructions

### Addressing Modes

* **Immediate**: `LDA #$42` (operand is literal value)
* **Zero Page**: `LDA $42` (operand is address $0042, 1-byte address)
* **Zero Page,X**: `LDA $42,X` (operand is $0042 + X, wraps at page boundary)
* **Zero Page,Y**: `LDA $42,Y` (operand is $0042 + Y, wraps at page boundary)
* **Absolute**: `LDA $1234` (operand is address $1234, 2-byte address)
* **Absolute,X**: `LDA $1234,X` (operand is $1234 + X, may cross page)
* **Absolute,Y**: `LDA $1234,Y` (operand is $1234 + Y, may cross page)
* **Indirect**: `JMP ($1234)` (operand is address at $1234, low byte first)
* **Indirect,X**: `LDA ($42,X)` (operand is address at $0042+X, wraps)
* **Indirect,Y**: `LDA ($42),Y` (operand is address at $0042 + Y, may cross page)

### Instruction Categories

* **Load/Store**: LDA, LDX, LDY, STA, STX, STY
* **Arithmetic**: ADC, SBC, INC, DEC, INX, DEX, INY, DEY
* **Logic**: AND, ORA, EOR, ASL, LSR, ROL, ROR
* **Branches**: BCC, BCS, BEQ, BMI, BNE, BPL, BVC, BVS (relative, ±127 bytes)
* **Jumps**: JMP (absolute/indirect), JSR (absolute), RTS
* **Stack**: PHA, PHP, PLA, PLP, TSX, TXS
* **Flags**: CLC, SEC, CLI, SEI, CLV, CLD, SED
* **Misc**: NOP, BRK, RTI

### Stack Behavior

* Stack grows **downward** (SP decrements on push)
* Stack is fixed at $0100–$01FF (cannot be relocated)
* PHA pushes A, PHP pushes P, PLA pulls A, PLP pulls P
* JSR pushes return address-1 (high byte, then low byte)
* RTS pulls return address and adds 1
* Stack overflow/underflow wraps (SP is 8-bit)

## Minimal Correct Usage Example

```asm
; Zero page usage
LDA #$10        ; Load immediate value
STA $00         ; Store to zero page ($0000)
LDX #$05        ; Load X with 5
LDA $00,X       ; Load from zero page indexed ($0005)

; Absolute addressing
LDA $1234       ; Load from absolute address
STA $5678       ; Store to absolute address

; Indexed addressing
LDY #$10
LDA $2000,Y     ; Load from $2010

; Stack operations
PHA             ; Push accumulator
PLA             ; Pull accumulator

; Branching
LDA $00
CMP #$10
BEQ equal       ; Branch if equal
; ... not equal code ...
equal:
; ... equal code ...

; Subroutine
JSR my_sub      ; Call subroutine
; ... continues after return ...
my_sub:
    PHA         ; Save A
    ; ... subroutine code ...
    PLA         ; Restore A
    RTS         ; Return
```

## Explicit Non-Goals

This section does not cover:
* Cycle counts and timing (see 2.1)
* Branch penalties and page crossings (see 2.1)
* NMI/IRQ handling (see 2.2)
* Memory map specifics (see 1.3)
* Advanced optimization techniques

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.3 (Memory)
- Related Advanced Fundamentals: 2.1 (CPU Timing & Cycles)
- Related Core Concepts: 3.2 (Data-Oriented Design)
- Related Cheatsheets: 4.1 (CPU Cheatsheets)
