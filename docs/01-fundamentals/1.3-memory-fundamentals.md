# 1.3 Memory Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES**: Primary focus
- ✅ **Famicom**: Fully compatible (identical memory architecture)
- ❌ **SNES**: Does not apply (SNES has different memory architecture - 24-bit address bus, different memory map)

## Physical Hardware Overview

The NES and Famicom CPU has a 16-bit address bus, providing 64 KB ($0000–$FFFF) of addressable space. This space is divided into:

* **Internal RAM**: 2 KB of work RAM, mirrored four times
* **PPU Registers**: Memory-mapped I/O for PPU communication, mirrored
* **APU/I/O Registers**: Audio and controller I/O, not mirrored
* **Cartridge Space**: PRG ROM, CHR ROM, mapper registers, optional RAM

The PPU has its own 14-bit address bus (16 KB), separate from the CPU bus.

## NES/Famicom Terminology Definitions

* **CPU Memory Map**: The 64 KB address space visible to the CPU
* **PPU Memory Map**: The 16 KB address space visible to the PPU
* **Zero Page**: First 256 bytes ($0000–$00FF), fastest addressing mode
* **Stack**: Fixed 256-byte region at $0100–$01FF, grows downward
* **Mirroring**: Multiple addresses map to the same physical memory
* **Memory-Mapped I/O**: Hardware registers accessible as memory addresses
* **PRG ROM**: Program ROM, contains CPU code and data
* **CHR ROM**: Character ROM, contains PPU pattern data (tiles)
* **Mapper**: Cartridge hardware that remaps ROM banks

## Core Rules and Invariants

### CPU Memory Map ($0000–$FFFF)

| Address Range | Size | Description | Notes |
|--------------|------|-------------|-------|
| $0000–$1FFF | 8 KB | Internal RAM | Mirrored 4 times (actual RAM: $0000–$07FF) |
| $2000–$3FFF | 8 KB | PPU Registers | Mirrored every 8 bytes ($2000–$2007) |
| $4000–$401F | 32 B | APU/I/O Registers | APU, controllers, expansion |
| $4020–$5FFF | 8 KB | Cartridge Expansion | Mapper-specific |
| $6000–$7FFF | 8 KB | Cartridge RAM | Optional SRAM (battery-backed) |
| $8000–$FFFF | 32 KB | Cartridge PRG ROM | Mapper 0: fixed 32 KB or 16 KB + mirror |

### Zero Page Philosophy

* Zero page ($0000–$00FF) uses 1-byte addresses (faster, fewer cycles)
* Critical variables should live in zero page
* Zero page is precious real estate; allocate carefully
* Zero page indexed addressing wraps at page boundary ($00FF + 1 = $0000)

### Stack Location and Constraints

* Stack is **fixed** at $0100–$01FF (cannot be relocated)
* Stack pointer (SP) is 8-bit, wraps automatically
* Stack grows **downward** (SP decrements on push)
* Initial SP should be set to $FF (points to $01FF)
* Stack overflow/underflow wraps silently (no hardware protection)

### ROM vs RAM vs Memory-Mapped I/O

* **ROM**: Read-only, contains code/data from cartridge
* **RAM**: Read-write, volatile (lost on power-off)
* **SRAM**: Battery-backed RAM in cartridge ($6000–$7FFF)
* **Memory-Mapped I/O**: Registers that control hardware, not storage

### PPU Memory Map ($0000–$3FFF)

| Address Range | Size | Description |
|--------------|------|-------------|
| $0000–$0FFF | 4 KB | Pattern Table 0 (or CHR ROM bank 0) |
| $1000–$1FFF | 4 KB | Pattern Table 1 (or CHR ROM bank 1) |
| $2000–$23FF | 1 KB | Name Table 0 |
| $2400–$27FF | 1 KB | Name Table 1 |
| $2800–$2BFF | 1 KB | Name Table 2 |
| $2C00–$2FFF | 1 KB | Name Table 3 |
| $3000–$3EFF | 3.75 KB | Mirrors of $2000–$2EFF |
| $3F00–$3F1F | 32 B | Palette RAM |
| $3F20–$3FFF | 224 B | Mirrors of $3F00–$3F1F |

## Minimal Correct Usage Example

```asm
; Zero page allocation
zp_temp = $00       ; Temporary variable
zp_ptr = $02        ; 16-bit pointer (low, high)

; Using zero page
LDA #$42
STA zp_temp         ; Store to zero page (faster)

; 16-bit pointer in zero page
LDA #<data_table    ; Low byte
STA zp_ptr
LDA #>data_table    ; High byte
STA zp_ptr+1

; Indirect addressing through zero page pointer
LDY #0
LDA (zp_ptr),Y      ; Load from address in zp_ptr

; Stack usage
PHA                 ; Push A
TXA
PHA                 ; Push X
; ... use A and X ...
PLA                 ; Pull X
TAX
PLA                 ; Pull A

; Accessing PPU registers
LDA $2002           ; Read PPU status (clears VBlank flag)
LDA #$20
STA $2006           ; PPU address high
LDA #$00
STA $2006           ; PPU address low
LDA $2007           ; Read from PPU data

data_table:
    .byte $01, $02, $03
```

## Explicit Non-Goals

This section does not cover:
* Detailed PPU memory layout (see 1.4)
* Cartridge mapper details (see 1.5)
* Timing-critical memory access (see 2.1, 2.3)
* Data-oriented design patterns (see 3.2)
* Memory map cheatsheet (see 4.3)

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.2 (CPU), 1.4 (PPU), 1.5 (ROM)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.2 (Data-Oriented Design)
- Related Cheatsheets: 4.3 (Memory Cheatsheets)
