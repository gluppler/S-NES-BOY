# 1.4 PPU Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES**: Primary focus (Ricoh 2C02 PPU)
- ✅ **Famicom**: Fully compatible (same Ricoh 2C02 PPU)
- ❌ **SNES**: Does not apply (SNES uses different PPU architecture - multiple layers, Mode 7, different sprite system)

**Note**: SNES PPU is fundamentally different with multiple background layers, Mode 7 effects, and enhanced sprite capabilities. This document covers NES/Famicom PPU only.

## Physical Hardware Overview

The **Ricoh 2C02 PPU** (Picture Processing Unit) is a separate chip from the CPU, operating at approximately 5.37 MHz (NTSC) or 5.32 MHz (PAL). The PPU has:

* Its own 14-bit address bus (16 KB addressable)
* 2 KB of internal VRAM (Video RAM)
* Separate data bus from CPU
* Hardware sprite evaluation and rendering logic
* Palette RAM (32 bytes)

The CPU communicates with the PPU exclusively through memory-mapped registers at $2000–$2007.

## NES/Famicom Terminology Definitions

* **Tile**: 8×8 pixel pattern, stored as 16 bytes (2 bitplanes × 8 rows)
* **Pattern Table**: 256 tiles (4 KB), contains tile graphics data
* **Name Table**: 32×30 tile map (960 bytes), defines which tiles appear on screen
* **Attribute Table**: 32×30 byte map (64 bytes), defines palette for 2×2 tile groups
* **Sprite**: 8×8 or 8×16 pixel object, can appear above or below background
* **OAM**: Object Attribute Memory, 256 bytes defining 64 sprites
* **Palette**: 4-color set (1 transparent + 3 colors), 8 palettes total (4 background + 4 sprite)
* **VBlank**: Period when PPU is not rendering (safe for VRAM access)
* **Scanline**: One horizontal line of video output

## Core Rules and Invariants

### Tiles vs Pixels

* NES renders in **tiles** (8×8 pixels), not individual pixels
* Each tile uses 16 bytes: 8 bytes for bitplane 0, 8 bytes for bitplane 1
* Each pixel is 2 bits (4 colors per tile from one palette)
* Background tiles come from pattern tables, mapped via name tables

### Pattern Tables

* Two pattern tables: $0000–$0FFF (table 0) and $1000–$1FFF (table 1)
* Each table contains 256 tiles (8×8 pixels each)
* Pattern tables can be CHR ROM (cartridge) or CHR RAM (writable)
* PPU register $2000 bit 4 selects which pattern table is used for background
* PPU register $2000 bit 3 selects which pattern table is used for sprites

### Name Tables

* Four name tables: $2000, $2400, $2800, $2C00 (each 1 KB)
* Each name table is 32×30 tiles (960 bytes)
* Each byte in name table is a tile index (0–255) into pattern table
* Name tables define the background layer
* PPU register $2000 bits 0–1 select which name table is visible
* Name tables can be mirrored (horizontal, vertical, or 4-screen)

### Attribute Tables

* Each name table has an associated 64-byte attribute table
* Attribute table maps 2×2 tile groups to palettes
* Each attribute byte controls 4×4 tiles (2 bits per 2×2 group)
* Attribute byte layout: `DDCCBBAA` (AA=top-left, BB=top-right, CC=bottom-left, DD=bottom-right)
* Attribute tables are located at $23C0, $27C0, $2BC0, $2FC0 (for each name table)

### Sprites vs Backgrounds

* **Background**: Tiles from name tables, rendered first (behind sprites)
* **Sprites**: Objects from OAM, rendered after background (can appear in front)
* Sprites can be 8×8 or 8×16 pixels (PPU register $2000 bit 5)
* Maximum 8 sprites per scanline (hardware limit)
* Sprite 0 hit flag ($2002 bit 6) indicates sprite 0 overlaps background
* Sprites can be disabled per-pixel using background priority bit

### OAM (Object Attribute Memory)

* 256 bytes total, defining 64 sprites (4 bytes each)
* Sprite structure:
  - Byte 0: Y position (top of sprite, 0–239 visible)
  - Byte 1: Tile index
  - Byte 2: Attributes (V H P C C C C C)
    - V: Vertical flip
    - H: Horizontal flip
    - P: Priority (0=in front, 1=behind background)
    - C C C C: Palette (0–3)
  - Byte 3: X position (left of sprite, 0–255, wraps)
* OAM is accessed via $2003 (OAM address) and $2004 (OAM data)

## Minimal Correct Usage Example

```asm
; Disable rendering
LDA #0
STA $2000    ; Disable NMI
STA $2001    ; Disable rendering

; Set PPU address to name table
LDA $2002    ; Reset address latch
LDA #$20
STA $2006    ; High byte of PPU address
LDA #$00
STA $2006    ; Low byte of PPU address

; Write to name table
LDX #0
loop:
    LDA name_table_data,X
    STA $2007    ; Write to PPU, auto-increments address
    INX
    CPX #240     ; Write 240 bytes
    BNE loop

; Set PPU address to palette
LDA $2002       ; Reset latch
LDA #$3F
STA $2006
LDA #$00
STA $2006

; Write palette data
LDX #0
palette_loop:
    LDA palette_data,X
    STA $2007
    INX
    CPX #32
    BNE palette_loop

; Enable rendering
LDA #%10010000  ; Enable NMI, pattern table 0 for background
STA $2000
LDA #%00011110  ; Enable background and sprites
STA $2001

name_table_data:
    .byte $00, $01, $02, $03  ; Tile indices
palette_data:
    .byte $0F, $30, $10, $00  ; Background palette 0
    .byte $0F, $30, $10, $00  ; Background palette 1
    .byte $0F, $30, $10, $00  ; Background palette 2
    .byte $0F, $30, $10, $00  ; Background palette 3
    .byte $0F, $16, $27, $18  ; Sprite palette 0
    .byte $0F, $16, $27, $18  ; Sprite palette 1
    .byte $0F, $16, $27, $18  ; Sprite palette 2
    .byte $0F, $16, $27, $18  ; Sprite palette 3
```

## Explicit Non-Goals

This section does not cover:
* VRAM access timing restrictions (see 2.3)
* Rendering architecture patterns (see 3.3)
* Sprite engine implementations (see 5.1)
* Scrolling techniques (see 5.2)
* PPU register details (see 4.2)

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.3 (Memory)
- Related Advanced Fundamentals: 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets)
