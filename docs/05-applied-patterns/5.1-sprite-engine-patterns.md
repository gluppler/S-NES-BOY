# 5.1 Sprite Engine Patterns

## System Applicability

**This document applies to:**
- ✅ **NES**: Primary focus (64 sprites, 8 per scanline)
- ✅ **Famicom**: Fully compatible (same sprite system)
- ⚠️ **SNES**: Concepts apply but SNES has different sprite system (128 sprites, 32 per scanline, different OAM structure)

**Note**: SNES sprite patterns follow similar principles but SNES has more sprites and different OAM organization. This document covers NES/Famicom sprite patterns.

## Fixed Sprite Slots

**Pattern**: Pre-allocate sprite slots for known entities (player, enemies, projectiles). Each entity type has a fixed range of OAM entries.

**Advantages**:
* Predictable OAM layout
* Easy to update specific entity types
* No dynamic allocation overhead

**Disadvantages**:
* Wastes OAM slots if entities are inactive
* Inflexible (can't exceed slot count)

**Implementation**:
```asm
; Fixed sprite slot allocation
SPRITE_PLAYER = 0        ; Slot 0: Player (1 sprite)
SPRITE_ENEMY_START = 1   ; Slots 1-10: Enemies (10 sprites)
SPRITE_PROJECTILE_START = 11  ; Slots 11-20: Projectiles (10 sprites)
SPRITE_UI_START = 21     ; Slots 21-30: UI elements (10 sprites)
SPRITE_COUNT = 64

; Update player sprite
update_player_sprite:
    LDA player_y
    STA oam_buffer + (SPRITE_PLAYER * 4) + 0  ; Y
    LDA #$00
    STA oam_buffer + (SPRITE_PLAYER * 4) + 1  ; Tile
    LDA #%00000000
    STA oam_buffer + (SPRITE_PLAYER * 4) + 2  ; Attr
    LDA player_x
    STA oam_buffer + (SPRITE_PLAYER * 4) + 3  ; X
    RTS

; Update enemy sprites
update_enemy_sprites:
    LDX #0          ; Enemy index
    LDY #SPRITE_ENEMY_START  ; OAM index
enemy_loop:
    LDA enemy_active,X
    BEQ enemy_off_screen
    
    ; Enemy is active, update sprite
    LDA enemy_y,X
    STA oam_buffer + (Y * 4) + 0
    LDA enemy_tile,X
    STA oam_buffer + (Y * 4) + 1
    LDA enemy_attr,X
    STA oam_buffer + (Y * 4) + 2
    LDA enemy_x,X
    STA oam_buffer + (Y * 4) + 3
    
    INY
    CPY #(SPRITE_ENEMY_START + 10)
    BEQ enemy_done
    
enemy_off_screen:
    ; Move sprite off-screen
    LDA #$FF
    STA oam_buffer + (Y * 4) + 0
    
    INY
    CPY #(SPRITE_ENEMY_START + 10)
    BNE enemy_loop
    
enemy_done:
    RTS
```

## Dynamic Sprite Allocation

**Pattern**: Allocate sprite slots on-demand from a free list. Sprites are allocated when entities spawn and freed when entities despawn.

**Advantages**:
* Efficient OAM usage (only active sprites use slots)
* Flexible (can allocate any number up to 64)
* Better for variable entity counts

**Disadvantages**:
* More complex (requires free list management)
* Fragmentation possible (gaps in OAM)
* Allocation overhead

**Implementation**:
```asm
; Sprite free list (bitmap: 1 = free, 0 = used)
sprite_free_list = $0400  ; 8 bytes (64 bits)

; Initialize free list (all sprites free)
init_sprite_free_list:
    LDA #$FF
    LDX #8
init_loop:
    STA sprite_free_list-1,X
    DEX
    BNE init_loop
    RTS

; Allocate a sprite slot (returns slot index in A, or $FF if none available)
allocate_sprite:
    LDX #0          ; Byte index
    LDY #0          ; Bit index
alloc_loop:
    LDA sprite_free_list,X
    BEQ next_byte   ; No free bits in this byte
    
    ; Find first set bit
    LDY #0
find_bit:
    LSR A
    BCS bit_found
    INY
    CPY #8
    BNE find_bit
    
next_byte:
    INX
    CPX #8
    BNE alloc_loop
    
    ; No free sprites
    LDA #$FF
    RTS
    
bit_found:
    ; Calculate slot index: X * 8 + Y
    TXA
    ASL A
    ASL A
    ASL A
    CLC
    ADC bit_index_table,Y
    PHA             ; Save slot index
    
    ; Mark sprite as used
    LDA sprite_free_list,X
    AND bit_clear_table,Y
    STA sprite_free_list,X
    
    PLA             ; Restore slot index
    RTS

; Free a sprite slot (A = slot index)
free_sprite:
    PHA
    ; Calculate byte and bit: slot / 8, slot % 8
    LSR A
    LSR A
    LSR A
    TAX             ; Byte index
    PLA
    AND #$07
    TAY             ; Bit index
    
    ; Mark sprite as free
    LDA sprite_free_list,X
    ORA bit_set_table,Y
    STA sprite_free_list,X
    
    RTS

; Bit manipulation tables
bit_index_table:
    .byte 0, 1, 2, 3, 4, 5, 6, 7
bit_clear_table:
    .byte %11111110, %11111101, %11111011, %11110111
    .byte %11101111, %11011111, %10111111, %01111111
bit_set_table:
    .byte %00000001, %00000010, %00000100, %00001000
    .byte %00010000, %00100000, %01000000, %10000000
```

## Sprite Flicker Prevention

**Pattern**: Rotate sprite priorities or limit sprites per scanline to prevent flicker when >8 sprites overlap.

**Common Techniques**:
1. **Sprite priority rotation**: Rotate which sprites are visible each frame
2. **Distance-based culling**: Hide distant sprites when too many are on-screen
3. **Static allocation**: Reserve slots for important sprites (player, UI)

**Implementation** (Priority Rotation):
```asm
; Rotate sprite visibility each frame to prevent flicker
sprite_rotation = $20  ; Zero page: rotation offset

update_sprite_rotation:
    INC sprite_rotation
    LDA sprite_rotation
    AND #$07        ; Rotate 0-7
    STA sprite_rotation
    RTS

; Update sprites with rotation
update_sprites_with_rotation:
    LDX #0          ; Entity index
    LDY #0          ; OAM index
    LDA sprite_rotation
    STA temp_rotation
    
sprite_loop:
    ; Check if sprite should be visible this frame
    LDA temp_rotation
    CMP entity_index,X
    BCC sprite_hide  ; Rotation < index: hide
    
    ; Sprite is visible, update OAM
    LDA entity_y,X
    STA oam_buffer + (Y * 4) + 0
    ; ... update other sprite data ...
    
    INY
    JMP sprite_next
    
sprite_hide:
    ; Move sprite off-screen
    LDA #$FF
    STA oam_buffer + (Y * 4) + 0
    
sprite_next:
    INX
    CPX #entity_count
    BNE sprite_loop
    
    RTS
```

## Cross-References

- Related Fundamentals: 1.4 (PPU Fundamentals)
- Related Advanced Fundamentals: 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets)
