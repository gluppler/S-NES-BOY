# 3.1 The Game Loop

## System Applicability

**This document applies to:**
- ✅ **Game Boy (DMG): Primary focus
- ✅ **Game Boy Color (CGB): Fully compatible

## Concept Definition

The Game Boy game loop separates **game logic execution** (main loop) from **rendering updates** (interrupt handlers). The main loop prepares rendering data (OAM buffers, tile updates), while interrupt handlers apply these updates to the PPU during safe windows (VBlank). This decoupling prevents rendering from blocking game logic and ensures all PPU updates occur during safe LCD mode windows.

## Subsystems Involved

* **CPU: Executes game logic, builds rendering queues
* **PPU: Receives rendering updates during VBlank
* **WRAM: Stores OAM buffers, rendering state
* **VRAM: PPU memory (tiles, tilemaps)
* **OAM: Sprite attribute memory (160 bytes, 40 sprites)
* **Interrupt System: Provides frame synchronization

## Step-by-Step Data Flow

1. **Main Loop (Game Logic):
   - Clear OAM buffer (set all sprites off-screen)
   - Build sprite list (iterate entities, write to OAM buffer)
   - Build tile update queue (tiles to change this frame)
   - Prepare palette changes (if CGB)
   - Set rendering flags (scroll changes, window position)

2. **VBlank Interrupt (Rendering Execution):
   - OAM DMA: Copy OAM buffer to OAM ($FF46)
   - Process tile update queue: Write tiles to VRAM
   - Update palettes: Write to palette registers (CGB)
   - Update scroll: Write scroll registers
   - Update window: Write window position registers
   - Increment frame counter

3. **PPU Rendering (Automatic):
   - PPU reads tilemaps, tiles, OAM
   - PPU generates pixels and outputs to LCD
   - Process repeats next frame

## Timing Implications

* **VBlank window: ~4560 cycles (10 scanlines × 456 cycles) for all PPU updates
* **OAM DMA: 160 cycles (blocks CPU during transfer)
* **VRAM writes: ~2 cycles per byte (via memory-mapped I/O)
* **Frame timing: All rendering updates must complete during VBlank
* **Double buffering: Can prepare next frame's data while current frame renders

## Why This Pattern Exists on Game Boy Specifically

* **VBlank constraint: VRAM/OAM access only safe during VBlank
* **Limited VBlank time: ~4560 cycles requires efficient updates
* **OAM DMA requirement: Hardware requires OAM updates via DMA
* **Decoupling: Separating preparation from execution prevents blocking
* **Deterministic rendering: Frame-based updates enable consistent visuals

## Failure Modes and Visible Symptoms

* **OAM buffer overflow: >40 sprites cause sprite flicker or missing sprites
* **VRAM updates outside VBlank: Visual corruption, tile glitches
* **Long VBlank handler: Exceeds VBlank duration, causes frame drops
* **Not clearing OAM buffer: Old sprites remain visible
* **Scroll desync: Scroll registers not updated every frame cause jitter

## Minimal Example

```asm
SECTION "Code", ROM0[$0150]

main_loop:
    halt            ; Wait for interrupt
    call update_game
    jp main_loop

SECTION "VBlank", ROM0[$0040]
    jp vblank_handler

vblank_handler:
    push af
    call update_oam_dma
    pop af
    reti
```

## Gold Standard Example

```asm
; Complete Game Boy game loop example
SECTION "OAM Buffer", WRAM0[$C000]
oam_buffer:
    ds $00A0         ; 160 bytes (40 sprites)

SECTION "Game State", WRAM0[$C100]
frame_counter:
    ds 1
scroll_x:
    ds 1
scroll_y:
    ds 1

SECTION "VBlank", ROM0[$0040]
    jp vblank_handler

SECTION "Code", ROM0[$0150]

; Main game loop
main_loop:
    ; Per Pan Docs: Use halt for power efficiency
    halt            ; Wait for interrupt (saves power)
    
    ; Game logic (executes after interrupt)
    call process_input
    call update_game_state
    call prepare_rendering
    
    jp main_loop

; VBlank interrupt handler
vblank_handler:
    ; Per Pan Docs: Must preserve all registers
    push af
    push bc
    push de
    push hl
    
    ; Rendering updates (safe during VBlank)
    call update_oam_dma
    call update_scroll
    call update_tiles
    call frame_counter_inc
    
    pop hl
    pop de
    pop bc
    pop af
    reti            ; Return and enable interrupts

; Update OAM via DMA
update_oam_dma:
    ; Start OAM DMA transfer
    ld a, HIGH(oam_buffer)
    ld [rDMA], a
    
    ; Wait for DMA (160 cycles)
    ld a, 40
.wait:
    dec a
    jr nz, .wait
    
    ret

; Update scroll registers
update_scroll:
    ld a, [scroll_x]
    ld [rSCX], a
    ld a, [scroll_y]
    ld [rSCY], a
    ret

; Update tiles (if needed)
update_tiles:
    ; Process tile update queue
    ; Write tiles to VRAM during VBlank
    ret

; Increment frame counter
frame_counter_inc:
    ld hl, frame_counter
    inc [hl]
    ret
```

## Cross-References

- Related Fundamentals: 1.5 (Execution Flow)
- Related Advanced Fundamentals: 2.2 (LCD Controller Modes), 2.4 (Interrupt System)
- Related Core Concepts: 3.2 (Rendering Pipeline), 3.4 (Input → State → Render Pipeline)
