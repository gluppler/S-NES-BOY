# 3.2 Rendering Pipeline

## System Applicability

**This document applies to:**
- ✅ **Game Boy (DMG): Primary focus
- ✅ **Game Boy Color (CGB): Differences explicitly labeled

## Concept Definition

The Game Boy rendering pipeline processes background tiles, window tiles, and sprites to generate the final pixel output. The PPU reads tile data from VRAM, applies palettes, and composites layers according to priority rules. All rendering is automatic; the CPU only prepares data (tiles, tilemaps, OAM) during safe access windows.

## Subsystems Involved

* **PPU: Reads tile data and generates pixels
* **VRAM: Stores tile graphics and tilemaps
* **OAM: Stores sprite attributes
* **Palette Registers: Define colors (DMG: fixed, CGB: programmable)
* **LCD: Displays final pixel output
* **CPU: Prepares rendering data during VBlank

## Step-by-Step Data Flow

1. **CPU Preparation (VBlank):
   - Update OAM buffer in WRAM
   - Update tile data in VRAM (if needed)
   - Update tilemap in VRAM (if needed)
   - Update scroll registers
   - Update window position (if used)
   - Start OAM DMA transfer

2. **PPU Rendering (Automatic, per scanline):
   - Mode 2 (OAM Search): Evaluate sprites for current scanline
   - Mode 3 (Pixel Transfer): Read tile data, apply palettes, composite layers
   - Mode 0 (HBlank): Prepare for next scanline
   - Repeat for 144 visible scanlines

3. **Layer Compositing (Mode 3):
   - Background layer: Tilemap → Tiles → Palette → Pixels
   - Window layer: Tilemap → Tiles → Palette → Pixels (if enabled)
   - Sprite layer: OAM → Tiles → Palette → Pixels
   - Priority rules: Sprites can be behind or in front of background
   - Final output: Composite all visible layers

4. **VBlank (Mode 1):
   - PPU idle, safe for CPU access
   - CPU prepares next frame's data
   - Process repeats

## Timing Implications

* **Frame duration: ~59,727 CPU cycles (4.19 MHz / 60 Hz)
* **VBlank duration: ~4560 cycles (10 scanlines × 456 cycles)
* **Visible rendering: ~54,864 cycles (144 scanlines × 381 cycles average)
* **OAM DMA: 160 cycles (blocks CPU)
* **VRAM access: Only during VBlank or HBlank

## Why This Pattern Exists on Game Boy Specifically

* **Hardware rendering: PPU handles all pixel generation automatically
* **VBlank constraint: CPU can only update rendering data during VBlank
* **OAM DMA: Hardware requires sprite updates via DMA
* **Tile-based: Rendering uses 8×8 pixel tiles (efficient for limited memory)
* **Layer system: Background, window, and sprites composite automatically

## Failure Modes and Visible Symptoms

* **VRAM updates during Mode 3: Tile corruption, visual glitches
* **OAM updates during Mode 2-3: Sprite corruption, missing sprites
* **Incorrect tile numbers: Wrong tiles displayed
* **Wrong palettes: Incorrect colors
* **Priority errors: Sprites appear in wrong order

## Minimal Example

```asm
; Basic rendering setup
init_rendering:
    ; Load tiles to VRAM
    call load_tiles
    
    ; Load tilemap to VRAM
    call load_tilemap
    
    ; Enable background
    ld a, %10010001  ; LCD on, BG on
    ld [rLCDC], a
    ret
```

## Gold Standard Example

```asm
; Complete Game Boy rendering pipeline example
SECTION "Code", ROM0[$0150]

; Initialize rendering
init_rendering:
    ; Wait for VBlank
    call wait_vblank
    
    ; Disable LCD
    xor a
    ld [rLCDC], a
    
    ; Load tiles to VRAM
    call load_tiles
    
    ; Load tilemap to VRAM
    call load_tilemap
    
    ; Initialize palettes
    call init_palettes
    
    ; Clear OAM
    call clear_oam
    
    ; Set scroll
    xor a
    ld [rSCX], a
    ld [rSCY], a
    
    ; Enable LCD
    ld a, %10010001  ; LCD on, BG on, tiles at $8000, BG tilemap at $9800
    ld [rLCDC], a
    
    ret

; Load tiles to VRAM
load_tiles:
    ; Per Pan Docs: Must be done during VBlank
    call wait_vblank
    
    ; Copy tile data to VRAM $8000-$97FF
    ld hl, tile_data
    ld de, $8000
    ld bc, $1800     ; 384 tiles × 16 bytes = 6144 bytes
    call copy_memory
    
    ret

; Load tilemap to VRAM
load_tilemap:
    ; Per Pan Docs: Must be done during VBlank
    call wait_vblank
    
    ; Copy tilemap to VRAM $9800-$9BFF (32×32 tiles = 1024 bytes)
    ld hl, tilemap_data
    ld de, $9800
    ld bc, $0400     ; 1024 bytes
    call copy_memory
    
    ret

; Initialize palettes
init_palettes:
    ; DMG: Fixed 4-shade palette
    ; CGB: Programmable palettes
    ld a, [w_is_cgb]
    or a
    jr z, .dmg_palette
    
    ; CGB palette initialization
    call init_cgb_palettes
    ret
    
.dmg_palette:
    ; DMG palette: %11100100 = White, Light Gray, Dark Gray, Black
    ld a, %11100100
    ld [rBGP], a     ; Background palette
    ld [rOBP0], a   ; Sprite palette 0
    ld [rOBP1], a   ; Sprite palette 1
    ret

; Copy memory
copy_memory:
    ld a, [hl+]
    ld [de], a
    inc de
    dec bc
    ld a, b
    or c
    jr nz, copy_memory
    ret
```

## Cross-References

- Related Fundamentals: 1.1 (Game Boy System Overview), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.2 (LCD Controller Modes), 2.3 (Memory Access Restrictions)
- Related Core Concepts: 3.1 (The Game Loop), 3.3 (Tile and Tilemap System)
