# 6.2 Emulators & Debuggers

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus (Mesen2, FCEUX)
- ✅ **: Fully compatible (same emulators)


## Mesen2 Workflow

**Mesen2** is a cycle-accurate NES emulator with built-in debugger.

### Installation

```bash
# Download from https://www.mesen.ca/
# Or use package manager
sudo pacman -S mesen2  # Arch Linux
```

### Basic Debugging Workflow

1. **Load ROM: File → Open ROM
2. **Set Breakpoints: Debug → Breakpoints → Add
3. **Run: F5 (run), F10 (step over), F11 (step into)
4. **Inspect: View → CPU, PPU, Memory, etc.

### Breakpoints

**CPU Breakpoint:
- Address: `$8000` (or label)
- Condition: Always, or register value
- Action: Break, log, or both

**PPU Breakpoint:
- Scanline: `241` (VBlank start)
- Condition: Always or specific PPU state

**Memory Breakpoint:
- Address: `$0200` (OAM buffer)
- Access: Read, Write, or Both
- Value: Specific value (optional)

### Debug Views

**CPU View:
- Registers (A, X, Y, SP, PC, P)
- Disassembly
- Stack
- Memory

**PPU View:
- Pattern tables
- Name tables
- Palettes
- OAM (sprites)
- Current scanline

**Memory View:
- CPU RAM ($0000–$1FFF)
- PPU RAM ($2000–$3FFF)
- Cartridge ROM ($8000–$FFFF)

### Common Debugging Tasks

**Find why sprite isn't appearing:
1. Set breakpoint at OAM DMA ($4014 write)
2. Inspect OAM buffer ($0200–$02FF)
3. Check sprite Y position (should be 0–239)
4. Check PPU mask ($2001) — sprites enabled?

**Find why tile is wrong:
1. Set breakpoint at VRAM write ($2007 write)
2. Inspect PPU address ($2006)
3. Check name table buffer
4. Verify tile index matches pattern table

**Find timing issue:
1. Enable cycle counter in debugger
2. Set breakpoint at NMI start
3. Count cycles until next breakpoint
4. Verify NMI completes in < 2,000 cycles

## PPU Viewers

**Mesen2 PPU Viewer:
- View → PPU Viewer
- Shows pattern tables, name tables, palettes in real-time
- Useful for debugging graphics issues

**FCEUX PPU Viewer:
- Tools → PPU Viewer
- Similar functionality to Mesen2

## Breakpoint Examples

**Break on NMI:
```
Address: $FFFA (NMI vector)
Condition: Always
Action: Break
```

**Break on sprite 0 hit:
```
Address: $2002 (PPU status)
Condition: Value & $40 != 0 (sprite 0 hit flag)
Action: Break
```

**Break on OAM write:
```
Address: $2004 (OAM data)
Access: Write
Action: Break
```

**Break on specific scanline:
```
PPU Breakpoint:
Scanline: 241
Condition: Always
Action: Break
```

## Memory Inspection

**Inspect OAM buffer:
```
Address: $0200
Size: 256 bytes
Format: Hex
```

**Inspect zero page:
```
Address: $0000
Size: 256 bytes
Format: Hex
```

**Inspect name table:
```
Address: $2000 (via PPU viewer)
Size: 960 bytes (32×30 tiles)
Format: Tile indices
```

## Logging

**Enable logging:
- Debug → Logging → Enable
- Log CPU instructions, PPU events, APU events

**Filter logs:
- Show only CPU instructions
- Show only PPU writes
- Show only specific addresses

## Common Debugging Scenarios

**Game freezes:
1. Check if NMI is firing (breakpoint at NMI)
2. Check if main loop is running (breakpoint in main loop)
3. Check stack overflow (SP < $0100)
4. Check infinite loop (PC doesn't change)

**Graphics corruption:
1. Check VRAM writes during rendering (breakpoint at $2007 during scanline 0–239)
2. Check OAM corruption (inspect OAM buffer)
3. Check palette corruption (inspect $3F00–$3F1F)

**Input not working:
1. Breakpoint at controller read ($4016)
2. Check if strobe is set (write $01 then $00 to $4016)
3. Check button state in memory

## Cross-References

- Related Advanced Fundamentals: 2.2 (NMI & VBlank Discipline), 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.1 (Game Loop), 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets), 4.4 (Timing Cheatsheets)
