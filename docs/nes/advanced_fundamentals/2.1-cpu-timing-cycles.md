# 2.1 CPU Timing & Cycles

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus (Ricoh 2A03 CPU timing)
- ✅ **: Fully compatible (same Ricoh 2A03 CPU)


## Hardware Behavior

The Ricoh 2A03 CPU executes instructions over a variable number of **cycles**. Each cycle corresponds to one master clock period. On NTSC systems, the CPU runs at 1.789773 MHz, meaning one cycle = ~559 nanoseconds.

The CPU fetches and executes instructions sequentially. Most instructions require 2–7 cycles, depending on:
* Addressing mode (zero page vs absolute)
* Page boundary crossings
* Branch taken/not taken
* Index register usage

## Why This Behavior Exists

The 6502 architecture was designed for cost-effectiveness. Simpler addressing modes (zero page) use fewer cycles because they require fewer memory accesses. Page boundary crossings add cycles because the address calculation must fetch an additional byte.

Branch instructions use relative addressing (±127 bytes) to save space, but taken branches require an extra cycle to update the program counter.

## Exact Rules and Constraints

### Instruction Cycle Counts

| Instruction | Addressing Mode | Cycles | Notes |
|------------|----------------|--------|-------|
| LDA | Immediate | 2 | |
| LDA | Zero Page | 3 | |
| LDA | Zero Page,X | 4 | |
| LDA | Absolute | 4 | |
| LDA | Absolute,X | 4–5 | +1 if page crossed |
| LDA | Absolute,Y | 4–5 | +1 if page crossed |
| LDA | (Indirect,X) | 6 | |
| LDA | (Indirect),Y | 5–6 | +1 if page crossed |
| STA | Zero Page | 3 | |
| STA | Absolute | 4 | |
| STA | Absolute,X | 5 | |
| STA | (Indirect,X) | 6 | |
| STA | (Indirect),Y | 6 | |
| JMP | Absolute | 3 | |
| JMP | Indirect | 5 | |
| JSR | Absolute | 6 | |
| RTS | Implied | 6 | |
| Branch (taken) | Relative | 3 | +1 if page crossed |
| Branch (not taken) | Relative | 2 | |

### Branch Penalties

* **Branch taken: 3 cycles (2 if not taken)
* **Page boundary crossing: +1 cycle (when branch target crosses $XX00/$XXFF)
* **Branch distance: ±127 bytes maximum (signed 8-bit offset)

### Page Boundary Crossings

A page boundary crossing occurs when:
* Indexed addressing crosses $XXFF → $YY00
* Branch target crosses $XXFF → $YY00

Examples:
* `LDA $12FF,X` with X=1 crosses from $1300 to $1300 (no crossing)
* `LDA $12FF,X` with X=2 crosses from $1301 to $1300 (crossing, +1 cycle)
* `BEQ target` where target is at $1300 and PC is at $12FF (crossing, +1 cycle)

## Timing Considerations

### Frame Timing (NTSC)

* One frame = 262 scanlines
* One scanline = ~341 CPU cycles (63.5 µs)
* One frame = ~29,780 CPU cycles (~16.67 ms)
* VBlank period = ~2,270 CPU cycles (~1.27 ms)

### Cycle Accuracy Matters Because

* **Audio timing: APU registers must be updated at precise intervals
* **PPU synchronization: VRAM writes must occur during safe windows
* **Controller polling: Must read controller state at consistent times
* **Sprite DMA: OAM DMA ($4014) takes exactly 513 cycles
* **Deterministic gameplay: Frame-perfect inputs require cycle accuracy

## Common Mistakes and Incorrect Assumptions

* **Assuming all instructions take the same time: Cycle counts vary significantly
* **Ignoring page boundary penalties: Can cause timing drift
* **Not accounting for branch penalties: Taken branches are slower
* **Using absolute addressing when zero page would work: Wastes cycles
* **Assuming emulator timing matches hardware: Some emulators are inaccurate

## Observable Symptoms When Rules Are Violated

* **Audio glitches: APU updates too early/late cause clicks/pops
* **Sprite flicker: OAM DMA timing errors cause sprite corruption
* **Input lag: Controller polling at wrong times causes missed inputs
* **Racing conditions: Timing-dependent code fails intermittently
* **Emulator-only bugs: Code works in emulator but fails on hardware

## Minimal Example

```asm
; Cycle-accurate delay loop
; Each iteration: DEX (2) + BNE (3 if taken, 2 if not) = 5 cycles (last = 4)
; For 256 iterations: 255 × 5 + 4 = 1279 cycles
delay_256:
    LDX #0
delay_loop:
    DEX
    BNE delay_loop    ; 5 cycles per iteration (except last)

; Precise timing for APU update
; Must update APU registers at specific frame intervals
update_audio:
    LDA frame_counter
    AND #$03         ; Every 4 frames
    BNE skip_update
    ; Update APU registers here (must be cycle-accurate)
skip_update:
    RTS
```

## Fixed Cycle Delay Patterns

For cycle-accurate timing (raster effects, APU synchronization), you need exact cycle delays. Here are common patterns:

### Short Delays (2-10 cycles)

| Cycles | Code | Notes |
|--------|------|-------|
| 2 | `NOP` | Single NOP |
| 4 | `NOP; NOP` | Two NOPs |
| 5 | `BIT $00` | Read zero page (3 cycles) + overhead |
| 6 | `NOP; NOP; NOP` | Three NOPs |
| 7 | `BIT $00; NOP` | |
| 10 | `PHA; PLA` | Push/pull accumulator (3+4 cycles) |

### Medium Delays (10-100 cycles)

```asm
; Delay exactly N cycles (where N is known)
; Pattern: LDX #count; DEX; BNE loop
; Each iteration: 5 cycles (DEX=2, BNE=3)
; Last iteration: 4 cycles (DEX=2, BNE=2 not taken)
; Total: count × 5 - 1 cycles

; Example: 24 cycles
    LDX #5           ; 2 cycles
delay_loop:
    DEX              ; 2 cycles
    BNE delay_loop   ; 3 cycles (taken), 2 cycles (not taken)
    ; Total: 2 + (4×5) + 4 = 26 cycles (adjust count for exact timing)
```

### Long Delays (100+ cycles)

```asm
; Nested loops for longer delays
; Outer loop: LDX #outer; ...; DEX; BNE outer
; Inner loop: LDY #inner; ...; DEY; BNE inner

delay_long:
    LDX #10          ; Outer loop count
outer_loop:
    LDY #20          ; Inner loop count (2 cycles)
inner_loop:
    DEY              ; 2 cycles
    BNE inner_loop   ; 3 cycles (taken), 2 cycles (not taken)
    ; Inner: 2 + (19×5) + 4 = 101 cycles per outer iteration
    DEX              ; 2 cycles
    BNE outer_loop   ; 3 cycles (taken), 2 cycles (not taken)
    ; Total: ~1010 cycles (adjust counts for exact timing)
```

### Precise Cycle Counting Formula

For a delay loop with count `N`:
- Setup: `LDX #N` = 2 cycles
- Loop body: `DEX` (2) + `BNE` (3 taken, 2 not taken)
- Iterations: N-1 taken branches + 1 not-taken branch
- Total: `2 + (N-1)×5 + 4 = 5×N + 1` cycles

To achieve exactly `T` cycles:
- Required iterations: `N = (T - 1) / 5` (rounded)

### Delay Code Examples

```asm
; Delay exactly 100 cycles
delay_100:
    LDX #20          ; 2 cycles
delay_loop:
    DEX              ; 2 cycles
    BNE delay_loop   ; 3 cycles (taken 19 times), 2 cycles (not taken once)
    ; Total: 2 + 19×5 + 4 = 101 cycles (close enough, or adjust)

; Delay exactly 513 cycles (OAM DMA duration)
delay_513:
    LDX #103         ; 2 cycles
delay_loop:
    DEX              ; 2 cycles
    BNE delay_loop   ; 3 cycles (taken 102 times), 2 cycles (not taken)
    ; Total: 2 + 102×5 + 4 = 516 cycles (adjust with NOPs)
    NOP              ; -2 cycles (if needed)
    NOP              ; -2 cycles (if needed)
    ; Final: 512 cycles (or use different pattern)
```

## Cycle Counting Tools and Techniques

### Manual Cycle Counting

1. **Instruction cycles**: Look up in reference table
2. **Page crossings**: Add +1 cycle for indexed addressing or branches
3. **Branch penalties**: +1 cycle if taken, +1 if page crossed
4. **Sum all cycles**: Add up instruction execution times

### Emulator Cycle Counters

- **Mesen2**: Built-in cycle counter in debugger
- **FCEUX**: Cycle counter in debugger
- **Nestopia**: Cycle-accurate timing display

### Cycle Counting Checklist

- [ ] Count each instruction's base cycles
- [ ] Add page crossing penalties for indexed addressing
- [ ] Add branch penalties (taken/not taken, page cross)
- [ ] Account for interrupt overhead (NMI/IRQ)
- [ ] Verify with emulator cycle counter
- [ ] Test on real hardware (emulator may be approximate)

## Timing-Critical Code Patterns

### Raster Effects (Scanline Timing)

```asm
; Wait for specific scanline (cycle-accurate)
wait_scanline:
    LDA $2002        ; Reset VBlank flag
    BIT $2002        ; Check VBlank (bit 7)
    BPL wait_scanline ; Wait for VBlank to clear
    
    ; Now at scanline 0, count cycles to target scanline
    ; Each scanline = 341 CPU cycles (NTSC)
    ; Use delay loops to reach target scanline
    LDX #68          ; Approximate delay for scanline 10
delay_to_scanline:
    DEX
    BNE delay_to_scanline
    
    ; Now at target scanline, perform raster effect
    LDA #%00011110   ; Enable rendering mid-frame
    STA $2001
```

### APU Register Update Timing

```asm
; Update APU registers at precise frame intervals
; Frame counter runs at 240 Hz (4-step) or 192 Hz (5-step)
update_apu_precise:
    ; Must update during specific frame phase
    LDA frame_counter
    AND #$03         ; Every 4 frames (4-step mode)
    BNE skip
    
    ; Update APU registers here
    ; Timing must be consistent (same cycle each frame)
    LDA #$7F
    STA $4000        ; Pulse 1 control
    ; ... more APU updates ...
    
skip:
    RTS
```

## Common Timing Mistakes

### ❌ Mistake: Assuming Fixed Cycle Count

```asm
; BAD: Assumes constant cycle count
    LDA $0300,X      ; 4 cycles if no page cross, 5 if page crossed
    ; Timing varies by 1 cycle!
```

```asm
; GOOD: Account for page crossing
    LDA $0300,X      ; 4-5 cycles
    ; Or use zero page to avoid page crossing
    LDA $00,X        ; Always 4 cycles
```

### ❌ Mistake: Ignoring Branch Penalties

```asm
; BAD: Doesn't account for branch timing
    CMP #10
    BEQ target       ; 2 cycles if not taken, 3 if taken
    ; Timing varies!
```

```asm
; GOOD: Structure code to minimize branch variance
    CMP #10
    BNE not_equal    ; Prefer not-taken (2 cycles)
    ; Equal case (rare)
    JMP equal_code
not_equal:
    ; Not equal case (common)
```

### ❌ Mistake: Variable Delay Loops

```asm
; BAD: Delay depends on register value
    LDX variable     ; Unknown cycles
delay:
    DEX
    BNE delay
```

```asm
; GOOD: Fixed delay or account for variable
    LDX #fixed_count ; Known cycles
delay:
    DEX
    BNE delay
```

## Observable Symptoms When Rules Are Violated

* **Audio glitches: APU updates too early/late cause clicks/pops
* **Sprite flicker: OAM DMA timing errors cause sprite corruption
* **Input lag: Controller polling at wrong times causes missed inputs
* **Racing conditions: Timing-dependent code fails intermittently
* **Emulator-only bugs: Code works in emulator but fails on hardware
* **Raster effects fail: Scanline timing incorrect causes visual glitches
* **Frame drops: NMI handler exceeds VBlank window

## Cross-References

- Related Fundamentals: 1.2 (6502 CPU Fundamentals)
- Related Advanced Fundamentals: 2.2 (NMI & VBlank Discipline), 2.5 (Audio Fundamentals)
- Related Core Concepts: 3.1 (Game Loop)
- Related Cheatsheets: 4.1 (CPU Cheatsheets), 4.4 (Timing Cheatsheets)
- Hardware Schematics: [`schematics/nes/`](../../../../schematics/nes/README.md) - CPU circuit diagrams and pin connections
