# 2.2 NMI & VBlank Discipline

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same PPU and interrupt system)


## Hardware Behavior

**NMI (Non-Maskable Interrupt)** is triggered by the PPU at the start of VBlank (scanline 241, NTSC). NMI cannot be disabled by the I flag; it always fires when:
1. PPU register $2000 bit 7 (NMI enable) is set
2. VBlank period begins (PPU status $2002 bit 7 becomes 1)

**VBlank** is the period when the PPU is not rendering visible scanlines. On NTSC:
* Scanlines 0–239: Visible rendering (PPU is busy)
* Scanline 240: Post-render (PPU is idle)
* Scanlines 241–260: VBlank (safe for VRAM access)
* Scanline 261: Pre-render (PPU prepares for next frame)

During VBlank, the PPU is idle and VRAM can be safely accessed via $2006/$2007.

## Why This Behavior Exists

VBlank exists because CRT displays require time to return the electron beam from the bottom-right to top-left of the screen. During this period, the PPU is not generating video signals, making it safe to update VRAM without visual corruption.

NMI provides a hardware-synchronized interrupt that fires exactly once per frame, ensuring game logic runs at a consistent 60 Hz (NTSC) or 50 Hz (PAL) rate.

## Exact Rules and Constraints

### What NMI Really Is

* **Hardware interrupt: Triggered by PPU, not software
* **Non-maskable: Cannot be disabled by SEI (I flag has no effect)
* **Automatic: Fires when VBlank begins (if enabled)
* **Synchronous: Always occurs at the same point in the frame

### What MUST Happen in NMI

* **Read $2002: Clears VBlank flag (prevents multiple NMI calls)
* **Update OAM: Use OAM DMA ($4014) or manual writes ($2003/$2004)
* **Update VRAM: Write to name tables, palettes, pattern tables (if CHR RAM)
* **Update scroll registers: $2005 (x, y scroll) and $2006 (name table select)
* **Frame counter increment: Track frame number for timing
* **Keep it fast: NMI should complete in < 2,270 cycles (VBlank duration)

### What Must NEVER Happen in NMI

* **Long calculations: NMI must return quickly (< ~2000 cycles)
* **Blocking operations: Infinite loops or long delays
* **Unnecessary register writes: Each $2006/$2007 write costs cycles
* **Missing $2002 read: Must read $2002 to clear VBlank flag
* **Re-enabling rendering mid-frame: Only enable at start of VBlank

### Frame Pacing

* **NTSC: 60.098 Hz (one NMI per ~16.67 ms)
* **PAL: 50.007 Hz (one NMI per ~20 ms)
* **Frame counter: Increment once per NMI for consistent timing
* **Game logic: Should run once per frame (in main loop, not NMI)

## Frame Timing Tables

### NTSC Frame Timing (60.098 Hz)

| Period | Scanlines | CPU Cycles | Duration | Safe for VRAM? |
|--------|-----------|------------|----------|----------------|
| Visible rendering | 0-239 | ~81,300 | ~13.43 ms | ❌ NO |
| Post-render | 240 | ~341 | ~0.19 ms | ⚠️ RISKY |
| VBlank | 241-260 | ~2,270 | ~1.27 ms | ✅ YES |
| Pre-render | 261 | ~341 | ~0.19 ms | ⚠️ RISKY |
| **Total frame** | **262** | **~89,400** | **~16.67 ms** | |

### PAL Frame Timing (50.007 Hz)

| Period | Scanlines | CPU Cycles | Duration | Safe for VRAM? |
|--------|-----------|------------|----------|----------------|
| Visible rendering | 0-239 | ~81,300 | ~16.20 ms | ❌ NO |
| Post-render | 240 | ~341 | ~0.20 ms | ⚠️ RISKY |
| VBlank | 241-310 | ~5,830 | ~3.51 ms | ✅ YES |
| Pre-render | 311 | ~341 | ~0.20 ms | ⚠️ RISKY |
| **Total frame** | **312** | **~106,500** | **~20.00 ms** | |

### Scanline Timing (NTSC)

| Scanline Type | CPU Cycles | PPU Activity |
|---------------|------------|--------------|
| Visible (0-239) | ~341 | Rendering tiles/sprites |
| Post-render (240) | ~341 | Idle |
| VBlank (241-260) | ~113.5 | Idle (safe for VRAM) |
| Pre-render (261) | ~341 | Preparing next frame |

## Timing Considerations

### VBlank Duration

* **NTSC: ~2,270 CPU cycles (~1.27 ms, scanlines 241–260)
* **PAL: ~3,270 CPU cycles (~1.97 ms, scanlines 241–310)

### Safe VRAM Access Window

* **Start: After reading $2002 in NMI
* **End: Before scanline 240 (pre-render) of next frame
* **Optimal: Complete all VRAM updates early in VBlank

### NMI Timing Constraints

* **Maximum NMI duration: ~2,000 cycles (leave buffer for main loop)
* **OAM DMA: 513 cycles (must complete during VBlank)
* **VRAM writes: ~2 cycles per byte (via $2007)
* **Scroll updates: 5 cycles ($2005 write × 2)

### NMI Handler Cycle Budget

**Typical NMI handler operations and cycle costs:**

| Operation | Cycles | Notes |
|-----------|--------|-------|
| Register save (PHA×3) | 9 | Save A, X, Y |
| Read $2002 | 4 | Clear VBlank flag, reset latch |
| OAM DMA setup | 4 | Write $2003, $4014 |
| OAM DMA transfer | 513 | Hardware DMA (CPU blocked) |
| Scroll update | 5 | Write $2005 twice |
| PPU control update | 2 | Write $2000 |
| Frame counter increment | 3-5 | INC frame_counter |
| Flag set | 3 | STA frame_ready |
| Register restore (PLA×3) | 12 | Restore A, X, Y |
| RTI | 6 | Return from interrupt |
| **Total** | **~565** | Well under 2,000 cycle budget |

**VBlank budget remaining**: ~1,700 cycles for VRAM updates (if needed)

### VRAM Update Budget

**Maximum VRAM bytes per VBlank (NTSC):**
- VBlank duration: ~2,270 cycles
- NMI overhead: ~565 cycles
- Available for VRAM: ~1,700 cycles
- VRAM write cost: 2 cycles per byte (via $2007)
- **Maximum bytes: ~850 bytes per VBlank**

**Best practice**: Keep VRAM updates <500 bytes per frame to leave buffer.

## Common Mistakes and Incorrect Assumptions

* **Doing game logic in NMI: NMI should only handle rendering updates
* **Not reading $2002: VBlank flag remains set, causing issues
* **Updating VRAM outside VBlank: Causes visual corruption
* **Long NMI handlers: Delays main loop, causes frame drops
* **Assuming NMI fires exactly 60 times per second: Actual rate is 60.098 Hz (NTSC)
* **Not disabling rendering before VRAM updates: Can cause glitches
* **Writing scroll only once: Scroll must be written twice every frame
* **Not resetting scroll latch: Must read $2002 before scroll writes
* **OAM updates during rendering: Causes sprite corruption
* **Assuming VBlank is exactly 2,270 cycles: Actual duration varies slightly

## NMI Handler Anti-Patterns

### ❌ Anti-Pattern: Game Logic in NMI

```asm
; BAD: Game logic in NMI (causes frame drops)
nmi:
    PHA
    TXA
    PHA
    TYA
    PHA
    
    LDA $2002
    
    ; BAD: Game logic in NMI
    JSR update_physics    ; 1000+ cycles
    JSR update_ai          ; 500+ cycles
    JSR check_collisions   ; 300+ cycles
    
    ; NMI takes too long, main loop delayed
    PLA
    TAY
    PLA
    TAX
    PLA
    RTI
```

```asm
; GOOD: NMI only handles rendering
nmi:
    PHA
    TXA
    PHA
    TYA
    PHA
    
    LDA $2002
    
    ; GOOD: Only rendering updates
    LDA #0
    STA $2003
    LDA #>oam_buffer
    STA $4014           ; OAM DMA
    
    LDA scroll_x
    STA $2005
    LDA scroll_y
    STA $2005
    
    LDA ppu_ctrl
    STA $2000
    
    LDA #1
    STA frame_ready      ; Signal main loop
    
    PLA
    TAY
    PLA
    TAX
    PLA
    RTI
```

### ❌ Anti-Pattern: Not Reading $2002

```asm
; BAD: Doesn't read $2002 (VBlank flag not cleared)
nmi:
    ; Missing: LDA $2002
    LDA #0
    STA $2003
    ; VBlank flag remains set, may cause issues
```

```asm
; GOOD: Always read $2002 first
nmi:
    LDA $2002           ; MUST read first (clears flag, resets latch)
    ; ... rest of NMI ...
```

### ❌ Anti-Pattern: VRAM Updates Outside VBlank

```asm
; BAD: VRAM update in main loop (during rendering)
main_loop:
    ; ... game logic ...
    JSR update_background ; Writes to VRAM during scanline 100
    ; Causes visual corruption!
```

```asm
; GOOD: VRAM updates only during VBlank
main_loop:
    ; ... game logic ...
    ; Set dirty flag for VRAM update
    LDA #1
    STA bg_dirty
    
nmi:
    LDA $2002
    ; ... OAM DMA, scroll ...
    
    ; Update VRAM if dirty
    LDA bg_dirty
    BEQ skip_bg_update
    JSR update_background ; Safe during VBlank
    LDA #0
    STA bg_dirty
skip_bg_update:
    RTI
```

## Debugging NMI/VBlank Issues

### Problem: Frame drops or stuttering

**Check:**
1. NMI handler cycle count (use emulator profiler)
2. VRAM update size (keep <500 bytes per frame)
3. OAM DMA timing (must complete during VBlank)
4. Main loop blocking (infinite loops, long delays)

### Problem: Visual corruption

**Check:**
1. VRAM writes during rendering (scanlines 0-239)
2. Missing $2002 read (scroll latch not reset)
3. Scroll not written every frame
4. OAM updates during rendering

### Problem: Sprite glitches

**Check:**
1. OAM DMA timing (must be during VBlank)
2. OAM buffer corruption (writing during rendering)
3. Sprite overflow (>8 sprites per scanline)
4. OAM address not reset before DMA

### Problem: Scroll jitter

**Check:**
1. Scroll written only once per frame (must write twice)
2. Scroll latch not reset (read $2002 before writes)
3. Scroll written during rendering (write during VBlank only)
4. Name table select not synchronized with scroll

## Observable Symptoms When Rules Are Violated

* **Visual corruption: VRAM writes during rendering cause tile/sprite glitches
* **Sprite flicker: OAM updates at wrong time cause sprite disappearance
* **Frame drops: Long NMI handlers delay main loop
* **Input lag: Game logic runs at inconsistent rates
* **Audio desync: APU updates at wrong frame intervals
* **Scroll jitter: Scroll register updates during rendering cause tearing

## Minimal Example

```asm
; Correct NMI handler
nmi:
    PHA             ; Save registers
    TXA
    PHA
    TYA
    PHA
    
    LDA $2002       ; MUST read to clear VBlank flag
    
    ; Update OAM (sprite data)
    LDA #0
    STA $2003       ; OAM address = 0
    LDA #>oam_buffer
    STA $4014       ; Start OAM DMA (513 cycles)
    
    ; Update scroll (must be done every frame)
    LDA scroll_x
    STA $2005       ; X scroll
    LDA scroll_y
    STA $2005       ; Y scroll
    
    ; Update PPU control if needed
    LDA ppu_ctrl
    STA $2000
    
    ; Set frame_ready flag for main loop
    LDA #1
    STA frame_ready
    
    PLA             ; Restore registers
    TAY
    PLA
    TAX
    PLA
    RTI

; Main loop (game logic runs here, not in NMI)
main_loop:
    LDA frame_ready
    BEQ main_loop   ; Wait for NMI
    
    LDA #0
    STA frame_ready ; Clear flag
    
    ; Game logic here (input, physics, AI, etc.)
    JSR read_controllers
    JSR update_game_state
    
    JMP main_loop
```

## Cross-References

- Related Fundamentals: 1.1 (NES System Overview), 1.4 (PPU Fundamentals)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.1 (Game Loop), 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets), 4.4 (Timing Cheatsheets)
- Hardware Schematics: [`schematics/nes/`](../../../../schematics/nes/README.md) - Console circuit diagrams showing NMI connections
