# 2.3 PPU Rendering Rules

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus (Ricoh 2C02 PPU)
- ✅ **: Fully compatible (same Ricoh 2C02 PPU)


## Hardware Behavior

The PPU renders 240 visible scanlines (0–239) plus 22 overhead scanlines (240–261 NTSC). During visible rendering, the PPU:
* Reads name table data to determine background tiles
* Reads pattern table data to fetch tile graphics
* Reads attribute table data to determine palettes
* Evaluates sprites (up to 8 per scanline)
* Generates pixel data and outputs to TV

The PPU has **strict timing requirements** for VRAM access. Writing to VRAM during rendering causes visual corruption because the PPU is actively reading from VRAM.

## Why This Behavior Exists

The PPU operates independently from the CPU on a separate bus. During rendering, the PPU continuously reads from VRAM to fetch tile and sprite data. If the CPU writes to VRAM simultaneously, the PPU may read corrupted or partially-written data, causing visual glitches.

The PPU's internal address latch ($2006) and data register ($2007) have specific write sequences that must be followed exactly.

## Exact Rules and Constraints

### VRAM Access Restrictions

* **During rendering (scanlines 0–239): VRAM writes cause corruption
* **During VBlank (scanlines 241–260 NTSC): VRAM writes are safe
* **During forced blanking: VRAM writes are safe (rendering disabled via $2001)

### $2006/$2007 Write Rules

**Setting PPU Address ($2006):
1. First write: High byte of address (bits 14–8)
2. Second write: Low byte of address (bits 7–0)
3. Address latch is reset after reading $2002
4. Address auto-increments by 1 or 32 after $2007 read/write (controlled by $2000 bit 2)

**Reading/Writing PPU Data ($2007):
1. First read after $2006 write returns **buffered data** (invalid)
2. Subsequent reads return actual PPU data
3. Writes go directly to PPU (no buffering)
4. Address increments automatically (by 1 or 32, depending on $2000 bit 2)

### Scroll Latch Behavior

**Scroll Register ($2005):
* First write: Fine X scroll (0–7) + coarse X scroll (0–31)
* Second write: Fine Y scroll (0–7) + coarse Y scroll (0–29)
* Scroll latch is reset after reading $2002
* Must be written **twice per frame** (in NMI) to maintain scroll position

**Name Table Select ($2006):
* Bits 0–1 of $2000 select which name table is visible
* Writing to $2006 also sets name table (bits 10–11 of address)
* Scroll and name table must be synchronized

### Sprite Evaluation Quirks

* **Sprite 0 Hit: Flag ($2002 bit 6) is set when sprite 0 pixel overlaps background pixel
* **8 Sprite Limit: Maximum 8 sprites per scanline (hardware limit)
* **Sprite Overflow: Flag ($2002 bit 5) is set when >8 sprites on a scanline (unreliable)
* **OAM Corruption: Reading $2002 during rendering can corrupt OAM (sprite evaluation period)

### Safe VRAM Write Windows

* **VBlank: Scanlines 241–260 (NTSC), 241–310 (PAL) — **primary window
* **Forced Blanking: When $2001 bit 3 = 0 (rendering disabled) — **always safe
* **Pre-render: Scanline 261 (NTSC) — **sometimes safe, not recommended

## Timing Considerations

### VRAM Write Timing

* **$2006 write: 2 cycles per byte (high, then low)
* **$2007 write: 2 cycles per byte
* **Bulk writes: ~2 cycles per byte (limited by VBlank duration)
* **Maximum bytes per VBlank: ~1,135 bytes (NTSC, theoretical)

### Sprite DMA Timing

* **OAM DMA ($4014): Exactly 513 cycles
* **Must complete during VBlank: DMA blocks CPU during transfer
* **Manual OAM writes: 2 cycles per byte via $2003/$2004

## Common Mistakes and Incorrect Assumptions

* **Writing to VRAM during rendering: Causes tile corruption, sprite glitches
* **Not reading $2002 before $2006: Address latch may be in wrong state
* **Using first $2007 read: First read is buffered, invalid data
* **Forgetting to update scroll: Scroll must be written twice per frame
* **Reading $2002 during rendering: Can corrupt OAM (sprite evaluation)
* **Assuming all emulators enforce VRAM restrictions: Some are lenient

## PPU Register Write Timing Table

| Register | Write Cycles | Safe to Write | Notes |
|----------|--------------|---------------|-------|
| $2000 (PPUCTRL) | 2 | Anytime | Controls NMI, pattern tables, name table |
| $2001 (PPUMASK) | 2 | Anytime | Controls rendering enable, color emphasis |
| $2002 (PPUSTATUS) | Read-only | Read anytime | Clears VBlank flag, resets address latch |
| $2003 (OAMADDR) | 2 | VBlank only | Sets OAM write address |
| $2004 (OAMDATA) | 2 | VBlank only | Writes to OAM (use DMA instead) |
| $2005 (PPUSCROLL) | 2 | Anytime | Must write twice per frame (X, then Y) |
| $2006 (PPUADDR) | 2 | VBlank only | Sets VRAM address (high, then low) |
| $2007 (PPUDATA) | 2 | VBlank only | Reads/writes VRAM (auto-increments) |

## VRAM Access Timing Windows

### Safe VRAM Access Periods (NTSC)

| Period | Scanlines | CPU Cycles | Safe for VRAM? | Notes |
|--------|-----------|------------|----------------|-------|
| Visible rendering | 0-239 | ~81,300 | ❌ NO | PPU actively reading VRAM |
| Post-render | 240 | ~341 | ⚠️ RISKY | PPU idle, but short window |
| VBlank | 241-260 | ~2,270 | ✅ YES | Primary safe window |
| Pre-render | 261 | ~341 | ⚠️ RISKY | PPU preparing next frame |

**PAL Timing:**
- Visible: 0-239 scanlines
- VBlank: 241-310 scanlines (~5,830 cycles)
- Pre-render: 311 scanline

### Forced Blanking (Always Safe)

When `$2001` bit 3 (background enable) = 0 and bit 4 (sprite enable) = 0:
- VRAM access is **always safe** regardless of scanline
- Use for large VRAM updates (loading levels, palettes)
- Disable rendering, update VRAM, re-enable rendering

## Scroll Register Detailed Behavior

### Scroll Latch Mechanism

The PPU has an internal **scroll latch** that alternates between X and Y scroll:

1. **First write to $2005**: Stores **fine X scroll** (bits 0-2) and **coarse X scroll** (bits 3-7)
2. **Second write to $2005**: Stores **fine Y scroll** (bits 0-2) and **coarse Y scroll** (bits 3-7)
3. **Reading $2002**: Resets latch to X scroll (next write is X)

### Scroll Register Format

| Write | Bits 7-3 | Bits 2-0 | Meaning |
|-------|----------|----------|---------|
| 1st ($2005) | Coarse X (0-31) | Fine X (0-7) | Horizontal scroll |
| 2nd ($2005) | Coarse Y (0-29) | Fine Y (0-7) | Vertical scroll |

**Fine scroll**: Pixel-level offset (0-7 pixels)
**Coarse scroll**: Tile-level offset (0-31 tiles horizontal, 0-29 tiles vertical)

### Scroll Update Pattern

```asm
; CORRECT: Update scroll every frame in NMI
nmi:
    LDA $2002        ; Reset scroll latch (MUST read first)
    
    ; Write scroll registers (must be done every frame)
    LDA scroll_x
    STA $2005        ; First write = X scroll
    LDA scroll_y
    STA $2005        ; Second write = Y scroll
    
    ; Also update name table select if needed
    LDA ppu_ctrl     ; Contains name table bits (0-1)
    STA $2000
```

### Common Scroll Mistakes

**❌ Mistake: Not reading $2002 before scroll update**
```asm
; BAD: Latch state unknown
    LDA scroll_x
    STA $2005        ; May write to Y instead of X!
```

**❌ Mistake: Writing scroll only once**
```asm
; BAD: Scroll resets every frame
    ; Must write twice every frame
```

**❌ Mistake: Writing scroll during rendering**
```asm
; BAD: Causes scroll jitter
    ; Write scroll during VBlank only
```

## Sprite Evaluation Detailed Behavior

### Sprite Evaluation Timing

The PPU evaluates sprites during specific periods:

| Period | Scanlines | Activity |
|--------|-----------|----------|
| Sprite evaluation | 0-239 | PPU scans OAM for sprites on current scanline |
| Sprite fetch | Per scanline | PPU fetches sprite data for rendering |
| OAM corruption window | 64-256 cycles into scanline | Reading $2002 corrupts OAM |

### 8 Sprite Per Scanline Limit

**Hardware limitation**: Maximum 8 sprites can be rendered per scanline.

**Behavior when >8 sprites:**
- First 8 sprites are rendered
- Remaining sprites are **not rendered** (invisible)
- Sprite overflow flag ($2002 bit 5) is set (but unreliable)

**Sprite overflow flag quirks:**
- Flag is set when >8 sprites detected
- Flag is **unreliable** (may be set incorrectly)
- Reading $2002 clears the flag
- **Do not rely on this flag** for sprite management

### Sprite 0 Hit Detection

**Sprite 0 Hit Flag** ($2002 bit 6):
- Set when sprite 0 (first sprite in OAM) pixel overlaps background pixel
- Used for split-screen effects, status bars
- Flag is cleared by reading $2002

**Sprite 0 hit timing:**
- Flag is set during sprite 0 rendering
- Must check flag **after** sprite 0 would be visible
- Typical use: Wait for sprite 0 hit, then change scroll/rendering

```asm
; Wait for sprite 0 hit (for split-screen effect)
wait_sprite0_hit:
    BIT $2002        ; Check sprite 0 hit flag (bit 6)
    BVC wait_sprite0_hit ; Branch if flag not set (V=0)
    
    ; Sprite 0 hit detected, change rendering
    LDA #%00011110   ; Enable rendering
    STA $2001
```

### OAM Corruption During Rendering

**Critical**: Reading $2002 during sprite evaluation (scanlines 0-239, cycles 64-256) **corrupts OAM**.

**Safe periods for $2002 reads:**
- VBlank (scanlines 241-260)
- Pre-render (scanline 261)
- Early in visible scanlines (cycles 0-63)

**Unsafe period:**
- Sprite evaluation (cycles 64-256 of each scanline 0-239)

**Best practice**: Only read $2002 during VBlank or when rendering is disabled.

## PPU Address Latch Behavior

The PPU address latch ($2006) has specific behavior:

1. **First write to $2006**: Stores high byte (bits 14-8 of address)
2. **Second write to $2006**: Stores low byte (bits 7-0 of address)
3. **Reading $2002**: Resets latch (next $2006 write is high byte)
4. **Writing $2007**: Auto-increments address by 1 or 32 (controlled by $2000 bit 2)

### Address Increment Mode

| $2000 bit 2 | Increment | Use Case |
|-------------|-----------|----------|
| 0 | +1 | Sequential VRAM writes (name tables, palettes) |
| 1 | +32 | Column-wise writes (tile columns) |

**Example:**
```asm
; Set increment to +1 (default)
    LDA #%10000000   ; Bit 2 = 0
    STA $2000
    
    ; Write to name table sequentially
    LDA $2002
    LDA #$20
    STA $2006
    LDA #$00
    STA $2006
    ; Each STA $2007 increments address by 1
```

### $2007 Read Buffer Quirk

**Important**: The first read from $2007 after setting $2006 returns **buffered data** (invalid).

**Pattern:**
1. Write to $2006 (set address)
2. First read from $2007 → **Returns buffered data (ignore)**
3. Subsequent reads → Return actual PPU data

**For writes**: No buffering, writes go directly to PPU.

```asm
; CORRECT: Read PPU data
    LDA $2002        ; Reset latch
    LDA #$20
    STA $2006        ; High byte
    LDA #$00
    STA $2006        ; Low byte
    LDA $2007        ; First read = BUFFERED (ignore)
    LDA $2007        ; Second read = ACTUAL data
    LDA $2007        ; Third read = ACTUAL data
```

## Palette RAM Special Behavior

**Palette RAM** ($3F00-$3F1F) has special mirroring:

- $3F00: Universal background color (shared by all palettes)
- $3F01-$3F03: Background palette 0
- $3F05-$3F07: Background palette 1
- $3F09-$3F0B: Background palette 2
- $3F0D-$3F0F: Background palette 3
- $3F11-$3F13: Sprite palette 0
- $3F15-$3F17: Sprite palette 1
- $3F19-$3F1B: Sprite palette 2
- $3F1D-$3F1F: Sprite palette 3

**Note**: Addresses $3F04, $3F08, $3F0C, $3F10, $3F14, $3F18, $3F1C mirror $3F00 (universal background).

**Best practice**: Write to $3F00 first, then write all 32 palette bytes sequentially.

## Observable Symptoms When Rules Are Violated

* **Tile corruption: Background tiles show wrong patterns
* **Sprite glitches: Sprites appear/disappear randomly
* **Palette corruption: Wrong colors appear on screen
* **Scroll jitter: Background scroll position jumps
* **Sprite 0 hit false positives: Flag triggers incorrectly
* **OAM corruption: Sprites have wrong positions/attributes
* **Rendering glitches: Screen tears, incorrect tiles
* **Address corruption: Writes go to wrong VRAM location

## Minimal Example

```asm
; Safe VRAM update during VBlank
update_vram:
    LDA $2002       ; Reset address latch (MUST read first)
    
    ; Update name table
    LDA #$20        ; Name table 0, high byte
    STA $2006
    LDA #$00        ; Name table 0, low byte
    STA $2006
    
    LDX #0
name_loop:
    LDA name_data,X
    STA $2007       ; Write to PPU (auto-increments)
    INX
    CPX #240
    BNE name_loop
    
    ; Update palette
    LDA $2002       ; Reset latch again
    LDA #$3F
    STA $2006       ; Palette address high
    LDA #$00
    STA $2006       ; Palette address low
    
    LDX #0
palette_loop:
    LDA palette_data,X
    STA $2007
    INX
    CPX #32
    BNE palette_loop
    
    ; Update scroll (must be done every frame)
    LDA scroll_x
    STA $2005       ; X scroll
    LDA scroll_y
    STA $2005       ; Y scroll
    
    RTS

; UNSAFE: Writing during rendering (DO NOT DO THIS)
unsafe_update:
    LDA #$20
    STA $2006       ; Writing during scanline 100 = CORRUPTION
    LDA #$00
    STA $2006
    LDA #$42
    STA $2007       ; This will corrupt the display
    RTS
```

## Cross-References

- Related Fundamentals: 1.4 (PPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.2 (NMI & VBlank Discipline)
- Related Core Concepts: 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets), 4.4 (Timing Cheatsheets)
- Hardware Schematics: [`schematics/nes/`](../../../../schematics/nes/README.md) - PPU circuit diagrams and pin connections
