# 2.4 Controller I/O

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same controller interface, though  has hardwired controllers)

**-Specific Notes:
-  controllers are hardwired (not removable)
- Controller 2 has microphone input (not available on NES)
- Same shift register protocol as NES


## Hardware Behavior

NES and controllers use a **serial shift register** interface. Each controller has 8 buttons, represented as 8 bits that are shifted out one at a time.

The controller interface uses two CPU registers:
* **$4016: Controller 1 (write: strobe, read: data)
* **$4017: Controller 2 (read: data, also controls APU frame counter)

The CPU **strobes** the controller (writes 1 then 0 to $4016 bit 0), which loads all 8 button states into an internal shift register. Then, the CPU reads $4016/$4017 eight times, receiving one button state per read (bit 0).

## Why This Behavior Exists

The NES controller uses a simple, cost-effective design: a 4021 shift register IC inside each controller. This requires only 3 wires (clock, data, latch) instead of 8 wires for parallel input, reducing manufacturing cost.

The shift register design means button states must be read sequentially, not in parallel.

## Exact Rules and Constraints

### Shift Register Behavior

1. **Strobe (latch): Write 1 to $4016 bit 0, then 0
   - This loads current button states into shift register
   - All 8 buttons are sampled simultaneously
2. **Read: Read $4016 (controller 1) or $4017 (controller 2) bit 0
   - First read: A button state
   - Second read: B button state
   - Third read: Select button state
   - Fourth read: Start button state
   - Fifth read: Up button state
   - Sixth read: Down button state
   - Seventh read: Left button state
   - Eighth read: Right button state
   - After 8 reads: Returns 1 (no more data)

### Button Bit Order

Reading order (bit 0 of $4016/$4017):
1. A
2. B
3. Select
4. Start
5. Up
6. Down
7. Left
8. Right

**Note: Buttons are active-low (0 = pressed, 1 = released).

### Strobing

* **Strobe sequence: 
  1. LDA #$01
  2. STA $4016
  3. LDA #$00
  4. STA $4016
* **Timing: Strobe can be done at any time (not frame-critical)
* **Frequency: Typically strobed once per frame (in main loop or NMI)

### Reading Controller State

* **Must read 8 times: One read per button
* **Bit 0 only: Other bits are unreliable or used for other purposes
* **Active-low: 0 = pressed, 1 = released
* **After 8 reads: Returns 1 (shift register exhausted)

## Timing Considerations

* **Strobe duration: Minimum 2 cycles (write 1, write 0)
* **Read timing: Can read immediately after strobe
* **Frame timing: Typically read once per frame (60 Hz)
* **No critical timing: Controller reads are not cycle-critical

## Common Mistakes and Incorrect Assumptions

* **Reading only once: Must read 8 times to get all buttons
* **Using wrong bit: Must use bit 0, not other bits
* **Forgetting to strobe: Shift register must be latched before reading
* **Reading in wrong order: Button order is fixed (A, B, Select, Start, Up, Down, Left, Right)
* **Assuming active-high: Buttons are active-low (0 = pressed)
* **Not handling controller 2: $4017 bit 0 for controller 2, bit 7 controls APU frame counter

## Observable Symptoms When Rules Are Violated

* **Missing inputs: Not reading all 8 buttons causes some buttons to be ignored
* **Wrong button mapping: Reading in wrong order maps buttons incorrectly
* **Stuck buttons: Not strobing causes shift register to retain old data
* **Controller 2 not working: Must read from $4017, not $4016

## Minimal Example

```asm
; Read controller 1
read_controller1:
    ; Strobe controller
    LDA #$01
    STA $4016       ; Strobe on
    LDA #$00
    STA $4016       ; Strobe off
    
    ; Read 8 buttons
    LDX #8
    LDY #0
read_loop:
    LDA $4016       ; Read bit 0
    LSR A           ; Shift bit 0 to carry
    ROL controller1 ; Rotate carry into controller1 (bit 0 = A, bit 7 = Right)
    DEY
    BNE read_loop
    
    RTS

; Alternative: Read into zero page
read_controller1_alt:
    ; Strobe
    LDA #$01
    STA $4016
    LDA #$00
    STA $4016
    
    ; Read buttons into zero page variable
    LDA $4016       ; A
    AND #$01
    EOR #$01        ; Invert (0 = pressed, 1 = released)
    STA buttons+0
    
    LDA $4016       ; B
    AND #$01
    EOR #$01
    STA buttons+1
    
    LDA $4016       ; Select
    AND #$01
    EOR #$01
    STA buttons+2
    
    LDA $4016       ; Start
    AND #$01
    EOR #$01
    STA buttons+3
    
    LDA $4016       ; Up
    AND #$01
    EOR #$01
    STA buttons+4
    
    LDA $4016       ; Down
    AND #$01
    EOR #$01
    STA buttons+5
    
    LDA $4016       ; Left
    AND #$01
    EOR #$01
    STA buttons+6
    
    LDA $4016       ; Right
    AND #$01
    EOR #$01
    STA buttons+7
    
    RTS

buttons: .res 8    ; Zero page: button states (0 = pressed, 1 = released)
```

## Cross-References

- Related Fundamentals: 1.2 (6502 CPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: None (controller I/O is simple)
- Related Core Concepts: 3.4 (Input → State → Output Pipeline)
- Related Cheatsheets: None (controller I/O is straightforward)
