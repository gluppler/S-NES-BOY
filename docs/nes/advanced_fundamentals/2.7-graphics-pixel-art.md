# 2.7 Graphics & Pixel Art

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus (tile-based graphics, 8×8 tiles, 4 colors per tile)
- ✅ **: Fully compatible (same graphics system)


## Hardware Constraints


### NES/ Constraints

* **Tile Size: 8×8 pixels (64 pixels per tile)
* **Pattern Table: 512 tiles (256 for background, 256 for sprites, or shared)
* **CHR ROM: 8 KB (512 tiles × 16 bytes) or 16 KB (1024 tiles) for Mapper 0
* **Color Depth: 2 bits per pixel (4 colors per tile)
* **Palette System: 4 palettes × 4 colors = 16 background colors, 4 palettes × 4 colors = 16 sprite colors
* **Total Colors: 64 colors in NES palette, but only 13 unique colors per tile (background color + 3 palette colors)
* **Sprite Limit: 64 sprites per frame, 8 per scanline
* **Sprite Size: 8×8 or 8×16 pixels
* **Name Table: 32×30 tiles (256×240 pixels visible)


* **Tile Size: 8×8 pixels (64 pixels per tile)
* **Pattern Table: Up to 1024 tiles per layer (varies by mode)
* **VRAM: 64 KB total
* **Color Depth: 2, 4, or 8 bits per pixel (depending on mode)
* **Palette System: 256 colors from 15-bit palette (32768 total colors)
* **Sprite Limit: 128 sprites per frame, 32 per scanline
* **Sprite Size: 8×8 to 64×64 pixels (in 8×8 increments)
* **Layers: Up to 4 background layers + sprite layer

## Core Principles

### 1. Tile-Based Thinking

**Rule: All graphics must fit within 8×8 pixel tiles.

* **Background Art: Composed of tiles arranged in name tables
* **Sprites: Individual tiles or multi-tile sprites (2×2, 3×3, etc.)
* **Reusability: Design tiles to be reused across the game
* **Tile Limits: NES has 512 tiles total; plan tile usage carefully

**Example: A character sprite might use 4 tiles (2×2 grid) to create a 16×16 pixel sprite.

### 2. Color Palette Constraints

**NES Palette System:
* Each tile can use 4 colors: background color (transparent for sprites) + 3 palette colors
* Background tiles share 4 palettes (16 colors total)
* Sprite tiles share 4 palettes (16 colors total)
* Background color ($3F00) is shared across all tiles

* 256-color palettes from 15-bit color space
* Each sprite can use 16 colors from a 256-color palette
* Background layers can use 4, 16, or 256 colors depending on mode

**Technique: Design with palette limitations in mind. Use color strategically to maximize visual impact within constraints.

### 3. Pixel Art Techniques

#### Japanese Pixel Art Principles

Based on techniques from Japanese game development (/NES era):

1. **Clean Shapes: Use clear, readable forms
2. **Strategic Pixel Placement: Every pixel matters; avoid unnecessary detail
3. **Color Economy: Maximize visual impact with minimal colors
4. **Readability: Characters and objects must be recognizable at small sizes
5. **Consistency: Maintain consistent style across all graphics

#### Anti-Aliasing (Limited)

* **NES: No true anti-aliasing; use dithering for gradients
* **Technique: Use checkerboard patterns or strategic color placement for smooth transitions

#### Dithering

* **Purpose: Create illusion of more colors or gradients
* **Patterns: 2×2 checkerboard, 1×2 alternating, custom patterns
* **Trade-off: Dithering reduces clarity but increases color range perception

#### Pixel Doubling/Scaling

* **2×2 Sprites: Scale 4×4 quadrant to 8×8 tile by doubling pixels
* **Technique: Extract quadrant from 8×8 character, scale to 8×8 tile
* **Use Case: Creating larger, readable characters from smaller designs

### 4. Tile Organization

#### Pattern Table Layout

**NES Pattern Table Structure:
* **$0000–$0FFF: Pattern table 0 (256 tiles)
* **$1000–$1FFF: Pattern table 1 (256 tiles)
* **16 bytes per tile: 8 bytes bitplane 0 + 8 bytes bitplane 1

**Tile Addressing:
* Tiles arranged in 16-tile rows
* Tile index: `base + (row * 16) + column`
* For 2×2 sprites: `base, base+1, base+16, base+17`

**Example: Character 'A' at base tile 0:
* Top-left: Tile 0 ($00)
* Top-right: Tile 1 ($01)
* Bottom-left: Tile 16 ($10)
* Bottom-right: Tile 17 ($11)

#### Character Set Organization

**Recommended Layout:
* **A–Z: Tiles 0–51 (26 characters × 2 tiles = 52 tiles, but using 2×2 = 104 tiles)
* **0–9: Tiles 52–71 (10 characters × 2 tiles = 20 tiles, but using 2×2 = 40 tiles)
* **Special: Space, punctuation
* **Base spacing: `char_index * 2` for 2×2 sprite characters

**Priority System:
* Write bottom tiles first (base+16, base+17)
* Write top tiles second (base, base+1)
* Prevents overwrites when tiles overlap

### 5. Sprite Design

#### Single-Tile Sprites (8×8)

* **Use Case: Small objects, particles, UI elements
* **Limitation: Very limited detail
* **Technique: Focus on silhouette and key features

#### Multi-Tile Sprites (2×2, 3×3, etc.)

* **2×2 (16×16): Common for characters, medium objects
* **3×3 (24×24): Larger characters, bosses
* **Technique: Design as complete image, then split into tiles
* **Constraint: NES 64-sprite limit (2×2 = 4 sprites per character)

#### Sprite Priority

* **OAM Order: Lower indices render on top
* **Background Priority: Sprites can appear behind background tiles
* **Technique: Order sprites by depth (background → foreground)

### 6. Background Art

#### Tile Reuse

* **Metatiles: Groups of 2×2 tiles that form reusable patterns
* **Compression: Store metatiles instead of individual tiles
* **Technique: Design level with reusable tile combinations

#### Attribute Tables

* **Purpose: Define palette for 2×2 tile regions (16×16 pixels)
* **Layout: 8×8 attribute bytes for 32×30 tile name table
* **Encoding: 2 bits per 2×2 region (4 palette choices)
* **Constraint: Palette changes only at 16×16 pixel boundaries

#### Scrolling Considerations

* **Tile Alignment: Tiles must align to 8×8 grid
* **Scroll Granularity: Fine scroll (0–7 pixels) + coarse scroll (tiles)
* **Technique: Design tiles to tile seamlessly horizontally and vertically

### 7. Animation Techniques

#### Frame-Based Animation

* **Sprite Animation: Cycle through tile indices
* **Frame Tables: Lookup tables mapping frame → tile indices
* **Timing: Update frames at consistent intervals (e.g., every N frames)

#### Tile Animation

* **Technique: Swap tiles in pattern table during VBlank
* **Use Case: Animated backgrounds, water, fire
* **Constraint: Must update during VBlank to avoid corruption

#### Palette Cycling

* **Technique: Rotate palette colors to create animation effect
* **Use Case: Pulsing effects, rainbow effects, status indicators
* **Implementation: Update palette during VBlank

### 8. Color Theory for Retro Graphics

#### NES Color Palette

* **64 Total Colors: But only 13 unique colors per tile
* **Color Emphasis: Can shift entire palette (red, green, blue emphasis)
* **Grayscale Mode: Can disable color for monochrome effect

#### Effective Color Use

* **Contrast: Use high contrast for readability
* **Hue Separation: Use distinct hues for different objects
* **Saturation: NES colors are naturally saturated; use this to advantage
* **Background Color: Shared across all tiles; choose carefully

#### Palette Optimization

* **Shared Colors: Use background color for common elements
* **Palette Grouping: Group related tiles in same palette
* **Technique: Analyze tile usage to optimize palette assignments

### 9. Tools and Workflows

#### Tile Editors

* **YY-CHR: Popular NES tile editor (Japanese tool)
* **NES Screen Tool: Tile and palette editor
* **Tiled: Modern tile map editor (supports NES)
* **Aseprite: Pixel art editor with tile support

#### Conversion Tools

* **Image → Tiles: Convert PNG/BMP to NES tile format
* **Tile Extraction: Extract tiles from existing ROMs
* **Palette Extraction: Extract palettes from images or ROMs

#### Workflow

1. **Design: Create pixel art in editor
2. **Tile Extraction: Split into 8×8 tiles
3. **Palette Assignment: Assign tiles to palettes
4. **Optimization: Remove duplicate tiles, optimize palette usage
5. **Export: Convert to CHR ROM format
6. **Integration: Include in assembly project

### 10. Common Patterns

#### Character Design

* **2×2 Sprites: Standard for readable characters
* **Technique: Design complete 16×16 character, split into 4 tiles
* **Quadrant Extraction: Top-left, top-right, bottom-left, bottom-right
* **Scaling: Scale 4×4 quadrants to 8×8 tiles for readability

#### UI Elements

* **Single Tiles: Icons, numbers, small UI elements
* **Tile Fonts: 8×8 or 16×16 character sets
* **Technique: Design font with consistent spacing and style

#### Background Tiles

* **Seamless Tiling: Design tiles to repeat without seams
* **Variation: Create multiple variations of similar tiles
* **Metatiles: Design 2×2 tile combinations for level building

### 11. Optimization Techniques

#### Tile Reuse

* **Duplicate Detection: Identify and remove duplicate tiles
* **Tile Sharing: Use same tile for multiple purposes
* **Technique: Analyze tile usage, maximize reuse

#### Palette Optimization

* **Palette Merging: Combine palettes when possible
* **Color Reduction: Reduce unique colors per tile
* **Technique: Use dithering to simulate missing colors

#### Memory Management

* **CHR ROM Limits: 8 KB (512 tiles) or 16 KB (1024 tiles) for Mapper 0
* **Tile Budget: Plan tile usage across game
* **Technique: Prioritize frequently-used tiles

### 12. Hardware-Specific Considerations

#### NES/

* **NTSC vs PAL: Different color palettes, timing
* **PPU Variants: Different PPU chips have slight color differences
* **Sprite Limit: 64 sprites, 8 per scanline (flicker management required)


* **Multiple Modes: Mode 0–7 with different capabilities
* **Layer Priority: Complex priority system
* **Effects: Mode 7 rotation/scaling, HDMA effects

### 13. Best Practices

#### Design Principles

1. **Start Simple: Begin with basic shapes, add detail gradually
2. **Test Early: View graphics on actual hardware or accurate emulator
3. **Iterate: Refine based on hardware appearance
4. **Consistency: Maintain consistent style and palette usage
5. **Readability: Prioritize clarity over detail

#### Technical Practices

1. **VBlank Updates: Only update graphics during VBlank
2. **Tile Organization: Plan tile layout before implementation
3. **Palette Planning: Design with palette constraints in mind
4. **Sprite Budget: Track sprite usage to avoid flicker
5. **Memory Budget: Track CHR ROM usage

#### Quality Checklist

- [ ] All tiles fit within 8×8 pixel boundaries
- [ ] Colors respect palette constraints (4 colors per tile)
- [ ] Tiles tile seamlessly for backgrounds
- [ ] Sprites are readable at target size
- [ ] Tile usage is optimized (minimal duplicates)
- [ ] Palette usage is optimized
- [ ] Graphics tested on hardware/accurate emulator
- [ ] Sprite count within limits (64 total, 8 per scanline)

## Cross-References

- [1.4 PPU Fundamentals](01-fundamentals/1.4-ppu-fundamentals.md) - Tiles, pattern tables, sprites
- [2.3 PPU Rendering Rules](02-advanced-fundamentals/2.3-ppu-rendering-rules.md) - VRAM access, VBlank
- [3.3 Rendering Architecture](03-core-concepts/3.3-rendering-architecture.md) - OAM buffering, rendering pipeline
- [4.2 PPU Cheatsheets](04-cheatsheets/4.2-ppu-cheatsheets.md) - Register reference, sprite attributes
- [5.1 Sprite Engine Patterns](05-applied-patterns/5.1-sprite-engine-patterns.md) - Sprite management
- [5.4 Animation Systems](05-applied-patterns/5.4-animation-systems.md) - Animation techniques

## External Resources

- [Mega Cat Studios: Creating NES Graphics](https://megacatstudios.com/blogs/retro-development/creating-nes-graphics)
- [Mega Cat Studios: Super Nintendo Graphic Guide](https://megacatstudios.com/blogs/retro-development/super-nintendo-graphic-guide)
- [Mega Cat Studios: NES Background Art II](https://megacatstudios.com/blogs/retro-development/nes-background-art-ii-teaching-as-a-pixel-sensei)
- [Mega Cat Studios: Blending Tiles for Animated NES Bosses](https://megacatstudios.com/blogs/retro-development/blending-tiles-for-animated-nes-bosses)
- [NES Rocks: NES Graphics](https://nesrocks.com/blog/nes-graphics/)
- [YY-CHR Wiki](https://w.atwiki.jp/yychr/) - Japanese tile editor documentation

---

**Note: This guide follows the hardware-first, assembly-aware philosophy of this framework. All techniques are verified against actual hardware behavior and constraints.
