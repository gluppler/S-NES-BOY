# 4.6 Optimization Cheatsheets

## System Applicability

**This cheatsheet applies to:
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same hardware constraints)


Quick reference for NES optimization techniques. See [2.6 Advanced Optimization Techniques](../02-advanced-fundamentals/2.6-optimization-techniques.md) for detailed explanations.

## Cycle Cost Reference

### Addressing Modes (LDA example)

| Mode | Cycles | Example | Use When |
|------|--------|---------|----------|
| Immediate | 2 | `LDA #$42` | Constants |
| Zero Page | 3 | `LDA $00` | Hot variables |
| Zero Page,X | 4 | `LDA $00,X` | Indexed zero page |
| Absolute | 4 | `LDA $0300` | Regular variables |
| Absolute,X | 4-5 | `LDA $0300,X` | Indexed (+1 if page cross) |
| (Indirect,X) | 6 | `LDA ($00,X)` | Jump tables |
| (Indirect),Y | 5-6 | `LDA ($00),Y` | Pointers (+1 if page cross) |

**Rule: Use fastest mode that fits your data layout.

## Zero Page Optimization

### When to Use Zero Page

- Variables accessed >10 times per frame
- Loop counters in hot loops
- Pointers for indirect addressing
- Temporary variables in tight loops

### Zero Page Savings

- **1 cycle saved** per access (3 vs 4 cycles)
- **10 accesses/frame** = 600 cycles/second saved
- **Critical for hot paths

### Example

```asm
; ❌ 4 cycles per access
player_x = $0300
    LDA player_x

; ✅ 3 cycles per access (25% faster)
zp_player_x = $09
    LDA zp_player_x
```

## Branch Optimization

### Branch Costs

| Type | Cycles | Notes |
|------|--------|-------|
| Not taken | 2 | Preferred path |
| Taken | 3 | +1 cycle penalty |
| Taken + page cross | 4 | Avoid in hot loops |

### Optimization Rules

1. **Structure for not-taken branches: Make common case the fall-through
2. **Early exits: Exit loops early when condition met
3. **Minimize nesting: Flatten conditional structures
4. **Avoid page crossings: Keep branch targets within ±127 bytes

### Example

```asm
; ❌ BAD: Taken branch in hot path
    CMP #0
    BEQ zero_case    ; 3 cycles if taken
    ; Non-zero case

; ✅ GOOD: Not-taken branch preferred
    CMP #0
    BNE non_zero     ; 2 cycles (not taken)
    ; Zero case (less common)
non_zero:
```

## Loop Optimization

### Unrolling Guidelines

| Iterations | Unroll? | Reason |
|------------|---------|--------|
| 1-3 | Always | Eliminates loop overhead |
| 4-7 | Consider | If called frequently |
| 8+ | Rarely | Code size vs speed trade-off |

### Loop Termination

```asm
; ✅ FAST: CPX (2 cycles)
    CPX #count
    BNE loop

; ⚠️ SLOWER: CMP (2 cycles, but less flexible)
    CMP #value
    BNE loop
```

## Memory Access Patterns

### Access Speed (Fastest to Slowest)

1. **CPU Registers** (A, X, Y): 0 cycles (already loaded)
2. **Zero Page: 3 cycles
3. **Absolute: 4 cycles
4. **Indexed Absolute: 4-5 cycles
5. **Indirect: 5-6 cycles

### Sequential vs Random Access

```asm
; ✅ FAST: Sequential access
    LDY #0
loop:
    LDA data,Y      ; Sequential
    INY
    CPY #count
    BNE loop

; ❌ SLOW: Random access
    LDX index
    LDA data,X      ; Random (cache miss)
```

## Lookup Tables vs Computation

### When to Use Lookup Tables

| Operation | Compute | Lookup | Winner |
|-----------|---------|--------|--------|
| Divide by 2 | 2 cycles (LSR) | 4 cycles | Compute |
| Divide by 8 | 6 cycles (3×LSR) | 4 cycles | Lookup |
| Multiply by 3 | 6 cycles | 4 cycles | Lookup |
| Multiply by 2 | 2 cycles (ASL) | 4 cycles | Compute |
| Complex math | 10+ cycles | 4 cycles | Lookup |

**Rule: Use lookup table if computation >4 cycles and used frequently.

## Struct-of-Arrays Pattern

### Memory Layout Comparison

```asm
; ❌ BAD: Array-of-structs (random access)
entity_data = $0300
    ; Entity 0: X, Y, VX, VY (offset 0)
    ; Entity 1: X, Y, VX, VY (offset 4)
    ; Entity 2: X, Y, VX, VY (offset 8)
    ; To update all X: access at 0, 4, 8, 12... (random)

; ✅ GOOD: Struct-of-arrays (sequential access)
entity_x = $0300   ; All X positions (sequential)
entity_y = $030A   ; All Y positions (sequential)
entity_vx = $0314  ; All X velocities (sequential)
entity_vy = $031E  ; All Y velocities (sequential)
    ; To update all X: access at 0, 1, 2, 3... (sequential)
```

## NMI Handler Budget

### VBlank Time Budget (NTSC)

| Task | Cycles | Notes |
|------|--------|-------|
| OAM DMA | 513 | Required, hardware-accelerated |
| Scroll update | 6 | Must do every frame |
| PPU control | 3 | Must do every frame |
| VRAM writes | ~2 per byte | Limited by VBlank duration |
| **Total Budget** | **~2,270** | Must complete in VBlank |

### NMI Optimization Rules

1. **Use OAM DMA: Never copy OAM byte-by-byte
2. **Batch VRAM writes: Minimize address changes
3. **Keep under 2000 cycles: Leave margin for safety
4. **Move non-critical work: Do heavy updates in main loop

## Register Reuse

### Keep Values in Registers

```asm
; ❌ BAD: Store and reload
    LDA value
    STA temp
    ; ... other code ...
    LDA temp

; ✅ GOOD: Keep in register
    LDA value
    TAX              ; Keep in X
    ; ... other code ...
    TXA              ; Restore from X
```

## Instruction Selection

### Fast Alternatives

| Operation | Slow | Fast | Savings |
|-----------|------|------|---------|
| Clear A | `LDA #0` (2) | `TXA` if X=0 (2) | Same, but reuses X |
| Copy A to X | `STA temp, LDX temp` (6) | `TAX` (2) | 4 cycles |
| Increment | `CLC, ADC #1` (4) | `INC` (5-6) | Depends on addressing |
| Compare to 0 | `CMP #0` (2) | `ORA #0` (2) or use flags | Same, but sets flags |

## Multiplication/Division Quick Reference

### Powers of 2 (Use Bit Shifts)

| Operation | Instruction | Cycles |
|-----------|-------------|--------|
| ×2 | `ASL A` | 2 |
| ×4 | `ASL A, ASL A` | 4 |
| ×8 | `ASL A` ×3 | 6 |
| ÷2 | `LSR A` | 2 |
| ÷4 | `LSR A, LSR A` | 4 |
| ÷8 | `LSR A` ×3 | 6 |

### Non-Powers of 2

| Operation | Method | Cycles |
|-----------|--------|--------|
| ×3 | `ASL A, ADC original` | 6 |
| ×5 | `ASL A, ASL A, ADC original` | 8 |
| ×7 | Lookup table | 4 |
| ×10 | `ASL A, STA temp, ASL A, ASL A, ADC temp` | 10 |

## Code Size vs Speed Trade-offs

### Inline vs Subroutine

| Code Size | Call Frequency | Use |
|-----------|----------------|-----|
| <10 cycles | >5 times/frame | Inline |
| 10-20 cycles | >3 times/frame | Consider inline |
| >20 cycles | Any | Subroutine |

## Optimization Checklist

### Quick Reference

- [ ] Hot variables in zero page?
- [ ] Fastest addressing mode used?
- [ ] Branches optimized (not-taken preferred)?
- [ ] Small loops unrolled?
- [ ] Lookup tables for complex math?
- [ ] Struct-of-arrays for entity data?
- [ ] Registers reused (not stored/reloaded)?
- [ ] NMI handler <2000 cycles?
- [ ] VRAM updates batched?
- [ ] OAM DMA used (not byte copy)?

## Performance Targets

### Frame Time Budget (NTSC)

| Period | Cycles | Usage |
|--------|--------|-------|
| Total frame | ~89,400 | Game logic + rendering |
| VBlank | ~2,270 | PPU updates only |
| Visible | ~81,300 | Game logic |
| NMI handler | <2,000 | Must complete in VBlank |

### Optimization Goals

- **Zero page: Save 1 cycle per access
- **Branch optimization: Save 1 cycle per taken branch avoided
- **Loop unrolling: Save 2-3 cycles per iteration
- **Lookup tables: Save 6+ cycles vs computation
- **NMI handler: Complete in <2000 cycles

## Common Mistakes to Avoid

| Mistake | Impact | Fix |
|---------|--------|-----|
| Absolute addressing for hot vars | Wastes 1 cycle/access | Use zero page |
| Taken branches in hot loops | Wastes 1 cycle/branch | Restructure code |
| Byte-by-byte OAM copy | Wastes 500+ cycles | Use OAM DMA |
| Random memory access | Cache misses | Use sequential access |
| Computing instead of lookup | Wastes 6+ cycles | Use lookup table |

## Related Topics

- [2.6 Advanced Optimization Techniques](../02-advanced-fundamentals/2.6-optimization-techniques.md) - Detailed optimization guide
- [2.1 CPU Timing & Cycles](../02-advanced-fundamentals/2.1-cpu-timing-cycles.md) - Cycle counting reference
- [3.2 Data-Oriented Design](../03-core-concepts/3.2-data-oriented-design.md) - Memory layout optimization
- [4.4 Timing Cheatsheets](4.4-timing-cheatsheets.md) - Frame timing reference

## Cross-References

- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.6 (Optimization Techniques)
- Related Core Concepts: 3.2 (Data-Oriented Design), 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.1 (CPU), 4.4 (Timing)
