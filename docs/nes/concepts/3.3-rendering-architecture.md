# 3.3 Rendering Architecture

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same PPU and rendering architecture)


## Concept Definition

NES rendering architecture separates **rendering preparation** (main loop) from **rendering execution** (NMI handler). The main loop builds rendering queues (OAM buffers, background update lists), while the NMI handler applies these updates to the PPU during VBlank. This decoupling prevents rendering from blocking game logic and ensures all PPU updates occur during safe VBlank windows.

## Subsystems Involved

* **CPU: Builds rendering queues, executes NMI handler
* **PPU: Receives rendering updates during VBlank
* **RAM: Stores OAM buffers, background update queues, rendering state
* **VRAM: PPU memory (name tables, pattern tables, palettes)
* **OAM: Sprite attribute memory (256 bytes, 64 sprites)

## Step-by-Step Data Flow

1. **Main Loop (Rendering Preparation):
   - Clear OAM buffer (set all sprites off-screen)
   - Build sprite list (iterate entities, write to OAM buffer)
   - Build background update queue (tiles to change this frame)
   - Prepare palette changes (if needed)
   - Set rendering flags (scroll changes, name table switches)

2. **NMI Handler (Rendering Execution):
   - Read $2002 (clear VBlank flag)
   - OAM DMA: Copy OAM buffer to PPU ($4014)
   - Process background update queue: Write tiles to name tables
   - Update palettes: Write to $3F00–$3F1F
   - Update scroll: Write $2005 twice (X, Y)
   - Update PPU control: Write $2000 (name table select, etc.)

3. **PPU Rendering (Automatic):
   - PPU reads name tables, pattern tables, OAM
   - PPU generates pixels and outputs to TV
   - Process repeats next frame

## Timing Implications

* **VBlank window: ~2,270 cycles (NTSC) for all PPU updates
* **OAM DMA: 513 cycles (blocks CPU during transfer)
* **VRAM writes: ~2 cycles per byte (via $2007)
* **Background updates: Limited by VBlank duration (~1,135 bytes max theoretical)
* **Frame timing: All rendering updates must complete during VBlank
* **Double buffering: Can prepare next frame's data while current frame renders

## Why This Pattern Exists on NES Specifically

* **VBlank constraint: VRAM access only safe during VBlank
* **Limited VBlank time: ~2,270 cycles requires efficient updates
* **OAM DMA requirement: Hardware requires OAM updates via DMA
* **Decoupling: Separating preparation from execution prevents blocking
* **Deterministic rendering: Frame-based updates enable consistent visuals

## Failure Modes and Visible Symptoms

* **OAM buffer overflow: >64 sprites cause sprite flicker or missing sprites
* **VRAM updates outside VBlank: Visual corruption, tile glitches
* **Long NMI handler: Exceeds VBlank duration, causes frame drops
* **Not clearing OAM buffer: Old sprites remain visible
* **Scroll desync: Scroll registers not updated every frame cause jitter
* **Background update queue overflow: Too many tile changes per frame cause corruption

## Minimal Example

```asm
; OAM buffer (256 bytes, 64 sprites × 4 bytes)
oam_buffer = $0200

; Background update queue
bg_update_queue = $0300    ; Queue of tile updates
bg_update_count = $00      ; Zero page: number of updates

; Rendering preparation (main loop)
prepare_rendering:
    ; Clear OAM buffer (move all sprites off-screen)
    LDX #0
    LDA #$FF        ; Y = 255 (off-screen)
clear_oam:
    STA oam_buffer,X
    INX
    CPX #256
    BNE clear_oam
    
    ; Build sprite list
    LDX #0          ; OAM index
    LDY #0          ; Entity index
build_sprites:
    ; Check if entity is visible
    LDA entity_active,Y
    BEQ skip_sprite
    
    ; Write sprite Y
    LDA entity_y,Y
    STA oam_buffer,X
    INX
    
    ; Write sprite tile
    LDA entity_tile,Y
    STA oam_buffer,X
    INX
    
    ; Write sprite attributes
    LDA entity_attr,Y
    STA oam_buffer,X
    INX
    
    ; Write sprite X
    LDA entity_x,Y
    STA oam_buffer,X
    INX
    
    ; Check if we've used all 64 sprites
    CPX #256
    BEQ sprites_done
    
skip_sprite:
    INY
    CPY #10         ; 10 entities
    BNE build_sprites
    
sprites_done:
    ; Build background update queue
    LDA #0
    STA bg_update_count
    
    ; Add tile updates to queue (example: update 5 tiles)
    LDX bg_update_count
    LDA #$20        ; Name table 0, high byte
    STA bg_update_queue,X
    INX
    LDA #$42        ; Low byte (tile address)
    STA bg_update_queue,X
    INX
    LDA #$01        ; Tile index
    STA bg_update_queue,X
    INX
    STX bg_update_count
    
    RTS

; Rendering execution (NMI handler)
execute_rendering:
    LDA $2002       ; Clear VBlank flag
    
    ; OAM DMA
    LDA #0
    STA $2003       ; OAM address = 0
    LDA #>oam_buffer
    STA $4014       ; Start DMA (513 cycles)
    
    ; Process background update queue
    LDX #0
bg_update_loop:
    CPX bg_update_count
    BEQ bg_update_done
    
    ; Set PPU address
    LDA $2002       ; Reset latch
    LDA bg_update_queue,X
    STA $2006       ; High byte
    INX
    LDA bg_update_queue,X
    STA $2006       ; Low byte
    INX
    
    ; Write tile
    LDA bg_update_queue,X
    STA $2007
    INX
    
    JMP bg_update_loop
    
bg_update_done:
    ; Update scroll
    LDA scroll_x
    STA $2005
    LDA scroll_y
    STA $2005
    
    ; Update PPU control
    LDA ppu_ctrl
    STA $2000
    
    RTS
```

## Cross-References

- Related Fundamentals: 1.4 (PPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.2 (NMI & VBlank Discipline), 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.1 (Game Loop), 3.4 (Input → State → Output)
- Related Cheatsheets: 4.2 (PPU Cheatsheets), 4.4 (Timing Cheatsheets)
