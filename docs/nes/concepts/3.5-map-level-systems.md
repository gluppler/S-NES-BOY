# 3.5 Map & Level Systems

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same PPU and tile system)


## Concept Definition

NES map and level systems store tile-based level data efficiently using **metatiles** (2×2 tile groups), **compression** (RLE, lookup tables), and **attribute encoding** (2×2 tile palette groups). Level data is stored in ROM and decompressed/decoded into PPU name tables and attribute tables during gameplay. This pattern minimizes ROM usage while enabling large, varied levels.

## Subsystems Involved

* **ROM: Stores compressed level data, metatile definitions, lookup tables
* **CPU: Decompresses level data, decodes metatiles, writes to VRAM
* **PPU: Displays level via name tables and attribute tables
* **RAM: Stores decompressed tile buffers, metatile cache, level state
* **VRAM: PPU memory (name tables $2000–$2EFF, attribute tables)

## Step-by-Step Data Flow

1. **Level Data Storage** (ROM):
   - Metatile definitions: 2×2 tile groups with attributes
   - Compressed level map: RLE or lookup table indices
   - Attribute encoding: 2×2 metatile groups share palette

2. **Level Loading** (Main Loop, during transitions):
   - Decompress level data from ROM
   - Decode metatiles: Expand 2×2 metatiles into 4 tiles
   - Decode attributes: Expand attribute bytes into 2×2 tile groups
   - Write to VRAM: Update name tables and attribute tables during VBlank

3. **Level Rendering** (PPU, automatic):
   - PPU reads name tables to determine background tiles
   - PPU reads attribute tables to determine palettes
   - PPU renders visible portion of level

4. **Scrolling** (Main Loop + NMI):
   - Update scroll registers ($2005) based on camera position
   - Load new tiles when scrolling reveals new areas (metatile-based)

## Timing Implications

* **Level loading: Must complete during screen transitions (multiple frames)
* **VRAM updates: Limited to VBlank windows (~1,135 bytes per frame theoretical)
* **Metatile decoding: CPU-intensive, should be done incrementally
* **Attribute decoding: Fast (lookup table), can be done on-dem
* **Scrolling updates: Must update $2005 every frame in NMI

## Why This Pattern Exists on NES Specifically

* **ROM size limits: Cartridges have limited PRG/CHR ROM
* **VRAM size limits: Only 4 name tables (4 KB total), must be managed
* **CPU constraints: Decompression must be efficient (limited CPU time)
* **Metatile efficiency: 2×2 groups reduce data by 4× (1 byte → 4 tiles)
* **Attribute encoding: 2×2 groups reduce attributes by 4× (1 byte → 4 tiles)

## Failure Modes and Visible Symptoms

* **ROM overflow: Uncompressed level data exceeds cartridge capacity
* **VRAM corruption: Writing too many tiles per frame causes visual glitches
* **Slow level loading: Decompression takes too long, causes frame drops
* **Attribute errors: Wrong palette mapping causes incorrect colors
* **Metatile misalignment: Incorrect metatile decoding causes tile corruption
* **Scrolling jitter: Not updating scroll every frame causes tearing

## Minimal Example

```asm
; Metatile definitions (ROM)
; Each metatile is 4 tiles (2×2)
metatile_table:
    ; Metatile 0: Empty (4 tiles of tile $00)
    .byte $00, $00, $00, $00
    ; Metatile 1: Ground (4 tiles)
    .byte $01, $02, $11, $12
    ; Metatile 2: Wall (4 tiles)
    .byte $03, $03, $03, $03
    ; ... more metatiles

; Compressed level data (RLE: run-length encoded)
; Format: [tile_index, count] pairs, $FF = end
level1_data:
    .byte 0, 32      ; 32 empty tiles (metatile 0)
    .byte 1, 8       ; 8 ground tiles (metatile 1)
    .byte 0, 16      ; 16 empty tiles
    .byte 2, 4       ; 4 wall tiles (metatile 2)
    .byte $FF        ; End of data

; Attribute encoding
; Each byte controls 2×2 metatile groups (4×4 tiles)
; Bits: DDCCBBAA (AA=top-left, BB=top-right, CC=bottom-left, DD=bottom-right)
level1_attributes:
    .byte %00000000  ; All groups use palette 0
    .byte %01010101  ; All groups use palette 1
    ; ... more attributes

; Decompress and load level
load_level:
    ; Clear name table buffer
    LDX #0
    LDA #0
clear_buffer:
    STA name_table_buffer,X
    INX
    CPX #960        ; 32×30 = 960 bytes
    BNE clear_buffer
    
    ; Decompress level data
    LDX #0          ; Buffer index
    LDY #0          ; Data index
decompress_loop:
    LDA level1_data,Y
    CMP #$FF
    BEQ decompress_done
    
    STA temp_metatile ; Metatile index
    INY
    LDA level1_data,Y
    STA temp_count    ; Count
    INY
    
    ; Expand metatile into tiles
    LDA temp_metatile
    ASL A
    ASL A            ; Multiply by 4 (4 tiles per metatile)
    TAY
    
    ; Write metatile tiles to buffer
    LDA metatile_table,Y   ; Top-left
    STA name_table_buffer,X
    INX
    LDA metatile_table+1,Y ; Top-right
    STA name_table_buffer,X
    INX
    LDA metatile_table+2,Y ; Bottom-left
    STA name_table_buffer,X
    INX
    LDA metatile_table+3,Y ; Bottom-right
    STA name_table_buffer,X
    INX
    
    ; Check if we've written enough
    DEC temp_count
    BNE decompress_loop
    
    JMP decompress_loop
    
decompress_done:
    ; Write name table to VRAM (during VBlank)
    JSR write_name_table
    
    ; Write attributes to VRAM
    JSR write_attributes
    
    RTS

; Write name table to VRAM
write_name_table:
    LDA $2002       ; Reset latch
    LDA #$20        ; Name table 0
    STA $2006
    LDA #$00
    STA $2006
    
    LDX #0
write_loop:
    LDA name_table_buffer,X
    STA $2007       ; Write to PPU
    INX
    CPX #960
    BNE write_loop
    
    RTS

; Write attributes to VRAM
write_attributes:
    LDA $2002       ; Reset latch
    LDA #$23        ; Attribute table 0
    STA $2006
    LDA #$C0
    STA $2006
    
    LDX #0
attr_loop:
    LDA level1_attributes,X
    STA $2007
    INX
    CPX #64         ; 64 attribute bytes
    BNE attr_loop
    
    RTS

; Buffers
name_table_buffer = $0300  ; 960 bytes
temp_metatile = $10        ; Zero page
temp_count = $11           ; Zero page
```

## Cross-References

- Related Fundamentals: 1.4 (PPU Fundamentals), 1.5 (ROM Fundamentals)
- Related Advanced Fundamentals: 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.2 (Data-Oriented Design), 3.3 (Rendering Architecture)
- Related Applied Patterns: 5.2 (Scrolling Patterns)
- Hardware Schematics: [`schematics/nes/`](../../../../schematics/nes/README.md) - Cartridge circuit diagrams for various mappers
