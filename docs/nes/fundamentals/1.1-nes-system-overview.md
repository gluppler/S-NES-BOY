# 1.1 NES System Overview

## System Applicability

**This document applies to:**
- ✅ **NES (Nintendo Entertainment System): Primary focus

## Physical Hardware Overview

The Nintendo Entertainment System (NES) is a composite system consisting of:

* **Ricoh 2A03 CPU** (6502 variant, ~1.79 MHz NTSC, ~1.66 MHz PAL)
* **Ricoh 2C02 PPU** (Picture Processing Unit, ~5.37 MHz NTSC, ~5.32 MHz PAL)
* **APU** (Audio Processing Unit, integrated into 2A03)
* **Cartridge slot** (connects PRG ROM, CHR ROM, and optional mapper hardware)
* **2 KB RAM** (CPU-accessible work RAM at $0000–$1FFF, mirrored)
* **2 KB VRAM** (PPU-accessible video RAM, typically at $2000–$3EFF)

The CPU and PPU operate on separate buses. The CPU cannot directly access PPU memory; all communication occurs through memory-mapped I/O registers ($2000–$2007).

## NES Terminology Definitions

* **NTSC: North American/Japanese video standard (60.098 Hz frame rate, 262 scanlines)
* **PAL: European video standard (50.007 Hz frame rate, 312 scanlines)
* **VBlank: Vertical blanking period (scanlines 241–260 NTSC, 241–310 PAL) when PPU is not rendering
* **Scanline: One horizontal line of video output (~63.5 CPU cycles NTSC, ~83 CPU cycles PAL)
* **Frame: One complete screen refresh (262 scanlines NTSC, 312 scanlines PAL)
* **NMI: Non-Maskable Interrupt, triggered at start of VBlank
* **Mapper: Cartridge hardware that remaps PRG/CHR ROM banks to CPU/PPU address space

## Core Rules and Invariants

* Everything revolves around **VBlank**. Safe PPU VRAM access occurs only during VBlank or forced blanking.
* The CPU runs at ~1.79 MHz (NTSC). One frame = ~29,780 CPU cycles.
* The PPU renders 240 visible scanlines, then enters VBlank for ~20 scanlines (NTSC).
* NMI fires once per frame at the start of VBlank (scanline 241).
* CPU memory map is fixed: $0000–$1FFF RAM (mirrored), $2000–$3FFF PPU registers (mirrored), $4000–$401F APU/I/O, $4020–$5FFF cartridge expansion, $6000–$7FFF cartridge RAM, $8000–$FFFF cartridge PRG ROM.
* PPU memory map: $0000–$1FFF pattern tables (CHR ROM/RAM), $2000–$2EFF name tables (background), $3F00–$3F1F palettes, $3F20–$3FFF mirrors.

## Minimal Correct Usage Example

```asm
; Minimal NES initialization
reset:
    SEI          ; Disable interrupts
    CLD          ; Clear decimal mode
    LDX #$FF
    TXS          ; Initialize stack pointer
    INX          ; X = 0
    STX $2000    ; Disable PPU rendering
    STX $2001    ; Disable rendering
    STX $4010    ; Disable DMC IRQ
    
    ; Wait for PPU to stabilize
    BIT $2002    ; Clear VBlank flag
vblank_wait1:
    BIT $2002
    BPL vblank_wait1
    
    ; Clear RAM
    LDA #0
clear_ram:
    STA $0000,X
    STA $0100,X
    STA $0200,X
    STA $0300,X
    STA $0400,X
    STA $0500,X
    STA $0600,X
    STA $0700,X
    INX
    BNE clear_ram
    
    ; Wait for second VBlank
vblank_wait2:
    BIT $2002
    BPL vblank_wait2
    
    ; Initialize PPU
    LDA #%10000000  ; Enable NMI
    STA $2000
    LDA #%00011110  ; Enable rendering
    STA $2001
    
    ; Main loop
main_loop:
    JMP main_loop

nmi:
    RTI
```

## Gold Standard Example

```asm
; Complete NES initialization following all hardware requirements
reset:
    ; Disable interrupts and initialize CPU
    SEI          ; Disable interrupts (required first)
    CLD          ; Clear decimal mode (NES doesn't use BCD)
    LDX #$FF
    TXS          ; Initialize stack pointer to $01FF
    INX          ; X = 0 (for clearing RAM)
    
    ; Disable PPU rendering
    STX $2000    ; Disable NMI (PPUCTRL = 0)
    STX $2001    ; Disable rendering (PPUMASK = 0)
    STX $4010    ; Disable DMC IRQ
    
    ; Wait for PPU to stabilize (first VBlank)
    BIT $2002    ; Clear VBlank flag
vblank_wait1:
    BIT $2002
    BPL vblank_wait1    ; Wait for VBlank flag (bit 7)
    
    ; Clear all RAM ($0000-$07FF)
    LDA #0
clear_ram:
    STA $0000,X  ; Zero page
    STA $0100,X  ; Stack
    STA $0200,X  ; OAM buffer
    STA $0300,X  ; RAM
    STA $0400,X  ; RAM
    STA $0500,X  ; RAM
    STA $0600,X  ; RAM
    STA $0700,X  ; RAM
    INX
    BNE clear_ram
    
    ; Wait for second VBlank (ensures PPU is fully stabilized)
vblank_wait2:
    BIT $2002
    BPL vblank_wait2
    
    ; Initialize PPU registers
    LDA #%10000000  ; Enable NMI, pattern table 0, name table 0
    STA $2000       ; PPUCTRL
    LDA #%00011110  ; Enable background and sprites, show left 8px
    STA $2001       ; PPUMASK
    
    ; Initialize game state
    LDA #0
    STA frame_counter
    STA frame_ready
    STA scroll_x
    STA scroll_y
    
    ; Load palette (must be done during VBlank)
    JSR load_palette
    
    ; Clear OAM buffer (move all sprites off-screen)
    LDX #0
    LDA #$FF
clear_oam:
    STA $0200,X
    INX
    BNE clear_oam
    
    ; Wait for VBlank before enabling rendering
vblank_wait3:
    BIT $2002
    BPL vblank_wait3
    
    ; Set scroll registers
    LDA $2002    ; Reset scroll latch
    LDA #0
    STA $2005    ; X scroll
    STA $2005    ; Y scroll
    
    ; Enter main loop
    JMP main_loop

nmi:
    ; Save registers
    PHA
    TXA
    PHA
    TYA
    PHA
    
    ; Clear VBlank flag
    LDA $2002
    
    ; Update OAM via DMA
    LDA #0
    STA $2003    ; OAM address
    LDA #$02     ; High byte of OAM buffer
    STA $4014    ; Start OAM DMA
    
    ; Update scroll
    LDA scroll_x
    STA $2005    ; X scroll
    LDA scroll_y
    STA $2005    ; Y scroll
    
    ; Update PPU control
    LDA ppu_ctrl
    STA $2000
    
    ; Set frame ready flag
    LDA #1
    STA frame_ready
    
    ; Restore registers
    PLA
    TAY
    PLA
    TAX
    PLA
    RTI

main_loop:
    ; Wait for frame
    LDA frame_ready
    BEQ main_loop
    
    ; Clear frame flag
    LDA #0
    STA frame_ready
    
    ; Read controllers
    JSR read_controllers
    
    ; Update game logic
    JSR update_game
    
    ; Update rendering
    JSR update_rendering
    
    JMP main_loop
```

## Validation Rules

### Hardware Requirements

1. **Interrupt Disable: SEI must be first instruction in reset handler
2. **Stack Initialization: Stack pointer must be set to $01FF before first use
3. **PPU Disable: PPU rendering must be disabled before VRAM access
4. **VBlank Waits: Must wait for 2 VBlanks to ensure PPU stabilization
5. **RAM Clearing: All RAM must be cleared to known state
6. **Register Order: PPU registers must be initialized in correct sequence
7. **VBlank Access: VRAM writes must occur during VBlank or forced blanking
8. **OAM DMA: OAM updates must use DMA (not individual writes)
9. **Scroll Latch: Must read $2002 before writing scroll registers
10. **NMI Timing: NMI handler must complete quickly (< ~2000 cycles)

### Failure Modes

* **Missing SEI: Interrupts may fire during initialization, corrupting state
* **Uninitialized Stack: Stack operations corrupt memory at $0100-$01FF
* **PPU Not Disabled: VRAM access during rendering causes corruption
* **Insufficient VBlank Waits: PPU may not be ready, causing initialization failures
* **VRAM Access Outside VBlank: Visual corruption, incorrect tiles/sprites
* **OAM Writes During Rendering: Sprite glitches, incorrect positions
* **Long NMI Handler: Delays main loop, causes frame drops, input lag
* **Missing Scroll Reset: Scroll position incorrect, screen misaligned

## Explicit Non-Goals

This section does not cover:
* Detailed CPU instruction set (see 1.2)
* Memory map specifics (see 1.3)
* PPU rendering details (see 1.4)
* Cartridge mapper details beyond Mapper 0 (see 1.5)
* Timing-critical operations (see 2.1, 2.2)
* Game loop architecture (see 3.1)

## Cross-References

- Related Fundamentals: 1.2 (CPU), 1.3 (Memory), 1.4 (PPU), 1.5 (ROM)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.2 (NMI & VBlank)
- Related Core Concepts: 3.1 (Game Loop)
- Related Cheatsheets: 4.3 (Memory), 4.4 (Timing)
