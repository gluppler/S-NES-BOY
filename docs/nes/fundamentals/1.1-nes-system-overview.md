# 1.1 NES System Overview

## System Applicability

**This document applies to:**
- ✅ **NES (Nintendo Entertainment System)**: Primary focus

## Physical Hardware Overview

The Nintendo Entertainment System (NES) is a composite system consisting of:

* **Ricoh 2A03 CPU** (6502 variant, ~1.79 MHz NTSC, ~1.66 MHz PAL)
* **Ricoh 2C02 PPU** (Picture Processing Unit, ~5.37 MHz NTSC, ~5.32 MHz PAL)
* **APU** (Audio Processing Unit, integrated into 2A03)
* **Cartridge slot** (connects PRG ROM, CHR ROM, and optional mapper hardware)
* **2 KB RAM** (CPU-accessible work RAM at $0000–$1FFF, mirrored)
* **2 KB VRAM** (PPU-accessible video RAM, typically at $2000–$3EFF)

The CPU and PPU operate on separate buses. The CPU cannot directly access PPU memory; all communication occurs through memory-mapped I/O registers ($2000–$2007).

**Hardware Schematics**: For detailed circuit diagrams of the NES console and cartridges, see [`schematics/nes/`](../../../../schematics/nes/README.md).

## Power-Up and Reset States

### CPU (2A03) Power-Up State

| Register/State | Power-Up Value | Notes |
|----------------|----------------|-------|
| A (Accumulator) | Undefined | Random value |
| X (Index) | Undefined | Random value |
| Y (Index) | Undefined | Random value |
| SP (Stack Pointer) | Undefined | Random value (must initialize) |
| PC (Program Counter) | Undefined | Random value (reset vector loads from $FFFC) |
| P (Status Register) | $34 | I=1 (interrupts disabled), D=0, B=1 |
| RAM ($0000–$07FF) | Undefined | Random values (must clear) |
| APU Registers | Undefined | Random values (must initialize) |

**Reset Behavior:**
- Reset vector at $FFFC–$FFFD is loaded into PC
- I flag is set (interrupts disabled)
- All other registers are undefined
- RAM contents are undefined
- **Must initialize**: Stack pointer, RAM, APU, PPU

### PPU (2C02) Power-Up State

| Register/State | Power-Up Value | Notes |
|----------------|----------------|-------|
| $2000 (PPUCTRL) | Undefined | Random value |
| $2001 (PPUMASK) | Undefined | Random value |
| $2002 (PPUSTATUS) | Undefined | VBlank flag may be set |
| $2003 (OAMADDR) | Undefined | Random value |
| $2005 (PPUSCROLL) | Undefined | Random value |
| $2006 (PPUADDR) | Undefined | Random value (address latch) |
| $2007 (PPUDATA) | Undefined | Random value |
| VRAM ($2000–$3EFF) | Undefined | Random values |
| OAM ($0200–$02FF) | Undefined | Random sprite data |
| Palette RAM ($3F00–$3F1F) | Undefined | Random colors |

**Reset Behavior:**
- All PPU registers are undefined
- VRAM contents are undefined
- OAM contains random sprite data
- **Must initialize**: Disable rendering, clear VRAM/OAM, set palettes

### APU Power-Up State

| Register/State | Power-Up Value | Notes |
|----------------|----------------|-------|
| $4000–$4013 (APU Channels) | Undefined | Random values |
| $4015 (APU Status) | $00 | All channels disabled |
| $4017 (Frame Counter) | Undefined | Frame counter not running |
| Channel Output | Silent | All channels disabled |

**Reset Behavior:**
- All APU registers are undefined
- Channels are disabled ($4015 = $00)
- Frame counter is not running
- **Must initialize**: Disable channels, initialize frame counter

### NTSC vs PAL Power-Up Differences

| Aspect | NTSC | PAL | Notes |
|--------|------|-----|-------|
| CPU Clock | 1.789773 MHz | 1.662607 MHz | Master clock ÷ 12 (NTSC) or ÷ 16 (PAL) |
| PPU Clock | 5.369318 MHz | 5.320545 MHz | Master clock ÷ 4 |
| Frame Rate | 60.098 Hz | 50.007 Hz | Slight variation from 60/50 Hz |
| Scanlines | 262 | 312 | PAL has 50 extra scanlines |
| VBlank Duration | ~2,270 cycles | ~5,830 cycles | PAL has longer VBlank |
| Power-Up Timing | Same | Same | Reset behavior identical |

**Critical Note**: Reset handler code is identical for NTSC and PAL. Timing differences only affect frame timing, not initialization.

## NES Terminology Definitions

* **NTSC**: North American/Japanese video standard (60.098 Hz frame rate, 262 scanlines)
* **PAL**: European video standard (50.007 Hz frame rate, 312 scanlines)
* **VBlank**: Vertical blanking period (scanlines 241–260 NTSC, 241–310 PAL) when PPU is not rendering
* **Scanline**: One horizontal line of video output (~63.5 CPU cycles NTSC, ~83 CPU cycles PAL)
* **Frame**: One complete screen refresh (262 scanlines NTSC, 312 scanlines PAL)
* **NMI**: Non-Maskable Interrupt, triggered at start of VBlank
* **Mapper**: Cartridge hardware that remaps PRG/CHR ROM banks to CPU/PPU address space

## Core Rules and Invariants

* Everything revolves around **VBlank**. Safe PPU VRAM access occurs only during VBlank or forced blanking.
* The CPU runs at ~1.79 MHz (NTSC) or ~1.66 MHz (PAL). One frame = ~29,780 CPU cycles (NTSC) or ~35,400 cycles (PAL).
* The PPU renders 240 visible scanlines, then enters VBlank for ~20 scanlines (NTSC) or ~70 scanlines (PAL).
* NMI fires once per frame at the start of VBlank (scanline 241).
* CPU memory map is fixed: $0000–$1FFF RAM (mirrored), $2000–$3FFF PPU registers (mirrored), $4000–$401F APU/I/O, $4020–$5FFF cartridge expansion, $6000–$7FFF cartridge RAM, $8000–$FFFF cartridge PRG ROM.
* PPU memory map: $0000–$1FFF pattern tables (CHR ROM/RAM), $2000–$2EFF name tables (background), $3F00–$3F1F palettes, $3F20–$3FFF mirrors.

## Clock Rates and Timing Relationships

### Master Clock Frequencies

| System | Master Clock | CPU Clock | PPU Clock | CPU:PPU Ratio |
|--------|--------------|-----------|----------|--------------|
| NTSC | 21.477272 MHz | 1.789773 MHz | 5.369318 MHz | 1:3 |
| PAL | 26.601712 MHz | 1.662607 MHz | 5.320545 MHz | 1:3.2 |

**CPU Clock Calculation:**
- NTSC: Master ÷ 12 = 1.789773 MHz
- PAL: Master ÷ 16 = 1.662607 MHz

**PPU Clock Calculation:**
- NTSC: Master ÷ 4 = 5.369318 MHz
- PAL: Master ÷ 5 = 5.320545 MHz

### Frame Timing (NTSC)

| Period | Scanlines | CPU Cycles | PPU Cycles | Duration |
|--------|-----------|------------|------------|----------|
| Visible rendering | 0-239 | ~81,300 | ~1,280,000 | ~13.43 ms |
| Post-render | 240 | ~341 | ~5,370 | ~0.19 ms |
| VBlank | 241-260 | ~2,270 | ~35,700 | ~1.27 ms |
| Pre-render | 261 | ~341 | ~5,370 | ~0.19 ms |
| **Total frame** | **262** | **~89,400** | **~1,406,000** | **~16.67 ms** |

### Frame Timing (PAL)

| Period | Scanlines | CPU Cycles | PPU Cycles | Duration |
|--------|-----------|------------|------------|----------|
| Visible rendering | 0-239 | ~81,300 | ~1,280,000 | ~16.20 ms |
| Post-render | 240 | ~341 | ~5,320 | ~0.20 ms |
| VBlank | 241-310 | ~5,830 | ~91,800 | ~3.51 ms |
| Pre-render | 311 | ~341 | ~5,320 | ~0.20 ms |
| **Total frame** | **312** | **~106,500** | **~1,677,000** | **~20.00 ms** |

### CPU ↔ PPU Synchronization

**Key Timing Relationships:**
- **One scanline** = 341 CPU cycles (NTSC) or 341 CPU cycles (PAL)
- **One frame** = 262 scanlines (NTSC) or 312 scanlines (PAL)
- **NMI timing**: Fires at scanline 241, dot 1 (start of VBlank)
- **VBlank duration**: ~2,270 CPU cycles (NTSC) or ~5,830 cycles (PAL)

**Critical Constraint**: CPU and PPU are **not synchronized**. CPU runs independently, but PPU timing determines safe VRAM access windows.

### CPU ↔ PPU ↔ APU Timing Relationships

**System-Wide Timing Synchronization:**

| Component | Clock Rate | Frame Synchronization | Notes |
|-----------|------------|----------------------|-------|
| CPU | 1.79 MHz (NTSC) / 1.66 MHz (PAL) | Independent | Runs continuously |
| PPU | 5.37 MHz (NTSC) / 5.32 MHz (PAL) | 60.098 Hz (NTSC) / 50.007 Hz (PAL) | Generates NMI at VBlank |
| APU | 1.79 MHz (NTSC) / 1.66 MHz (PAL) | 240 Hz (4-step) / 192 Hz (5-step) | Frame counter driven |

**Synchronization Points:**
1. **NMI (VBlank)**: PPU triggers NMI, CPU responds
2. **Frame Counter**: APU frame counter updates at fixed intervals
3. **OAM DMA**: CPU initiates, PPU receives (513 cycles)
4. **VRAM Access**: CPU writes during VBlank (PPU idle)

**Timing Constraints:**
- **NMI Handler**: Must complete within VBlank (~2,270 cycles NTSC)
- **OAM DMA**: Takes 513 cycles (blocks CPU during transfer)
- **Frame Counter Reset**: Must write $4017 at consistent time (in NMI)
- **VRAM Updates**: Limited by VBlank duration (~1,135 bytes max NTSC)

**Critical Timing Windows:**

| Window | Duration | CPU Activity | PPU Activity | APU Activity |
|--------|----------|--------------|--------------|--------------|
| Visible rendering | ~81,300 cycles | Game logic | Rendering | Audio playback |
| VBlank | ~2,270 cycles | VRAM updates, OAM DMA | Idle | Frame counter updates |
| Frame counter update | Every 4-5 frames | APU register writes | N/A | Length/envelope updates |

**Best Practice**: Coordinate CPU, PPU, and APU activities:
- CPU game logic during visible rendering
- CPU VRAM updates during VBlank
- CPU APU updates synchronized with frame counter
- OAM DMA during VBlank (timing-critical)

## Minimal Correct Usage Example

```asm
; Minimal NES initialization
reset:
    SEI          ; Disable interrupts
    CLD          ; Clear decimal mode
    LDX #$FF
    TXS          ; Initialize stack pointer
    INX          ; X = 0
    STX $2000    ; Disable PPU rendering
    STX $2001    ; Disable rendering
    STX $4010    ; Disable DMC IRQ
    
    ; Wait for PPU to stabilize
    BIT $2002    ; Clear VBlank flag
vblank_wait1:
    BIT $2002
    BPL vblank_wait1
    
    ; Clear RAM
    LDA #0
clear_ram:
    STA $0000,X
    STA $0100,X
    STA $0200,X
    STA $0300,X
    STA $0400,X
    STA $0500,X
    STA $0600,X
    STA $0700,X
    INX
    BNE clear_ram
    
    ; Wait for second VBlank
vblank_wait2:
    BIT $2002
    BPL vblank_wait2
    
    ; Initialize PPU
    LDA #%10000000  ; Enable NMI
    STA $2000
    LDA #%00011110  ; Enable rendering
    STA $2001
    
    ; Main loop
main_loop:
    JMP main_loop

nmi:
    RTI
```

## Gold Standard Example

```asm
; Complete NES initialization following all hardware requirements
reset:
    ; Disable interrupts and initialize CPU
    SEI          ; Disable interrupts (required first)
    CLD          ; Clear decimal mode (NES doesn't use BCD)
    LDX #$FF
    TXS          ; Initialize stack pointer to $01FF
    INX          ; X = 0 (for clearing RAM)
    
    ; Disable PPU rendering
    STX $2000    ; Disable NMI (PPUCTRL = 0)
    STX $2001    ; Disable rendering (PPUMASK = 0)
    STX $4010    ; Disable DMC IRQ
    
    ; Wait for PPU to stabilize (first VBlank)
    BIT $2002    ; Clear VBlank flag
vblank_wait1:
    BIT $2002
    BPL vblank_wait1    ; Wait for VBlank flag (bit 7)
    
    ; Clear all RAM ($0000-$07FF)
    LDA #0
clear_ram:
    STA $0000,X  ; Zero page
    STA $0100,X  ; Stack
    STA $0200,X  ; OAM buffer
    STA $0300,X  ; RAM
    STA $0400,X  ; RAM
    STA $0500,X  ; RAM
    STA $0600,X  ; RAM
    STA $0700,X  ; RAM
    INX
    BNE clear_ram
    
    ; Wait for second VBlank (ensures PPU is fully stabilized)
vblank_wait2:
    BIT $2002
    BPL vblank_wait2
    
    ; Initialize PPU registers
    LDA #%10000000  ; Enable NMI, pattern table 0, name table 0
    STA $2000       ; PPUCTRL
    LDA #%00011110  ; Enable background and sprites, show left 8px
    STA $2001       ; PPUMASK
    
    ; Initialize game state
    LDA #0
    STA frame_counter
    STA frame_ready
    STA scroll_x
    STA scroll_y
    
    ; Load palette (must be done during VBlank)
    JSR load_palette
    
    ; Clear OAM buffer (move all sprites off-screen)
    LDX #0
    LDA #$FF
clear_oam:
    STA $0200,X
    INX
    BNE clear_oam
    
    ; Wait for VBlank before enabling rendering
vblank_wait3:
    BIT $2002
    BPL vblank_wait3
    
    ; Set scroll registers
    LDA $2002    ; Reset scroll latch
    LDA #0
    STA $2005    ; X scroll
    STA $2005    ; Y scroll
    
    ; Enter main loop
    JMP main_loop

nmi:
    ; Save registers
    PHA
    TXA
    PHA
    TYA
    PHA
    
    ; Clear VBlank flag
    LDA $2002
    
    ; Update OAM via DMA
    LDA #0
    STA $2003    ; OAM address
    LDA #$02     ; High byte of OAM buffer
    STA $4014    ; Start OAM DMA
    
    ; Update scroll
    LDA scroll_x
    STA $2005    ; X scroll
    LDA scroll_y
    STA $2005    ; Y scroll
    
    ; Update PPU control
    LDA ppu_ctrl
    STA $2000
    
    ; Set frame ready flag
    LDA #1
    STA frame_ready
    
    ; Restore registers
    PLA
    TAY
    PLA
    TAX
    PLA
    RTI

main_loop:
    ; Wait for frame
    LDA frame_ready
    BEQ main_loop
    
    ; Clear frame flag
    LDA #0
    STA frame_ready
    
    ; Read controllers
    JSR read_controllers
    
    ; Update game logic
    JSR update_game
    
    ; Update rendering
    JSR update_rendering
    
    JMP main_loop
```

## Validation Rules

### Hardware Requirements

1. **Interrupt Disable: SEI must be first instruction in reset handler
2. **Stack Initialization: Stack pointer must be set to $01FF before first use
3. **PPU Disable: PPU rendering must be disabled before VRAM access
4. **VBlank Waits: Must wait for 2 VBlanks to ensure PPU stabilization
5. **RAM Clearing: All RAM must be cleared to known state
6. **Register Order: PPU registers must be initialized in correct sequence
7. **VBlank Access: VRAM writes must occur during VBlank or forced blanking
8. **OAM DMA: OAM updates must use DMA (not individual writes)
9. **Scroll Latch: Must read $2002 before writing scroll registers
10. **NMI Timing: NMI handler must complete quickly (< ~2000 cycles)

### Failure Modes

* **Missing SEI: Interrupts may fire during initialization, corrupting state
* **Uninitialized Stack: Stack operations corrupt memory at $0100-$01FF
* **PPU Not Disabled: VRAM access during rendering causes corruption
* **Insufficient VBlank Waits: PPU may not be ready, causing initialization failures
* **VRAM Access Outside VBlank: Visual corruption, incorrect tiles/sprites
* **OAM Writes During Rendering: Sprite glitches, incorrect positions
* **Long NMI Handler: Delays main loop, causes frame drops, input lag
* **Missing Scroll Reset: Scroll position incorrect, screen misaligned
* **APU Not Initialized: Frame counter not running, audio desynchronized
* **RAM Not Cleared: Uninitialized variables cause unpredictable behavior

## Known Traps and Invalid Assumptions

### ❌ Invalid Assumption: Power-Up State is Zero

**Myth**: "Registers and RAM are zero at power-up"

**Reality**: All registers and RAM are **undefined** (random values)

**Fix**: Always initialize registers and clear RAM:
```asm
reset:
    SEI
    CLD
    LDX #$FF
    TXS          ; Initialize stack pointer
    ; Clear RAM
    LDA #0
    LDX #0
clear_ram:
    STA $0000,X
    STA $0100,X
    ; ... clear all RAM ...
```

### ❌ Invalid Assumption: Emulator Behavior = Hardware Behavior

**Myth**: "If it works in emulator, it works on hardware"

**Reality**: Emulators may be lenient with timing, undefined behavior, and hardware quirks

**Fix**: Always test on real hardware before finalizing

### ❌ Invalid Assumption: VBlank is Exactly 60 Hz

**Myth**: "VBlank fires exactly 60 times per second"

**Reality**: NTSC VBlank fires at **60.098 Hz** (slight variation)

**Fix**: Use frame counter for timing, not wall-clock time

### ❌ Invalid Assumption: PPU Registers Can Be Read Back

**Myth**: "PPU registers can be read to check their state"

**Reality**: Most PPU registers are **write-only**. Reading returns undefined values.

**Fix**: Maintain shadow registers in RAM for PPU state

### ❌ Invalid Assumption: Reset Button Clears RAM

**Myth**: "Reset button clears RAM to zero"

**Reality**: Reset button does **not** clear RAM. RAM contents are undefined after reset.

**Fix**: Always clear RAM in reset handler

## Debugging Heuristics

### Problem: Code works in emulator but fails on hardware

**Check:**
1. Power-up state initialization (registers, RAM)
2. Timing accuracy (cycle counts, frame timing)
3. Undefined behavior (reading unmapped memory)
4. Hardware quirks (sprite evaluation, OAM corruption)

### Problem: Sporadic crashes or corruption

**Check:**
1. Uninitialized variables (RAM not cleared)
2. Stack overflow (SP wraps around)
3. Zero page conflicts (variables overwriting each other)
4. VRAM access during rendering

### Problem: Audio desynchronization

**Check:**
1. Frame counter initialization ($4017 written)
2. Frame counter reset timing (write in NMI)
3. APU register write timing
4. DMC DMA cycle stealing

### Problem: Visual glitches

**Check:**
1. VRAM writes during rendering
2. OAM updates during rendering
3. Sprite evaluation corruption ($2002 reads)
4. Scroll register timing

## Explicit Non-Goals

This section does not cover:
* Detailed CPU instruction set (see 1.2)
* Memory map specifics (see 1.3)
* PPU rendering details (see 1.4)
* Cartridge mapper details beyond Mapper 0 (see 1.5)
* Timing-critical operations (see 2.1, 2.2)
* Game loop architecture (see 3.1)

## Cross-References

- Related Fundamentals: 1.2 (CPU), 1.3 (Memory), 1.4 (PPU), 1.5 (ROM)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.2 (NMI & VBlank)
- Related Core Concepts: 3.1 (Game Loop)
- Related Cheatsheets: 4.3 (Memory), 4.4 (Timing)
