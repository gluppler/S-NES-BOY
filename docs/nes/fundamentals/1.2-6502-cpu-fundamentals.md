# 1.2 6502 CPU Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus (Ricoh 2A03 CPU)

## Physical Hardware Overview

The NES uses a **Ricoh 2A03**, a 6502 variant with integrated APU. The CPU operates at:
* **NTSC: 1.789773 MHz (21.477272 MHz master clock ÷ 12)
* **PAL: 1.662607 MHz (26.601712 MHz master clock ÷ 16)

**Hardware Schematics**: For detailed circuit diagrams showing CPU connections, pinouts, and system architecture, see [`schematics/nes/`](../../../../schematics/nes/README.md).

The 6502 is an 8-bit processor with:
* 16-bit address bus (64 KB addressable)
* 8-bit data bus
* 8-bit accumulator (A)
* 8-bit index registers (X, Y)
* 8-bit stack pointer (SP, points to $0100–$01FF)
* 16-bit program counter (PC)
* 8-bit status register (P: N V - B D I Z C)

## CPU Variants and Power-Up State

### Ricoh 2A03 CPU Variants

The NES uses the **Ricoh 2A03** (NTSC) or **Ricoh 2A07** (PAL). Both are functionally identical 6502 variants with integrated APU.

| Variant | Region | CPU Clock | APU Clock | Notes |
|---------|--------|-----------|-----------|-------|
| 2A03 | NTSC | 1.789773 MHz | 1.789773 MHz | North America, Japan |
| 2A07 | PAL | 1.662607 MHz | 1.662607 MHz | Europe, Australia |

**Key Differences:**
- Clock speed (NTSC faster)
- Frame rate (60 Hz vs 50 Hz)
- **Instruction set identical** (same 6502 opcodes)
- **APU behavior identical** (same audio channels)

### CPU Power-Up State

When the NES is powered on or reset button is pressed:

| Register/State | Power-Up Value | Guaranteed? | Notes |
|----------------|----------------|-------------|-------|
| A (Accumulator) | Undefined | ❌ No | Random value, varies by hardware |
| X (Index) | Undefined | ❌ No | Random value, varies by hardware |
| Y (Index) | Undefined | ❌ No | Random value, varies by hardware |
| SP (Stack Pointer) | Undefined | ❌ No | Random value, **must initialize** |
| PC (Program Counter) | Undefined | ❌ No | Random value, reset vector loads from $FFFC |
| P (Status Register) | $34 | ✅ Yes | I=1 (interrupts disabled), D=0, B=1, others undefined |
| RAM ($0000–$07FF) | Undefined | ❌ No | Random values, **must clear** |
| APU Registers | Undefined | ❌ No | Random values, **must initialize** |

**Status Register Power-Up ($34 = %00110100):**
- Bit 7 (N): Undefined
- Bit 6 (V): Undefined
- Bit 5: Always 1 (unused bit)
- Bit 4 (B): 1 (Break flag set)
- Bit 3 (D): 0 (Decimal mode off)
- Bit 2 (I): 1 (Interrupts disabled) ← **Critical**
- Bit 1 (Z): Undefined
- Bit 0 (C): Undefined

### Reset Behavior

**Reset Vector Location:** $FFFC–$FFFD (low byte, high byte)

**Reset Sequence:**
1. CPU reads reset vector from $FFFC–$FFFD
2. PC is loaded with vector value
3. I flag is set (interrupts disabled)
4. Stack pointer is **undefined** (must initialize)
5. All other registers are **undefined**

**Reset Handler Requirements:**
```asm
reset:
    SEI          ; Disable interrupts (I flag already set, but explicit)
    CLD          ; Clear decimal mode (D already 0, but explicit)
    LDX #$FF
    TXS          ; Initialize stack pointer (CRITICAL: SP is undefined)
    ; ... rest of initialization ...
```

**Critical Reset Handler Steps:**
1. **SEI first**: Disable interrupts (may already be set, but be explicit)
2. **CLD**: Clear decimal mode (NES doesn't use BCD, but be safe)
3. **Initialize SP**: Stack pointer is undefined, must set to $FF
4. **Clear RAM**: RAM contents are undefined, must clear
5. **Initialize PPU**: PPU registers are undefined
6. **Initialize APU**: APU registers are undefined

### CPU Reset vs Power-Up

| Aspect | Power-Up | Reset Button |
|--------|----------|--------------|
| Reset Vector | ✅ Loaded | ✅ Loaded |
| I Flag | ✅ Set | ✅ Set |
| Other Registers | ❌ Undefined | ❌ Undefined |
| RAM Contents | ❌ Undefined | ❌ Undefined (may retain values briefly) |
| PPU State | ❌ Undefined | ❌ Undefined |
| APU State | ❌ Undefined | ❌ Undefined |

**Key Point**: Reset button and power-up have **identical behavior** from CPU perspective. Both require full initialization.

## NES Terminology Definitions

* **Accumulator (A): Primary arithmetic/logic register
* **Index Registers (X, Y): Used for indexing memory and loops
* **Stack Pointer (SP): Points to $0100–$01FF (hardware stack)
* **Status Register (P): Flags (N=Negative, V=Overflow, B=Break, D=Decimal, I=Interrupt, Z=Zero, C=Carry)
* **Zero Page: First 256 bytes ($0000–$00FF), faster addressing
* **Addressing Mode: How an instruction determines its operand address
* **Page: 256-byte block (e.g., $0100–$01FF is "page 1")
* **Page Boundary: Crossing from $XXFF to $XX00 incurs cycle penalty

## Core Rules and Invariants

### Registers

* **A: Accumulator, used by most arithmetic/logic operations
* **X: Index register, used for loops, indexing, stack manipulation
* **Y: Index register, used for loops and indexing
* **SP: Stack pointer (8-bit, wraps at $00/$FF), points to $0100–$01FF
* **PC: Program counter (16-bit), points to current instruction
* **P: Status register, updated by most instructions

### Addressing Modes

* **Immediate: `LDA #$42` (operand is literal value)
* **Zero Page: `LDA $42` (operand is address $0042, 1-byte address)
* **Zero Page,X: `LDA $42,X` (operand is $0042 + X, wraps at page boundary)
* **Zero Page,Y: `LDA $42,Y` (operand is $0042 + Y, wraps at page boundary)
* **Absolute: `LDA $1234` (operand is address $1234, 2-byte address)
* **Absolute,X: `LDA $1234,X` (operand is $1234 + X, may cross page)
* **Absolute,Y: `LDA $1234,Y` (operand is $1234 + Y, may cross page)
* **Indirect: `JMP ($1234)` (operand is address at $1234, low byte first)
* **Indirect,X: `LDA ($42,X)` (operand is address at $0042+X, wraps)
* **Indirect,Y: `LDA ($42),Y` (operand is address at $0042 + Y, may cross page)

### Instruction Categories

* **Load/Store: LDA, LDX, LDY, STA, STX, STY
* **Arithmetic: ADC, SBC, INC, DEC, INX, DEX, INY, DEY
* **Logic: AND, ORA, EOR, ASL, LSR, ROL, ROR
* **Branches: BCC, BCS, BEQ, BMI, BNE, BPL, BVC, BVS (relative, ±127 bytes)
* **Jumps: JMP (absolute/indirect), JSR (absolute), RTS
* **Stack: PHA, PHP, PLA, PLP, TSX, TXS
* **Flags: CLC, SEC, CLI, SEI, CLV, CLD, SED
* **Misc: NOP, BRK, RTI

### Stack Behavior

* Stack grows **downward** (SP decrements on push)
* Stack is fixed at $0100–$01FF (cannot be relocated)
* PHA pushes A, PHP pushes P, PLA pulls A, PLP pulls P
* JSR pushes return address-1 (high byte, then low byte)
* RTS pulls return address and adds 1
* Stack overflow/underflow wraps (SP is 8-bit)

## Minimal Correct Usage Example

```asm
; Zero page usage
LDA #$10        ; Load immediate value
STA $00         ; Store to zero page ($0000)
LDX #$05        ; Load X with 5
LDA $00,X       ; Load from zero page indexed ($0005)

; Absolute addressing
LDA $1234       ; Load from absolute address
STA $5678       ; Store to absolute address

; Indexed addressing
LDY #$10
LDA $2000,Y     ; Load from $2010

; Stack operations
PHA             ; Push accumulator
PLA             ; Pull accumulator

; Branching
LDA $00
CMP #$10
BEQ equal       ; Branch if equal
; ... not equal code ...
equal:
; ... equal code ...

; Subroutine
JSR my_sub      ; Call subroutine
; ... continues after return ...
my_sub:
    PHA         ; Save A
    ; ... subroutine code ...
    PLA         ; Restore A
    RTS         ; Return
```

## Gold Standard Example

```asm
; Complete 6502 usage example following best practices
reset:
    ; Initialize CPU
    SEI          ; Disable interrupts
    CLD          ; Clear decimal mode
    LDX #$FF
    TXS          ; Initialize stack pointer to $01FF
    
    ; Zero page usage (fastest addressing)
    LDA #$42
    STA $00      ; Store to zero page (3 cycles)
    LDX #$05
    LDA $00,X    ; Load from zero page indexed (4 cycles)
    
    ; Absolute addressing
    LDA #$12
    STA $0300    ; Store to RAM (4 cycles)
    LDA $0300    ; Load from RAM (4 cycles)
    
    ; Indexed addressing
    LDY #$10
    LDA $2000,Y  ; Load from $2010 (4-5 cycles, may cross page)
    
    ; Arithmetic operations
    LDA #$10
    CLC          ; Clear carry
    ADC #$20     ; Add with carry
    STA $00      ; Store result
    
    ; Logic operations
    LDA #$0F
    AND #$F0     ; AND operation
    ORA #$05     ; OR operation
    EOR #$FF     ; XOR operation
    STA $00
    
    ; Shifts
    LDA #$42
    ASL          ; Arithmetic shift left (multiply by 2)
    LSR          ; Logical shift right (divide by 2)
    ROL          ; Rotate left through carry
    ROR          ; Rotate right through carry
    STA $00
    
    ; Branching with proper patterns
    LDA $00
    CMP #$10
    BCC less_than    ; Branch if < $10 (not-taken preferred)
    BEQ equal        ; Branch if = $10
    ; Greater than code here
    JMP done
less_than:
    ; Less than code here
    JMP done
equal:
    ; Equal code here
done:
    
    ; Subroutine with register preservation
    JSR my_subroutine
    ; ... continues ...
    
    JMP main_loop

my_subroutine:
    PHA          ; Save accumulator
    TXA
    PHA          ; Save X register
    TYA
    PHA          ; Save Y register
    
    ; Subroutine code here
    LDA #$42
    STA $00
    
    PLA          ; Restore Y register
    TAY
    PLA          ; Restore X register
    TAX
    PLA          ; Restore accumulator
    RTS          ; Return
```

## Validation Rules

### Register Usage Rules

1. **Accumulator (A): Primary register for arithmetic and logic operations
2. **Index Registers (X, Y): Use for loops, indexing, and temporary storage
3. **Stack Pointer (SP): Must be initialized to $FF before first use
4. **Status Register (P): Automatically updated by most instructions

### Addressing Mode Rules

1. **Zero Page: Use for frequently accessed variables (3 cycles vs 4 cycles)
2. **Zero Page Indexed: X wraps at page boundary, Y does not wrap
3. **Absolute Indexed: May incur page crossing penalty (+1 cycle)
4. **Indirect: Only available for JMP instruction
5. **Indirect Indexed: Y may cause page crossing, X wraps

### Instruction Rules

1. **Arithmetic: Always clear/set carry (CLC/SEC) before ADC/SBC
2. **Branches: Relative addressing, ±127 bytes range
3. **Jumps: Absolute or indirect addressing
4. **Stack: Grows downward, fixed at $0100-$01FF
5. **Flags: Decimal mode (D flag) not used on NES

### Failure Modes

* **Uninitialized Stack: Stack pointer at $00 causes stack to wrap
* **Page Crossing: Unexpected cycle penalty in timing-critical code
* **Carry Not Cleared: ADC produces incorrect results
* **Stack Overflow: Pushing more than 256 bytes wraps stack pointer
* **Branch Out of Range: Branching beyond ±127 bytes fails silently
* **Decimal Mode: Setting D flag causes incorrect BCD arithmetic

## Synthetic Instructions (Common Patterns)

Synthetic instructions are instruction sequences that act like single operations. These are commonly used patterns that optimize for size or speed:

### Transfer Operations

| Operation | Pattern | Cycles | Notes |
|-----------|---------|--------|-------|
| `TAX` (A→X) | `TAX` | 2 | Native instruction |
| `TXA` (X→A) | `TXA` | 2 | Native instruction |
| `TAY` (A→Y) | `TAY` | 2 | Native instruction |
| `TYA` (Y→A) | `TYA` | 2 | Native instruction |
| `TXS` (X→SP) | `TXS` | 2 | Native instruction |
| `TSX` (SP→X) | `TSX` | 2 | Native instruction |
| Clear A | `LDA #0` | 2 | Faster than `AND #0` |
| Clear X | `LDX #0` | 2 | |
| Clear Y | `LDY #0` | 2 | |
| Clear Carry | `CLC` | 2 | |
| Set Carry | `SEC` | 2 | |
| Clear Zero | `LDA #1` then `LDA #0` | 4 | Only way to clear Z flag |

### Memory Operations

| Operation | Pattern | Cycles | Notes |
|-----------|---------|--------|-------|
| `INC addr` | `INC addr` | 5-7 | Native instruction |
| `DEC addr` | `DEC addr` | 5-7 | Native instruction |
| `INC A` | `CLC; ADC #1` | 4 | Alternative to `INC` (doesn't exist for A) |
| `DEC A` | `SEC; SBC #1` | 4 | Alternative to `DEC` (doesn't exist for A) |
| `ASL A` | `ASL` | 2 | Accumulator mode |
| `LSR A` | `LSR` | 2 | Accumulator mode |
| `ROL A` | `ROL` | 2 | Accumulator mode |
| `ROR A` | `ROR` | 2 | Accumulator mode |

### Comparison Operations

| Operation | Pattern | Cycles | Notes |
|-----------|---------|--------|-------|
| Compare A to 0 | `CMP #0` or `ORA #0` | 2 | `ORA` sets flags without modifying A |
| Compare X to 0 | `CPX #0` or `TXA; ORA #0` | 2-4 | |
| Compare Y to 0 | `CPY #0` or `TYA; ORA #0` | 2-4 | |
| Test if A = X | `STX temp; CMP temp` | 5-6 | Requires temp variable |
| Test if A = Y | `STY temp; CMP temp` | 5-6 | Requires temp variable |

### Branch Patterns

| Pattern | Code | Cycles | Use Case |
|---------|------|--------|----------|
| Branch if A = 0 | `BEQ label` | 2-3 | After operation that sets Z |
| Branch if A ≠ 0 | `BNE label` | 2-3 | After operation that sets Z |
| Branch if A < 0 | `BMI label` | 2-3 | After operation that sets N |
| Branch if A ≥ 0 | `BPL label` | 2-3 | After operation that sets N |
| Branch if A < value | `CMP #value; BCC label` | 4-5 | Unsigned comparison |
| Branch if A ≥ value | `CMP #value; BCS label` | 4-5 | Unsigned comparison |

### Jump Tables and Pointer Tables

**Jump Table Pattern:**
```asm
; Jump table: array of addresses
jump_table:
    .word handler_0, handler_1, handler_2, handler_3

; Jump based on index in A (0-3)
    ASL A              ; Multiply by 2 (addresses are 2 bytes)
    TAX
    LDA jump_table+1,X ; High byte
    PHA
    LDA jump_table,X   ; Low byte
    PHA
    RTS                ; RTS trick: jump to address on stack
```

**Pointer Table Pattern:**
```asm
; Pointer table: array of 16-bit pointers
data_table:
    .word data_0, data_1, data_2

; Load pointer based on index in X
    TXA
    ASL A              ; Multiply by 2
    TAX
    LDA data_table,X   ; Low byte
    STA zp_ptr
    LDA data_table+1,X ; High byte
    STA zp_ptr+1
    ; Now (zp_ptr),Y points to data
```

**RTS Trick (Subroutine Return Jump):**
```asm
; Push address on stack, then RTS to jump there
    LDA #>target_address
    PHA
    LDA #<target_address
    PHA
    RTS                ; Jumps to target_address
```

### Scanning Tables

**Linear Search:**
```asm
; Search for value in A within table
    LDX #0
search_loop:
    CMP table,X
    BEQ found
    INX
    CPX #table_size
    BNE search_loop
    ; Not found
found:
    ; X contains index
```

**Binary Search (for sorted tables):**
```asm
; Binary search requires more complex logic
; Typically uses lookup table instead for speed
```

## Unofficial Opcodes (Advanced)

The 6502 has undocumented opcodes that result from instruction decoding quirks. **WARNING: These are unreliable and may behave differently on different hardware revisions. Use only if absolutely necessary and test thoroughly.**

| Opcode | Mnemonic | Cycles | Behavior | Reliability |
|--------|----------|--------|----------|-------------|
| $1A | `NOP` | 2 | No operation | Reliable |
| $3A | `NOP` | 2 | No operation | Reliable |
| $5A | `NOP` | 2 | No operation | Reliable |
| $7A | `NOP` | 2 | No operation | Reliable |
| $DA | `NOP` | 2 | No operation | Reliable |
| $FA | `NOP` | 2 | No operation | Reliable |
| $80 | `NOP #imm` | 2 | No operation (eats immediate byte) | Reliable |
| $04, $44, $64 | `NOP zp` | 3 | No operation (eats zero page byte) | Reliable |
| $0C | `NOP abs` | 4 | No operation (eats absolute address) | Reliable |

**Recommendation:** Avoid unofficial opcodes unless you have a specific need (e.g., cycle-accurate timing). Standard `NOP` ($EA) is always safe.

## Common Anti-Patterns and Gotchas

### ❌ Anti-Pattern: Using Absolute Addressing for Hot Variables

```asm
; BAD: Absolute addressing in hot loop
player_x = $0300
update_loop:
    LDA player_x      ; 4 cycles
    INC A
    STA player_x      ; 4 cycles
    ; Total: 8 cycles per iteration
```

```asm
; GOOD: Zero page addressing
zp_player_x = $09
update_loop:
    LDA zp_player_x   ; 3 cycles
    INC A
    STA zp_player_x   ; 3 cycles
    ; Total: 6 cycles per iteration (25% faster)
```

### ❌ Anti-Pattern: Not Clearing Carry Before Addition

```asm
; BAD: Carry may be set from previous operation
    ADC #10           ; May produce incorrect result
```

```asm
; GOOD: Always clear carry before addition
    CLC
    ADC #10           ; Correct result
```

### ❌ Anti-Pattern: Using Decimal Mode

```asm
; BAD: Decimal mode on NES
    SED               ; Enables BCD mode
    ADC #$05          ; Produces incorrect results
```

```asm
; GOOD: Always clear decimal mode
    CLD               ; Disable BCD mode (required on NES)
    ADC #$05          ; Correct binary arithmetic
```

### ❌ Anti-Pattern: Branch Out of Range

```asm
; BAD: Branch may be out of range (±127 bytes)
    BEQ far_label     ; May fail silently if >127 bytes away
```

```asm
; GOOD: Use JMP for long distances
    BEQ near_branch
    JMP far_label
near_branch:
    ; ...
```

### ❌ Anti-Pattern: Indirect JMP Bug

```asm
; BAD: Indirect JMP at page boundary
    JMP ($12FF)       ; Reads $12FF, $1200 (WRONG!)
```

```asm
; GOOD: Avoid page boundaries for indirect JMP
    JMP ($12FE)       ; Reads $12FE, $12FF (CORRECT)
```

### ❌ Anti-Pattern: Stack Overflow

```asm
; BAD: Deeply nested subroutines without checking
    JSR level1
level1:
    JSR level2
level2:
    JSR level3        ; May overflow stack
level3:
    RTS
```

```asm
; GOOD: Limit nesting or use state machine
    ; Keep call depth < 8 levels
    ; Or restructure to avoid deep nesting
```

## Debugging Heuristics

### Problem: Code works in emulator but fails on hardware

**Check:**
1. Cycle timing accuracy (emulator may be lenient)
2. Undefined behavior (reading from unmapped memory)
3. Initialization order (RAM state on real hardware)
4. Interrupt timing (NMI/IRQ may fire at different times)

### Problem: Sporadic crashes or corruption

**Check:**
1. Stack overflow (SP wraps around)
2. Zero page conflicts (variables overwriting each other)
3. Uninitialized pointers (indirect addressing with garbage)
4. Page boundary crossings (unexpected cycle penalties)

### Problem: Incorrect arithmetic results

**Check:**
1. Carry flag not cleared before ADC
2. Decimal mode enabled (SED not cleared)
3. Overflow in signed arithmetic (check V flag)
4. Page boundary crossing affecting timing

### Problem: Branches not working

**Check:**
1. Branch distance > ±127 bytes
2. Flags not set correctly before branch
3. Page boundary crossing (+1 cycle penalty)
4. Branch target alignment

## Emulator vs Hardware Divergence Notes

| Behavior | Emulator | Hardware | Notes |
|----------|----------|----------|-------|
| Cycle accuracy | May be approximate | Exact | Some emulators round cycles |
| Undefined opcodes | May work | Unpredictable | Test on real hardware |
| RAM initialization | Usually zero | Random | Always clear RAM |
| Interrupt timing | May be lenient | Exact | NMI timing is critical |
| PPU register reads | May return last write | Actual hardware state | Read $2002 for real status |
| Stack overflow | May detect | Silent wrap | No hardware protection |

**Best Practice:** Always test on real hardware before finalizing. Emulators are excellent for development but cannot catch all hardware-specific issues.

## Hardware Quirks and Undefined Behavior

### Undefined Opcodes

The 6502 has undocumented opcodes that result from instruction decoding quirks. **Behavior is unreliable and varies by hardware revision.**

**Recommendation**: Avoid undocumented opcodes unless absolutely necessary for cycle-accurate timing. Use standard `NOP` ($EA) for delays.

### Unstable Behavior

| Behavior | Guaranteed? | Notes |
|---------|-------------|-------|
| Register values at power-up | ❌ No | A, X, Y, SP, PC are undefined |
| RAM contents at power-up | ❌ No | All RAM is undefined |
| Indirect JMP at page boundary | ⚠️ Bug | Reads wrong address (hardware bug) |
| Decimal mode on NES | ❌ No | NES doesn't support BCD arithmetic |
| Stack overflow | ⚠️ Wraps | No hardware protection, wraps silently |

### Emulator vs Hardware Divergence

| Behavior | Emulator | Hardware | Notes |
|----------|----------|----------|-------|
| Power-up register values | May be 0 | Random | Emulators often initialize to 0 |
| RAM contents at power-up | May be 0 | Random | Emulators often clear RAM |
| Undefined opcodes | May work | Unpredictable | Emulators may implement differently |
| Cycle accuracy | Approximate | Exact | Some emulators round cycles |
| Stack overflow | May detect | Silent wrap | Emulators may warn, hardware doesn't |

**Best Practice**: Always test on real hardware. Emulators are excellent for development but cannot catch all hardware-specific issues.

## Explicit Non-Goals

This section does not cover:
* Detailed cycle counts and timing (see 2.1)
* Branch penalties and page crossings (see 2.1)
* NMI/IRQ handling (see 2.2)
* Memory map specifics (see 1.3)
* Advanced optimization techniques (see 2.6)
* APU behavior (see 2.5)

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.3 (Memory)
- Related Advanced Fundamentals: 2.1 (CPU Timing & Cycles), 2.6 (Optimization Techniques)
- Related Core Concepts: 3.2 (Data-Oriented Design)
- Related Cheatsheets: 4.1 (CPU Cheatsheets)
