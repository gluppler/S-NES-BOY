# 1.2 6502 CPU Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus (Ricoh 2A03 CPU)

## Physical Hardware Overview

The NES uses a **Ricoh 2A03**, a 6502 variant with integrated APU. The CPU operates at:
* **NTSC: 1.789773 MHz (21.477272 MHz master clock ÷ 12)
* **PAL: 1.662607 MHz (26.601712 MHz master clock ÷ 16)

The 6502 is an 8-bit processor with:
* 16-bit address bus (64 KB addressable)
* 8-bit data bus
* 8-bit accumulator (A)
* 8-bit index registers (X, Y)
* 8-bit stack pointer (SP, points to $0100–$01FF)
* 16-bit program counter (PC)
* 8-bit status register (P: N V - B D I Z C)

## NES Terminology Definitions

* **Accumulator (A): Primary arithmetic/logic register
* **Index Registers (X, Y): Used for indexing memory and loops
* **Stack Pointer (SP): Points to $0100–$01FF (hardware stack)
* **Status Register (P): Flags (N=Negative, V=Overflow, B=Break, D=Decimal, I=Interrupt, Z=Zero, C=Carry)
* **Zero Page: First 256 bytes ($0000–$00FF), faster addressing
* **Addressing Mode: How an instruction determines its operand address
* **Page: 256-byte block (e.g., $0100–$01FF is "page 1")
* **Page Boundary: Crossing from $XXFF to $XX00 incurs cycle penalty

## Core Rules and Invariants

### Registers

* **A: Accumulator, used by most arithmetic/logic operations
* **X: Index register, used for loops, indexing, stack manipulation
* **Y: Index register, used for loops and indexing
* **SP: Stack pointer (8-bit, wraps at $00/$FF), points to $0100–$01FF
* **PC: Program counter (16-bit), points to current instruction
* **P: Status register, updated by most instructions

### Addressing Modes

* **Immediate: `LDA #$42` (operand is literal value)
* **Zero Page: `LDA $42` (operand is address $0042, 1-byte address)
* **Zero Page,X: `LDA $42,X` (operand is $0042 + X, wraps at page boundary)
* **Zero Page,Y: `LDA $42,Y` (operand is $0042 + Y, wraps at page boundary)
* **Absolute: `LDA $1234` (operand is address $1234, 2-byte address)
* **Absolute,X: `LDA $1234,X` (operand is $1234 + X, may cross page)
* **Absolute,Y: `LDA $1234,Y` (operand is $1234 + Y, may cross page)
* **Indirect: `JMP ($1234)` (operand is address at $1234, low byte first)
* **Indirect,X: `LDA ($42,X)` (operand is address at $0042+X, wraps)
* **Indirect,Y: `LDA ($42),Y` (operand is address at $0042 + Y, may cross page)

### Instruction Categories

* **Load/Store: LDA, LDX, LDY, STA, STX, STY
* **Arithmetic: ADC, SBC, INC, DEC, INX, DEX, INY, DEY
* **Logic: AND, ORA, EOR, ASL, LSR, ROL, ROR
* **Branches: BCC, BCS, BEQ, BMI, BNE, BPL, BVC, BVS (relative, ±127 bytes)
* **Jumps: JMP (absolute/indirect), JSR (absolute), RTS
* **Stack: PHA, PHP, PLA, PLP, TSX, TXS
* **Flags: CLC, SEC, CLI, SEI, CLV, CLD, SED
* **Misc: NOP, BRK, RTI

### Stack Behavior

* Stack grows **downward** (SP decrements on push)
* Stack is fixed at $0100–$01FF (cannot be relocated)
* PHA pushes A, PHP pushes P, PLA pulls A, PLP pulls P
* JSR pushes return address-1 (high byte, then low byte)
* RTS pulls return address and adds 1
* Stack overflow/underflow wraps (SP is 8-bit)

## Minimal Correct Usage Example

```asm
; Zero page usage
LDA #$10        ; Load immediate value
STA $00         ; Store to zero page ($0000)
LDX #$05        ; Load X with 5
LDA $00,X       ; Load from zero page indexed ($0005)

; Absolute addressing
LDA $1234       ; Load from absolute address
STA $5678       ; Store to absolute address

; Indexed addressing
LDY #$10
LDA $2000,Y     ; Load from $2010

; Stack operations
PHA             ; Push accumulator
PLA             ; Pull accumulator

; Branching
LDA $00
CMP #$10
BEQ equal       ; Branch if equal
; ... not equal code ...
equal:
; ... equal code ...

; Subroutine
JSR my_sub      ; Call subroutine
; ... continues after return ...
my_sub:
    PHA         ; Save A
    ; ... subroutine code ...
    PLA         ; Restore A
    RTS         ; Return
```

## Gold Standard Example

```asm
; Complete 6502 usage example following best practices
reset:
    ; Initialize CPU
    SEI          ; Disable interrupts
    CLD          ; Clear decimal mode
    LDX #$FF
    TXS          ; Initialize stack pointer to $01FF
    
    ; Zero page usage (fastest addressing)
    LDA #$42
    STA $00      ; Store to zero page (3 cycles)
    LDX #$05
    LDA $00,X    ; Load from zero page indexed (4 cycles)
    
    ; Absolute addressing
    LDA #$12
    STA $0300    ; Store to RAM (4 cycles)
    LDA $0300    ; Load from RAM (4 cycles)
    
    ; Indexed addressing
    LDY #$10
    LDA $2000,Y  ; Load from $2010 (4-5 cycles, may cross page)
    
    ; Arithmetic operations
    LDA #$10
    CLC          ; Clear carry
    ADC #$20     ; Add with carry
    STA $00      ; Store result
    
    ; Logic operations
    LDA #$0F
    AND #$F0     ; AND operation
    ORA #$05     ; OR operation
    EOR #$FF     ; XOR operation
    STA $00
    
    ; Shifts
    LDA #$42
    ASL          ; Arithmetic shift left (multiply by 2)
    LSR          ; Logical shift right (divide by 2)
    ROL          ; Rotate left through carry
    ROR          ; Rotate right through carry
    STA $00
    
    ; Branching with proper patterns
    LDA $00
    CMP #$10
    BCC less_than    ; Branch if < $10 (not-taken preferred)
    BEQ equal        ; Branch if = $10
    ; Greater than code here
    JMP done
less_than:
    ; Less than code here
    JMP done
equal:
    ; Equal code here
done:
    
    ; Subroutine with register preservation
    JSR my_subroutine
    ; ... continues ...
    
    JMP main_loop

my_subroutine:
    PHA          ; Save accumulator
    TXA
    PHA          ; Save X register
    TYA
    PHA          ; Save Y register
    
    ; Subroutine code here
    LDA #$42
    STA $00
    
    PLA          ; Restore Y register
    TAY
    PLA          ; Restore X register
    TAX
    PLA          ; Restore accumulator
    RTS          ; Return
```

## Validation Rules

### Register Usage Rules

1. **Accumulator (A): Primary register for arithmetic and logic operations
2. **Index Registers (X, Y): Use for loops, indexing, and temporary storage
3. **Stack Pointer (SP): Must be initialized to $FF before first use
4. **Status Register (P): Automatically updated by most instructions

### Addressing Mode Rules

1. **Zero Page: Use for frequently accessed variables (3 cycles vs 4 cycles)
2. **Zero Page Indexed: X wraps at page boundary, Y does not wrap
3. **Absolute Indexed: May incur page crossing penalty (+1 cycle)
4. **Indirect: Only available for JMP instruction
5. **Indirect Indexed: Y may cause page crossing, X wraps

### Instruction Rules

1. **Arithmetic: Always clear/set carry (CLC/SEC) before ADC/SBC
2. **Branches: Relative addressing, ±127 bytes range
3. **Jumps: Absolute or indirect addressing
4. **Stack: Grows downward, fixed at $0100-$01FF
5. **Flags: Decimal mode (D flag) not used on NES

### Failure Modes

* **Uninitialized Stack: Stack pointer at $00 causes stack to wrap
* **Page Crossing: Unexpected cycle penalty in timing-critical code
* **Carry Not Cleared: ADC produces incorrect results
* **Stack Overflow: Pushing more than 256 bytes wraps stack pointer
* **Branch Out of Range: Branching beyond ±127 bytes fails silently
* **Decimal Mode: Setting D flag causes incorrect BCD arithmetic

## Explicit Non-Goals

This section does not cover:
* Cycle counts and timing (see 2.1)
* Branch penalties and page crossings (see 2.1)
* NMI/IRQ handling (see 2.2)
* Memory map specifics (see 1.3)
* Advanced optimization techniques

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.3 (Memory)
- Related Advanced Fundamentals: 2.1 (CPU Timing & Cycles)
- Related Core Concepts: 3.2 (Data-Oriented Design)
- Related Cheatsheets: 4.1 (CPU Cheatsheets)
