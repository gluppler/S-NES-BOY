# 1.3 Memory Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus

## Physical Hardware Overview

The NES CPU has a 16-bit address bus, providing 64 KB ($0000–$FFFF) of addressable space. This space is divided into:

* **Internal RAM: 2 KB of work RAM, mirrored four times
* **PPU Registers: Memory-mapped I/O for PPU communication, mirrored
* **APU/I/O Registers: Audio and controller I/O, not mirrored
* **Cartridge Space: PRG ROM, CHR ROM, mapper registers, optional RAM

The PPU has its own 14-bit address bus (16 KB), separate from the CPU bus.

## NES Terminology Definitions

* **CPU Memory Map: The 64 KB address space visible to the CPU
* **PPU Memory Map: The 16 KB address space visible to the PPU
* **Zero Page: First 256 bytes ($0000–$00FF), fastest addressing mode
* **Stack: Fixed 256-byte region at $0100–$01FF, grows downward
* **Mirroring: Multiple addresses map to the same physical memory
* **Memory-Mapped I/O: Hardware registers accessible as memory addresses
* **PRG ROM: Program ROM, contains CPU code and data
* **CHR ROM: Character ROM, contains PPU pattern data (tiles)
* **Mapper: Cartridge hardware that remaps ROM banks

## Core Rules and Invariants

### CPU Memory Map ($0000–$FFFF)

| Address Range | Size | Description | Notes |
|--------------|------|-------------|-------|
| $0000–$1FFF | 8 KB | Internal RAM | Mirrored 4 times (actual RAM: $0000–$07FF) |
| $2000–$3FFF | 8 KB | PPU Registers | Mirrored every 8 bytes ($2000–$2007) |
| $4000–$401F | 32 B | APU/I/O Registers | APU, controllers, expansion |
| $4020–$5FFF | 8 KB | Cartridge Expansion | Mapper-specific |
| $6000–$7FFF | 8 KB | Cartridge RAM | Optional SRAM (battery-backed) |
| $8000–$FFFF | 32 KB | Cartridge PRG ROM | Mapper 0: fixed 32 KB or 16 KB + mirror |

### Zero Page Philosophy

* Zero page ($0000–$00FF) uses 1-byte addresses (faster, fewer cycles)
* Critical variables should live in zero page
* Zero page is precious real estate; allocate carefully
* Zero page indexed addressing wraps at page boundary ($00FF + 1 = $0000)

### Stack Location and Constraints

* Stack is **fixed** at $0100–$01FF (cannot be relocated)
* Stack pointer (SP) is 8-bit, wraps automatically
* Stack grows **downward** (SP decrements on push)
* Initial SP should be set to $FF (points to $01FF)
* Stack overflow/underflow wraps silently (no hardware protection)

### ROM vs RAM vs Memory-Mapped I/O

* **ROM: Read-only, contains code/data from cartridge
* **RAM: Read-write, volatile (lost on power-off)
* **SRAM: Battery-backed RAM in cartridge ($6000–$7FFF)
* **Memory-Mapped I/O: Registers that control hardware, not storage

### PPU Memory Map ($0000–$3FFF)

| Address Range | Size | Description |
|--------------|------|-------------|
| $0000–$0FFF | 4 KB | Pattern Table 0 (or CHR ROM bank 0) |
| $1000–$1FFF | 4 KB | Pattern Table 1 (or CHR ROM bank 1) |
| $2000–$23FF | 1 KB | Name Table 0 |
| $2400–$27FF | 1 KB | Name Table 1 |
| $2800–$2BFF | 1 KB | Name Table 2 |
| $2C00–$2FFF | 1 KB | Name Table 3 |
| $3000–$3EFF | 3.75 KB | Mirrors of $2000–$2EFF |
| $3F00–$3F1F | 32 B | Palette RAM |
| $3F20–$3FFF | 224 B | Mirrors of $3F00–$3F1F |

## Minimal Correct Usage Example

```asm
; Zero page allocation
zp_temp = $00       ; Temporary variable
zp_ptr = $02        ; 16-bit pointer (low, high)

; Using zero page
LDA #$42
STA zp_temp         ; Store to zero page (faster)

; 16-bit pointer in zero page
LDA #<data_table    ; Low byte
STA zp_ptr
LDA #>data_table    ; High byte
STA zp_ptr+1

; Indirect addressing through zero page pointer
LDY #0
LDA (zp_ptr),Y      ; Load from address in zp_ptr

; Stack usage
PHA                 ; Push A
TXA
PHA                 ; Push X
; ... use A and X ...
PLA                 ; Pull X
TAX
PLA                 ; Pull A

; Accessing PPU registers
LDA $2002           ; Read PPU status (clears VBlank flag)
LDA #$20
STA $2006           ; PPU address high
LDA #$00
STA $2006           ; PPU address low
LDA $2007           ; Read from PPU data

data_table:
    .byte $01, $02, $03
```

## Gold Standard Example

```asm
; Complete memory usage example following best practices
reset:
    ; Initialize zero page variables (fastest access)
    LDA #0
    STA frame_counter    ; $04 - frame counter
    STA frame_ready      ; $05 - frame synchronization
    STA scroll_x         ; $06 - horizontal scroll
    STA scroll_y         ; $07 - vertical scroll
    
    ; Set up zero page pointer
    LDA #<data_table
    STA zp_ptr           ; $02 - pointer low byte
    LDA #>data_table
    STA zp_ptr+1         ; $03 - pointer high byte
    
    ; Access data via pointer (indirect indexed)
    LDY #0
    LDA (zp_ptr),Y       ; Load first byte from data_table
    
    ; Stack operations (preserve registers)
    PHA                  ; Save accumulator
    TXA
    PHA                  ; Save X register
    TYA
    PHA                  ; Save Y register
    
    ; Use registers for temporary operations
    LDA #$42
    TAX                  ; Transfer to X
    TXA                  ; Transfer back to A
    
    ; Restore registers
    PLA                  ; Restore Y
    TAY
    PLA                  ; Restore X
    TAX
    PLA                  ; Restore A
    
    ; Access PPU registers (memory-mapped I/O)
    LDA $2002            ; Read PPU status (clears VBlank flag)
    LDA #$3F
    STA $2006            ; PPU address high
    LDA #$00
    STA $2006            ; PPU address low
    LDA $2007            ; Read from PPU data
    
    ; Access APU registers
    LDA #$00
    STA $4000            ; Pulse 1 control
    STA $4001            ; Pulse 1 sweep
    STA $4002            ; Pulse 1 timer low
    STA $4003            ; Pulse 1 timer high
    
    ; Access controller
    LDA #$01
    STA $4016            ; Strobe controller
    LDA #$00
    STA $4016            ; Clear strobe
    LDA $4016            ; Read button A
    
    ; RAM usage (game state)
    LDA #1
    STA game_state       ; $0300 - game state
    LDA #3
    STA lives           ; $0302 - player lives
    
    ; OAM buffer access
    LDX #0
    LDA #$FF
clear_oam:
    STA $0200,X          ; OAM buffer at $0200-$02FF
    INX
    BNE clear_oam
    
    RTS

; Data in ROM
data_table:
    .byte $01, $02, $03, $04
```

## Validation Rules

### Memory Access Rules

1. **Zero Page Priority: Frequently accessed variables must be in zero page
2. **Stack Usage: Stack is fixed at $0100-$01FF, cannot be relocated
3. **Register Preservation: Save/restore registers in subroutines
4. **Pointer Setup: Zero page pointers must be initialized before use
5. **PPU Register Access: Must read $2002 before VRAM operations
6. **RAM Clearing: All RAM must be cleared to known state on reset
7. **OAM Buffer: OAM buffer at $0200-$02FF, must be updated via DMA

### Addressing Mode Rules

1. **Zero Page: Use for variables accessed >10 times per frame
2. **Absolute: Use for constants, lookup tables, game state
3. **Indexed: Use for arrays, loops, sequential access
4. **Indirect: Use for function pointers, jump tables
5. **Stack Relative: Not available on 6502 (use absolute addressing)

### Failure Modes

* **Zero Page Overflow: Using too many zero page variables causes conflicts
* **Stack Overflow: Pushing more than 256 bytes wraps stack pointer
* **Uninitialized Pointer: Indirect addressing with uninitialized pointer crashes
* **PPU Register Timing: Accessing PPU registers at wrong time causes corruption
* **RAM Not Cleared: Uninitialized RAM causes unpredictable behavior
* **OAM Corruption: Writing to OAM during rendering causes sprite glitches

## Explicit Non-Goals

This section does not cover:
* Detailed PPU memory layout (see 1.4)
* Cartridge mapper details (see 1.5)
* Timing-critical memory access (see 2.1, 2.3)
* Data-oriented design patterns (see 3.2)
* Memory map cheatsheet (see 4.3)

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.2 (CPU), 1.4 (PPU), 1.5 (ROM)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.2 (Data-Oriented Design)
- Related Cheatsheets: 4.3 (Memory Cheatsheets)
