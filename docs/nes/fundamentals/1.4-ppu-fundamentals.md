# 1.4 PPU Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus (Ricoh 2C02 PPU)

## Physical Hardware Overview

The **Ricoh 2C02 PPU** (Picture Processing Unit) is a separate chip from the CPU, operating at approximately 5.37 MHz (NTSC) or 5.32 MHz (PAL). The PPU has:

* Its own 14-bit address bus (16 KB addressable)
* 2 KB of internal VRAM (Video RAM)
* Separate data bus from CPU
* Hardware sprite evaluation and rendering logic
* Palette RAM (32 bytes)

The CPU communicates with the PPU exclusively through memory-mapped registers at $2000–$2007.

## NES Terminology Definitions

* **Tile: 8×8 pixel pattern, stored as 16 bytes (2 bitplanes × 8 rows)
* **Pattern Table: 256 tiles (4 KB), contains tile graphics data
* **Name Table: 32×30 tile map (960 bytes), defines which tiles appear on screen
* **Attribute Table: 32×30 byte map (64 bytes), defines palette for 2×2 tile groups
* **Sprite: 8×8 or 8×16 pixel object, can appear above or below background
* **OAM: Object Attribute Memory, 256 bytes defining 64 sprites
* **Palette: 4-color set (1 transparent + 3 colors), 8 palettes total (4 background + 4 sprite)
* **VBlank: Period when PPU is not rendering (safe for VRAM access)
* **Scanline: One horizontal line of video output

## Core Rules and Invariants

### Tiles vs Pixels

* NES renders in **tiles** (8×8 pixels), not individual pixels
* Each tile uses 16 bytes: 8 bytes for bitplane 0, 8 bytes for bitplane 1
* Each pixel is 2 bits (4 colors per tile from one palette)
* Background tiles come from pattern tables, mapped via name tables

### Pattern Tables

* Two pattern tables: $0000–$0FFF (table 0) and $1000–$1FFF (table 1)
* Each table contains 256 tiles (8×8 pixels each)
* Pattern tables can be CHR ROM (cartridge) or CHR RAM (writable)
* PPU register $2000 bit 4 selects which pattern table is used for background
* PPU register $2000 bit 3 selects which pattern table is used for sprites

### Name Tables

* Four name tables: $2000, $2400, $2800, $2C00 (each 1 KB)
* Each name table is 32×30 tiles (960 bytes)
* Each byte in name table is a tile index (0–255) into pattern table
* Name tables define the background layer
* PPU register $2000 bits 0–1 select which name table is visible
* Name tables can be mirrored (horizontal, vertical, or 4-screen)

### Attribute Tables

* Each name table has an associated 64-byte attribute table
* Attribute table maps 2×2 tile groups to palettes
* Each attribute byte controls 4×4 tiles (2 bits per 2×2 group)
* Attribute byte layout: `DDCCBBAA` (AA=top-left, BB=top-right, CC=bottom-left, DD=bottom-right)
* Attribute tables are located at $23C0, $27C0, $2BC0, $2FC0 (for each name table)

### Sprites vs Backgrounds

* **Background: Tiles from name tables, rendered first (behind sprites)
* **Sprites: Objects from OAM, rendered after background (can appear in front)
* Sprites can be 8×8 or 8×16 pixels (PPU register $2000 bit 5)
* Maximum 8 sprites per scanline (hardware limit)
* Sprite 0 hit flag ($2002 bit 6) indicates sprite 0 overlaps background
* Sprites can be disabled per-pixel using background priority bit

### OAM (Object Attribute Memory)

* 256 bytes total, defining 64 sprites (4 bytes each)
* Sprite structure:
  - Byte 0: Y position (top of sprite, 0–239 visible)
  - Byte 1: Tile index
  - Byte 2: Attributes (V H P C C C C C)
    - V: Vertical flip
    - H: Horizontal flip
    - P: Priority (0=in front, 1=behind background)
    - C C C C: Palette (0–3)
  - Byte 3: X position (left of sprite, 0–255, wraps)
* OAM is accessed via $2003 (OAM address) and $2004 (OAM data)

## Minimal Correct Usage Example

```asm
; Disable rendering
LDA #0
STA $2000    ; Disable NMI
STA $2001    ; Disable rendering

; Set PPU address to name table
LDA $2002    ; Reset address latch
LDA #$20
STA $2006    ; High byte of PPU address
LDA #$00
STA $2006    ; Low byte of PPU address

; Write to name table
LDX #0
loop:
    LDA name_table_data,X
    STA $2007    ; Write to PPU, auto-increments address
    INX
    CPX #240     ; Write 240 bytes
    BNE loop

; Set PPU address to palette
LDA $2002       ; Reset latch
LDA #$3F
STA $2006
LDA #$00
STA $2006

; Write palette data
LDX #0
palette_loop:
    LDA palette_data,X
    STA $2007
    INX
    CPX #32
    BNE palette_loop

; Enable rendering
LDA #%10010000  ; Enable NMI, pattern table 0 for background
STA $2000
LDA #%00011110  ; Enable background and sprites
STA $2001

name_table_data:
    .byte $00, $01, $02, $03  ; Tile indices
palette_data:
    .byte $0F, $30, $10, $00  ; Background palette 0
    .byte $0F, $30, $10, $00  ; Background palette 1
    .byte $0F, $30, $10, $00  ; Background palette 2
    .byte $0F, $30, $10, $00  ; Background palette 3
    .byte $0F, $16, $27, $18  ; Sprite palette 0
    .byte $0F, $16, $27, $18  ; Sprite palette 1
    .byte $0F, $16, $27, $18  ; Sprite palette 2
    .byte $0F, $16, $27, $18  ; Sprite palette 3
```

## Explicit Non-Goals

## Gold Standard Example

```asm
; Complete PPU usage example following best practices
load_palette:
    ; Reset PPU address latch
    LDA $2002           ; Read PPUSTATUS (clears VBlank flag, resets latch)
    
    ; Set PPU address to palette RAM ($3F00)
    LDA #$3F
    STA $2006           ; PPU address high
    LDA #$00
    STA $2006           ; PPU address low
    
    ; Write all 32 palette bytes
    LDY #0
palette_loop:
    LDA palette_data,Y
    STA $2007           ; Write to PPU data (auto-increments)
    INY
    CPY #32
    BNE palette_loop
    
    ; Set universal background color
    LDA $2002           ; Reset latch
    LDA #$3F
    STA $2006
    LDA #$00
    STA $2006
    LDA #$0F            ; Black background
    STA $2007
    RTS

load_background:
    ; Reset PPU address latch
    LDA $2002
    
    ; Set PPU address to name table ($2000)
    LDA #$20
    STA $2006           ; Name table high byte
    LDA #$00
    STA $2006           ; Name table low byte
    
    ; Clear name table (960 bytes)
    LDX #0
    LDY #0
    LDA #0              ; Tile 0 (empty)
clear_name_table:
    STA $2007           ; Write tile
    INX
    BNE clear_name_table
    INY
    CPY #4              ; 4 iterations = 1024 bytes (covers 960 + 64 attributes)
    BNE clear_name_table
    
    ; Clear attribute table explicitly
    LDA $2002           ; Reset latch
    LDA #$23
    STA $2006           ; Attribute table high byte
    LDA #$C0
    STA $2006           ; Attribute table low byte
    
    LDX #0
    LDA #0              ; Attribute 0 (palette 0)
clear_attr_table:
    STA $2007
    INX
    CPX #64             ; 64 attribute bytes
    BNE clear_attr_table
    
    RTS

update_sprite:
    ; Update sprite in OAM buffer
    ; Input: X = sprite index (0-63), A = Y position, Y = X position
    PHA                 ; Save Y position
    TYA                 ; X position to A
    PHA                 ; Save X position
    
    ; Calculate OAM offset: sprite_index * 4
    TXA
    ASL                 ; Multiply by 2
    ASL                 ; Multiply by 4
    TAY                 ; OAM offset to Y
    
    ; Write sprite data
    PLA                 ; Restore X position
    STA $0203,Y         ; Sprite X position (4th byte)
    PLA                 ; Restore Y position
    STA $0200,Y         ; Sprite Y position (1st byte)
    LDA #0              ; Tile index
    STA $0201,Y         ; Sprite tile (2nd byte)
    LDA #0              ; Attributes
    STA $0202,Y         ; Sprite attributes (3rd byte)
    
    RTS

palette_data:
    .byte $0F, $30, $10, $00  ; Background palette 0
    .byte $0F, $30, $10, $00  ; Background palette 1
    .byte $0F, $30, $10, $00  ; Background palette 2
    .byte $0F, $30, $10, $00  ; Background palette 3
    .byte $0F, $16, $27, $18  ; Sprite palette 0
    .byte $0F, $16, $27, $18  ; Sprite palette 1
    .byte $0F, $16, $27, $18  ; Sprite palette 2
    .byte $0F, $16, $27, $18  ; Sprite palette 3
```

## Validation Rules

### PPU Access Rules

1. **VBlank Access: VRAM writes must occur during VBlank or forced blanking
2. **Latch Reset: Must read $2002 before setting PPU address
3. **Address Sequence: Write high byte, then low byte to $2006
4. **Auto-Increment: $2007 auto-increments address after each read/write
5. **OAM DMA: OAM updates must use DMA ($4014), not individual writes
6. **Scroll Timing: Scroll registers must be written twice per frame
7. **Register Order: PPU registers must be written in correct sequence

### Tile and Sprite Rules

1. **Tile Size: All tiles are 8×8 pixels (16 bytes each)
2. **Pattern Tables: Two pattern tables, 256 tiles each (4 KB total)
3. **Name Table: 32×30 tiles (960 bytes) + 64 bytes attributes
4. **Sprite Limit: Maximum 8 sprites per scanline (hardware limit)
5. **OAM Format: 4 bytes per sprite (Y, Tile, Attributes, X)
6. **Palette Selection: Each tile uses one of 4 background or 4 sprite palettes

### Failure Modes

* **VRAM Access During Rendering: Visual corruption, incorrect tiles
* **Missing Latch Reset: PPU address incorrect, writes to wrong location
* **Wrong Address Sequence: PPU address corrupted, writes fail
* **OAM Writes During Rendering: Sprite glitches, incorrect positions
* **Sprite Overflow: More than 8 sprites per scanline causes flickering
* **Missing Scroll Update: Screen position incorrect, misaligned

## Explicit Non-Goals

This section does not cover:
* VRAM access timing restrictions (see 2.3)
* Rendering architecture patterns (see 3.3)
* Sprite engine implementations (see 5.1)
* Scrolling techniques (see 5.2)
* PPU register details (see 4.2)

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.3 (Memory)
- Related Advanced Fundamentals: 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets)
