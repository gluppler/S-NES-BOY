# 1.4 PPU Fundamentals

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus (Ricoh 2C02 PPU)

## Physical Hardware Overview

The **Ricoh 2C02 PPU** (Picture Processing Unit) is a separate chip from the CPU, operating at approximately 5.37 MHz (NTSC) or 5.32 MHz (PAL). The PPU has:

* Its own 14-bit address bus (16 KB addressable)
* 2 KB of internal VRAM (Video RAM)
* Separate data bus from CPU
* Hardware sprite evaluation and rendering logic
* Palette RAM (32 bytes)

The CPU communicates with the PPU exclusively through memory-mapped registers at $2000–$2007.

**Hardware Schematics**: For detailed circuit diagrams showing PPU connections, pinouts, and video output circuitry, see [`schematics/nes/`](../../../../schematics/nes/README.md).

## PPU Variants and Power-Up State

### Ricoh 2C02 PPU Variants

The NES uses the **Ricoh 2C02** (NTSC) or **Ricoh 2C07** (PAL). Both are functionally identical PPU variants.

| Variant | Region | PPU Clock | Frame Rate | Scanlines |
|---------|--------|-----------|------------|-----------|
| 2C02 | NTSC | 5.369318 MHz | 60.098 Hz | 262 |
| 2C07 | PAL | 5.320545 MHz | 50.007 Hz | 312 |

**Key Differences:**
- Clock speed (NTSC faster)
- Frame rate (60 Hz vs 50 Hz)
- VBlank duration (NTSC: 20 scanlines, PAL: 70 scanlines)
- **Rendering behavior identical** (same tile/sprite system)

### PPU Power-Up State

When the NES is powered on or reset:

| Register/State | Power-Up Value | Guaranteed? | Notes |
|----------------|----------------|-------------|-------|
| $2000 (PPUCTRL) | Undefined | ❌ No | Random value |
| $2001 (PPUMASK) | Undefined | ❌ No | Random value |
| $2002 (PPUSTATUS) | Undefined | ❌ No | VBlank flag may be set |
| $2003 (OAMADDR) | Undefined | ❌ No | Random value |
| $2005 (PPUSCROLL) | Undefined | ❌ No | Random value |
| $2006 (PPUADDR) | Undefined | ❌ No | Random value (address latch) |
| $2007 (PPUDATA) | Undefined | ❌ No | Random value |
| VRAM ($2000–$3EFF) | Undefined | ❌ No | Random values |
| OAM ($0200–$02FF) | Undefined | ❌ No | Random sprite data |
| Palette RAM ($3F00–$3F1F) | Undefined | ❌ No | Random colors |

**Critical**: All PPU state is **undefined** at power-up. Must initialize:
1. Disable rendering ($2001 = $00)
2. Clear VRAM/OAM
3. Set palettes
4. Initialize scroll registers

### PPU Reset Behavior

**Reset Sequence:**
1. All PPU registers become undefined
2. VRAM contents are undefined
3. OAM contains random sprite data
4. Rendering state is undefined
5. **Must wait for PPU to stabilize** (2 VBlank waits recommended)

**PPU Stabilization:**
- PPU requires time to stabilize after power-up/reset
- **Two VBlank waits** ensure PPU is ready
- First VBlank: PPU begins operation
- Second VBlank: PPU is fully stabilized

```asm
; PPU initialization sequence
    LDA #0
    STA $2000    ; Disable NMI
    STA $2001    ; Disable rendering
    
    ; Wait for first VBlank (PPU stabilization)
    BIT $2002    ; Clear VBlank flag
vblank_wait1:
    BIT $2002
    BPL vblank_wait1
    
    ; Clear VRAM, OAM, etc.
    ; ... initialization code ...
    
    ; Wait for second VBlank (ensure PPU is ready)
vblank_wait2:
    BIT $2002
    BPL vblank_wait2
    
    ; Now safe to enable rendering
    LDA #%10000000
    STA $2000    ; Enable NMI
    LDA #%00011110
    STA $2001    ; Enable rendering
```

## NES Terminology Definitions

* **Tile: 8×8 pixel pattern, stored as 16 bytes (2 bitplanes × 8 rows)
* **Pattern Table: 256 tiles (4 KB), contains tile graphics data
* **Name Table: 32×30 tile map (960 bytes), defines which tiles appear on screen
* **Attribute Table: 32×30 byte map (64 bytes), defines palette for 2×2 tile groups
* **Sprite: 8×8 or 8×16 pixel object, can appear above or below background
* **OAM: Object Attribute Memory, 256 bytes defining 64 sprites
* **Palette: 4-color set (1 transparent + 3 colors), 8 palettes total (4 background + 4 sprite)
* **VBlank: Period when PPU is not rendering (safe for VRAM access)
* **Scanline: One horizontal line of video output

## Core Rules and Invariants

### Tiles vs Pixels

* NES renders in **tiles** (8×8 pixels), not individual pixels
* Each tile uses 16 bytes: 8 bytes for bitplane 0, 8 bytes for bitplane 1
* Each pixel is 2 bits (4 colors per tile from one palette)
* Background tiles come from pattern tables, mapped via name tables

### Pattern Tables

* Two pattern tables: $0000–$0FFF (table 0) and $1000–$1FFF (table 1)
* Each table contains 256 tiles (8×8 pixels each)
* Pattern tables can be CHR ROM (cartridge) or CHR RAM (writable)
* PPU register $2000 bit 4 selects which pattern table is used for background
* PPU register $2000 bit 3 selects which pattern table is used for sprites

### Name Tables

* Four name tables: $2000, $2400, $2800, $2C00 (each 1 KB)
* Each name table is 32×30 tiles (960 bytes)
* Each byte in name table is a tile index (0–255) into pattern table
* Name tables define the background layer
* PPU register $2000 bits 0–1 select which name table is visible
* Name tables can be mirrored (horizontal, vertical, or 4-screen)

### Attribute Tables

* Each name table has an associated 64-byte attribute table
* Attribute table maps 2×2 tile groups to palettes
* Each attribute byte controls 4×4 tiles (2 bits per 2×2 group)
* Attribute byte layout: `DDCCBBAA` (AA=top-left, BB=top-right, CC=bottom-left, DD=bottom-right)
* Attribute tables are located at $23C0, $27C0, $2BC0, $2FC0 (for each name table)

### Sprites vs Backgrounds

* **Background: Tiles from name tables, rendered first (behind sprites)
* **Sprites: Objects from OAM, rendered after background (can appear in front)
* Sprites can be 8×8 or 8×16 pixels (PPU register $2000 bit 5)
* Maximum 8 sprites per scanline (hardware limit)
* Sprite 0 hit flag ($2002 bit 6) indicates sprite 0 overlaps background
* Sprites can be disabled per-pixel using background priority bit

### OAM (Object Attribute Memory)

* 256 bytes total, defining 64 sprites (4 bytes each)
* Sprite structure:
  - Byte 0: Y position (top of sprite, 0–239 visible)
  - Byte 1: Tile index
  - Byte 2: Attributes (V H P C C C C C)
    - V: Vertical flip
    - H: Horizontal flip
    - P: Priority (0=in front, 1=behind background)
    - C C C C: Palette (0–3)
  - Byte 3: X position (left of sprite, 0–255, wraps)
* OAM is accessed via $2003 (OAM address) and $2004 (OAM data)

## Minimal Correct Usage Example

```asm
; Disable rendering
LDA #0
STA $2000    ; Disable NMI
STA $2001    ; Disable rendering

; Set PPU address to name table
LDA $2002    ; Reset address latch
LDA #$20
STA $2006    ; High byte of PPU address
LDA #$00
STA $2006    ; Low byte of PPU address

; Write to name table
LDX #0
loop:
    LDA name_table_data,X
    STA $2007    ; Write to PPU, auto-increments address
    INX
    CPX #240     ; Write 240 bytes
    BNE loop

; Set PPU address to palette
LDA $2002       ; Reset latch
LDA #$3F
STA $2006
LDA #$00
STA $2006

; Write palette data
LDX #0
palette_loop:
    LDA palette_data,X
    STA $2007
    INX
    CPX #32
    BNE palette_loop

; Enable rendering
LDA #%10010000  ; Enable NMI, pattern table 0 for background
STA $2000
LDA #%00011110  ; Enable background and sprites
STA $2001

name_table_data:
    .byte $00, $01, $02, $03  ; Tile indices
palette_data:
    .byte $0F, $30, $10, $00  ; Background palette 0
    .byte $0F, $30, $10, $00  ; Background palette 1
    .byte $0F, $30, $10, $00  ; Background palette 2
    .byte $0F, $30, $10, $00  ; Background palette 3
    .byte $0F, $16, $27, $18  ; Sprite palette 0
    .byte $0F, $16, $27, $18  ; Sprite palette 1
    .byte $0F, $16, $27, $18  ; Sprite palette 2
    .byte $0F, $16, $27, $18  ; Sprite palette 3
```

## Explicit Non-Goals

## Gold Standard Example

```asm
; Complete PPU usage example following best practices
load_palette:
    ; Reset PPU address latch
    LDA $2002           ; Read PPUSTATUS (clears VBlank flag, resets latch)
    
    ; Set PPU address to palette RAM ($3F00)
    LDA #$3F
    STA $2006           ; PPU address high
    LDA #$00
    STA $2006           ; PPU address low
    
    ; Write all 32 palette bytes
    LDY #0
palette_loop:
    LDA palette_data,Y
    STA $2007           ; Write to PPU data (auto-increments)
    INY
    CPY #32
    BNE palette_loop
    
    ; Set universal background color
    LDA $2002           ; Reset latch
    LDA #$3F
    STA $2006
    LDA #$00
    STA $2006
    LDA #$0F            ; Black background
    STA $2007
    RTS

load_background:
    ; Reset PPU address latch
    LDA $2002
    
    ; Set PPU address to name table ($2000)
    LDA #$20
    STA $2006           ; Name table high byte
    LDA #$00
    STA $2006           ; Name table low byte
    
    ; Clear name table (960 bytes)
    LDX #0
    LDY #0
    LDA #0              ; Tile 0 (empty)
clear_name_table:
    STA $2007           ; Write tile
    INX
    BNE clear_name_table
    INY
    CPY #4              ; 4 iterations = 1024 bytes (covers 960 + 64 attributes)
    BNE clear_name_table
    
    ; Clear attribute table explicitly
    LDA $2002           ; Reset latch
    LDA #$23
    STA $2006           ; Attribute table high byte
    LDA #$C0
    STA $2006           ; Attribute table low byte
    
    LDX #0
    LDA #0              ; Attribute 0 (palette 0)
clear_attr_table:
    STA $2007
    INX
    CPX #64             ; 64 attribute bytes
    BNE clear_attr_table
    
    RTS

update_sprite:
    ; Update sprite in OAM buffer
    ; Input: X = sprite index (0-63), A = Y position, Y = X position
    PHA                 ; Save Y position
    TYA                 ; X position to A
    PHA                 ; Save X position
    
    ; Calculate OAM offset: sprite_index * 4
    TXA
    ASL                 ; Multiply by 2
    ASL                 ; Multiply by 4
    TAY                 ; OAM offset to Y
    
    ; Write sprite data
    PLA                 ; Restore X position
    STA $0203,Y         ; Sprite X position (4th byte)
    PLA                 ; Restore Y position
    STA $0200,Y         ; Sprite Y position (1st byte)
    LDA #0              ; Tile index
    STA $0201,Y         ; Sprite tile (2nd byte)
    LDA #0              ; Attributes
    STA $0202,Y         ; Sprite attributes (3rd byte)
    
    RTS

palette_data:
    .byte $0F, $30, $10, $00  ; Background palette 0
    .byte $0F, $30, $10, $00  ; Background palette 1
    .byte $0F, $30, $10, $00  ; Background palette 2
    .byte $0F, $30, $10, $00  ; Background palette 3
    .byte $0F, $16, $27, $18  ; Sprite palette 0
    .byte $0F, $16, $27, $18  ; Sprite palette 1
    .byte $0F, $16, $27, $18  ; Sprite palette 2
    .byte $0F, $16, $27, $18  ; Sprite palette 3
```

## Validation Rules

### PPU Access Rules

1. **VBlank Access: VRAM writes must occur during VBlank or forced blanking
2. **Latch Reset: Must read $2002 before setting PPU address
3. **Address Sequence: Write high byte, then low byte to $2006
4. **Auto-Increment: $2007 auto-increments address after each read/write
5. **OAM DMA: OAM updates must use DMA ($4014), not individual writes
6. **Scroll Timing: Scroll registers must be written twice per frame
7. **Register Order: PPU registers must be written in correct sequence

### Tile and Sprite Rules

1. **Tile Size: All tiles are 8×8 pixels (16 bytes each)
2. **Pattern Tables: Two pattern tables, 256 tiles each (4 KB total)
3. **Name Table: 32×30 tiles (960 bytes) + 64 bytes attributes
4. **Sprite Limit: Maximum 8 sprites per scanline (hardware limit)
5. **OAM Format: 4 bytes per sprite (Y, Tile, Attributes, X)
6. **Palette Selection: Each tile uses one of 4 background or 4 sprite palettes

### Failure Modes

* **VRAM Access During Rendering: Visual corruption, incorrect tiles
* **Missing Latch Reset: PPU address incorrect, writes to wrong location
* **Wrong Address Sequence: PPU address corrupted, writes fail
* **OAM Writes During Rendering: Sprite glitches, incorrect positions
* **Sprite Overflow: More than 8 sprites per scanline causes flickering
* **Missing Scroll Update: Screen position incorrect, misaligned

## PPU Rendering Pipeline

### Rendering Phases

The PPU renders frames in distinct phases:

| Phase | Scanlines | PPU Activity | CPU Access |
|-------|-----------|--------------|------------|
| Visible rendering | 0-239 | Rendering tiles/sprites | ❌ VRAM unsafe |
| Post-render | 240 | Idle | ⚠️ Risky (short window) |
| VBlank | 241-260 (NTSC) / 241-310 (PAL) | Idle | ✅ VRAM safe |
| Pre-render | 261 (NTSC) / 311 (PAL) | Preparing next frame | ⚠️ Risky |

### Sprite Evaluation Process

**Sprite Evaluation Timing:**
- Occurs during visible rendering (scanlines 0-239)
- PPU scans OAM for sprites on current scanline
- Maximum 8 sprites per scanline (hardware limit)
- Sprite overflow flag ($2002 bit 5) is unreliable

**Sprite Evaluation Window:**
- Cycles 64-256 of each visible scanline
- **Reading $2002 during this window corrupts OAM**
- Must avoid $2002 reads during sprite evaluation

### Rendering Pipeline Steps

**Per Scanline (Visible Rendering):**
1. **Sprite Evaluation** (cycles 0-64): PPU scans OAM for sprites
2. **Background Fetch** (cycles 0-256): PPU fetches tile data
3. **Sprite Fetch** (cycles 256-320): PPU fetches sprite data
4. **Rendering** (cycles 0-256): PPU outputs pixels to TV
5. **HBlank** (cycles 256-341): PPU idle, preparing next scanline

**VBlank Period:**
- PPU is idle (not rendering)
- Safe for VRAM access
- CPU can update name tables, palettes, OAM

## Hardware Quirks and Undefined Behavior

### PPU Register Read Behavior

| Register | Read Behavior | Notes |
|----------|---------------|-------|
| $2002 (PPUSTATUS) | Clears VBlank flag, resets address latch | Must read before $2006 writes |
| $2004 (OAMDATA) | Returns OAM byte at current address | OAM address increments |
| $2007 (PPUDATA) | First read is buffered (invalid) | Subsequent reads return actual data |

### VRAM Access Restrictions

| Period | VRAM Access | Result |
|--------|-------------|--------|
| Visible rendering (0-239) | ❌ Write | Visual corruption |
| Visible rendering (0-239) | ⚠️ Read | May return incorrect data |
| VBlank (241-260/310) | ✅ Write | Safe |
| VBlank (241-260/310) | ✅ Read | Safe |
| Forced blanking | ✅ Write | Safe (rendering disabled) |

### Sprite Evaluation Corruption

**Critical Bug**: Reading $2002 during sprite evaluation (cycles 64-256 of scanlines 0-239) **corrupts OAM**.

**Safe Periods for $2002 Reads:**
- VBlank (scanlines 241-260/310)
- Pre-render (scanline 261/311)
- Early in visible scanlines (cycles 0-63)

**Best Practice**: Only read $2002 during VBlank or when rendering is disabled.

### Emulator vs Hardware Divergence

| Behavior | Emulator | Hardware | Notes |
|----------|----------|----------|-------|
| VRAM write during rendering | May allow | Causes corruption | Emulators may be lenient |
| OAM corruption window | May not enforce | Strict timing | Emulators may not simulate |
| Sprite overflow flag | May be accurate | Unreliable | Hardware flag is buggy |
| Palette mid-frame changes | May work | Risky | Hardware may glitch |

**Best Practice**: Test on real hardware. Emulators cannot perfectly simulate all PPU quirks.

## Explicit Non-Goals

This section does not cover:
* VRAM access timing restrictions (see 2.3)
* Rendering architecture patterns (see 3.3)
* Sprite engine implementations (see 5.1)
* Scrolling techniques (see 5.2)
* PPU register details (see 4.2)

## Cross-References

- Related Fundamentals: 1.1 (System Overview), 1.3 (Memory)
- Related Advanced Fundamentals: 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets)
