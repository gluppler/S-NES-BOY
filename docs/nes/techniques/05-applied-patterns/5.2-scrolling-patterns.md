# 5.2 Scrolling Patterns

## System Applicability

**This document applies to:**
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same PPU scrolling system)


## Horizontal Scrolling

**Pattern: Update scroll X register ($2005) each frame based on camera position. Load new tiles when scrolling reveals new columns.

**Implementation:
```asm
; Horizontal scroll variables
scroll_x = $01        ; Zero page: fine scroll (0-7)
scroll_coarse_x = $02 ; Zero page: coarse scroll (tile column, 0-31)
camera_x = $03        ; Zero page: camera position (pixels)

; Update horizontal scroll
update_horizontal_scroll:
    ; Increment camera
    INC camera_x
    
    ; Calculate fine scroll (pixels within tile)
    LDA camera_x
    AND #$07          ; Fine scroll (0-7)
    STA scroll_x
    
    ; Calculate coarse scroll (tile column)
    LDA camera_x
    LSR A
    LSR A
    LSR A             ; Divide by 8
    AND #$1F          ; Wrap at 32 tiles
    STA scroll_coarse_x
    
    ; Update PPU scroll (in NMI)
    LDA scroll_x
    STA scroll_x_nmi
    LDA scroll_coarse_x
    STA scroll_coarse_x_nmi
    
    ; Check if we need to load new column
    LDA camera_x
    AND #$07          ; Fine scroll
    BNE no_new_column ; Not at tile boundary
    
    ; Load new column (right edge)
    JSR load_column_right
    
no_new_column:
    RTS

; Load column at right edge of screen
load_column_right:
    ; Calculate which column to load
    LDA scroll_coarse_x
    CLC
    ADC #32           ; Right edge column (32 tiles wide screen)
    AND #$1F          ; Wrap at 32 tiles
    TAX
    
    ; Set PPU address to right column
    LDA $2002         ; Reset latch
    LDA #$20          ; Name table 0
    STA $2006
    TXA
    ASL A             ; Column * 2 (each column is 2 name tables wide)
    STA $2006
    
    ; Write column tiles (30 rows)
    LDY #0
column_loop:
    LDA level_data,X  ; Get tile from level data
    STA $2007
    INX
    INY
    CPY #30           ; 30 rows
    BNE column_loop
    
    RTS
```

## Vertical Scrolling

**Pattern: Update scroll Y register ($2005) each frame based on camera position. Load new tiles when scrolling reveals new rows.

**Implementation:
```asm
; Vertical scroll variables
scroll_y = $04        ; Zero page: fine scroll (0-7)
scroll_coarse_y = $05 ; Zero page: coarse scroll (tile row, 0-29)
camera_y = $06        ; Zero page: camera position (pixels)

; Update vertical scroll
update_vertical_scroll:
    ; Increment camera
    INC camera_y
    
    ; Calculate fine scroll
    LDA camera_y
    AND #$07          ; Fine scroll (0-7)
    STA scroll_y
    
    ; Calculate coarse scroll
    LDA camera_y
    LSR A
    LSR A
    LSR A             ; Divide by 8
    AND #$1D          ; Wrap at 30 tiles (29 + 1)
    STA scroll_coarse_y
    
    ; Update PPU scroll (in NMI)
    LDA scroll_y
    STA scroll_y_nmi
    LDA scroll_coarse_y
    STA scroll_coarse_y_nmi
    
    ; Check if we need to load new row
    LDA camera_y
    AND #$07          ; Fine scroll
    BNE no_new_row    ; Not at tile boundary
    
    ; Load new row (bottom edge)
    JSR load_row_bottom
    
no_new_row:
    RTS

; Load row at bottom edge of screen
load_row_bottom:
    ; Calculate which row to load
    LDA scroll_coarse_y
    CLC
    ADC #30           ; Bottom edge row (30 tiles tall screen)
    AND #$1D          ; Wrap at 30 tiles
    TAX
    
    ; Set PPU address to bottom row
    LDA $2002         ; Reset latch
    LDA #$20          ; Name table 0
    STA $2006
    TXA
    ASL A
    ASL A
    ASL A
    ASL A
    ASL A             ; Row * 32 (32 tiles per row)
    STA $2006
    
    ; Write row tiles (32 columns)
    LDY #0
row_loop:
    LDA level_data,X  ; Get tile from level data
    STA $2007
    INX
    INY
    CPY #32           ; 32 columns
    BNE row_loop
    
    RTS
```

## Four-Way Scrolling Constraints

**Pattern: Handle scrolling in both X and Y directions simultaneously. Must manage name table boundaries and coordinate tile loading.

**Constraints:
* **Name table size: 32×30 tiles per name table
* **Scroll range: 0–255 pixels (fine) + 0–31/29 tiles (coarse)
* **Name table switching: Must update $2000 bits 0–1 when crossing boundaries
* **Tile loading: Must load tiles in both X and Y directions

**Implementation:
```asm
; Four-way scroll variables
scroll_x = $01
scroll_y = $04
name_table = $07      ; Zero page: current name table (0-3)

; Update four-way scroll
update_four_way_scroll:
    ; Update horizontal
    JSR update_horizontal_scroll
    
    ; Update vertical
    JSR update_vertical_scroll
    
    ; Check name table boundaries
    LDA scroll_coarse_x
    CMP #32
    BCC check_y_boundary
    
    ; Crossed X boundary, switch name table
    LDA name_table
    EOR #$01          ; Toggle bit 0 (horizontal)
    STA name_table
    
    ; Reset coarse X
    LDA #0
    STA scroll_coarse_x
    
check_y_boundary:
    LDA scroll_coarse_y
    CMP #30
    BCC update_ppu_ctrl
    
    ; Crossed Y boundary, switch name table
    LDA name_table
    EOR #$02          ; Toggle bit 1 (vertical)
    STA name_table
    
    ; Reset coarse Y
    LDA #0
    STA scroll_coarse_y
    
update_ppu_ctrl:
    ; Update PPU control with new name table
    LDA ppu_ctrl_base
    ORA name_table
    STA ppu_ctrl
    
    RTS

; Load tiles for four-way scrolling
load_scroll_tiles:
    ; Check if we need to load right column
    LDA camera_x
    AND #$07
    BNE check_bottom_row
    JSR load_column_right
    
check_bottom_row:
    ; Check if we need to load bottom row
    LDA camera_y
    AND #$07
    BNE load_done
    JSR load_row_bottom
    
load_done:
    RTS
```

## Cross-References

- Related Fundamentals: 1.4 (PPU Fundamentals)
- Related Advanced Fundamentals: 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.3 (Rendering Architecture), 3.5 (Map & Level Systems)
- Related Cheatsheets: 4.2 (PPU Cheatsheets), 4.4 (Timing Cheatsheets)
