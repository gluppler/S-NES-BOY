# 2.3 PPU Rendering Rules

## System Applicability

**This document applies to:**
- ✅ **: Fully compatible (same Ricoh 2C02 PPU)


## Hardware Behavior

The PPU renders 240 visible scanlines (0–239) plus 22 overhead scanlines (240–261 NTSC). During visible rendering, the PPU:
* Reads name table data to determine background tiles
* Reads pattern table data to fetch tile graphics
* Reads attribute table data to determine palettes
* Evaluates sprites (up to 8 per scanline)
* Generates pixel data and outputs to TV

The PPU has **strict timing requirements** for VRAM access. Writing to VRAM during rendering causes visual corruption because the PPU is actively reading from VRAM.

## Why This Behavior Exists

The PPU operates independently from the CPU on a separate bus. During rendering, the PPU continuously reads from VRAM to fetch tile and sprite data. If the CPU writes to VRAM simultaneously, the PPU may read corrupted or partially-written data, causing visual glitches.

The PPU's internal address latch ($2006) and data register ($2007) have specific write sequences that must be followed exactly.

## Exact Rules and Constraints

### VRAM Access Restrictions

* **During rendering (scanlines 0–239): VRAM writes cause corruption
* **During VBlank (scanlines 241–260 NTSC): VRAM writes are safe
* **During forced blanking: VRAM writes are safe (rendering disabled via $2001)

### $2006/$2007 Write Rules

**Setting PPU Address ($2006):
1. First write: High byte of address (bits 14–8)
2. Second write: Low byte of address (bits 7–0)
3. Address latch is reset after reading $2002
4. Address auto-increments by 1 or 32 after $2007 read/write (controlled by $2000 bit 2)

**Reading/Writing PPU Data ($2007):
1. First read after $2006 write returns **buffered data** (invalid)
2. Subsequent reads return actual PPU data
3. Writes go directly to PPU (no buffering)
4. Address increments automatically (by 1 or 32, depending on $2000 bit 2)

### Scroll Latch Behavior

**Scroll Register ($2005):
* First write: Fine X scroll (0–7) + coarse X scroll (0–31)
* Second write: Fine Y scroll (0–7) + coarse Y scroll (0–29)
* Scroll latch is reset after reading $2002
* Must be written **twice per frame** (in NMI) to maintain scroll position

**Name Table Select ($2006):
* Bits 0–1 of $2000 select which name table is visible
* Writing to $2006 also sets name table (bits 10–11 of address)
* Scroll and name table must be synchronized

### Sprite Evaluation Quirks

* **Sprite 0 Hit: Flag ($2002 bit 6) is set when sprite 0 pixel overlaps background pixel
* **8 Sprite Limit: Maximum 8 sprites per scanline (hardware limit)
* **Sprite Overflow: Flag ($2002 bit 5) is set when >8 sprites on a scanline (unreliable)
* **OAM Corruption: Reading $2002 during rendering can corrupt OAM (sprite evaluation period)

### Safe VRAM Write Windows

* **VBlank: Scanlines 241–260 (NTSC), 241–310 (PAL) — **primary window
* **Forced Blanking: When $2001 bit 3 = 0 (rendering disabled) — **always safe
* **Pre-render: Scanline 261 (NTSC) — **sometimes safe, not recommended

## Timing Considerations

### VRAM Write Timing

* **$2006 write: 2 cycles per byte (high, then low)
* **$2007 write: 2 cycles per byte
* **Bulk writes: ~2 cycles per byte (limited by VBlank duration)
* **Maximum bytes per VBlank: ~1,135 bytes (NTSC, theoretical)

### Sprite DMA Timing

* **OAM DMA ($4014): Exactly 513 cycles
* **Must complete during VBlank: DMA blocks CPU during transfer
* **Manual OAM writes: 2 cycles per byte via $2003/$2004

## Common Mistakes and Incorrect Assumptions

* **Writing to VRAM during rendering: Causes tile corruption, sprite glitches
* **Not reading $2002 before $2006: Address latch may be in wrong state
* **Using first $2007 read: First read is buffered, invalid data
* **Forgetting to update scroll: Scroll must be written twice per frame
* **Reading $2002 during rendering: Can corrupt OAM (sprite evaluation)
* **Assuming all emulators enforce VRAM restrictions: Some are lenient

## Observable Symptoms When Rules Are Violated

* **Tile corruption: Background tiles show wrong patterns
* **Sprite glitches: Sprites appear/disappear randomly
* **Palette corruption: Wrong colors appear on screen
* **Scroll jitter: Background scroll position jumps
* **Sprite 0 hit false positives: Flag triggers incorrectly
* **OAM corruption: Sprites have wrong positions/attributes

## Minimal Example

```asm
; Safe VRAM update during VBlank
update_vram:
    LDA $2002       ; Reset address latch (MUST read first)
    
    ; Update name table
    LDA #$20        ; Name table 0, high byte
    STA $2006
    LDA #$00        ; Name table 0, low byte
    STA $2006
    
    LDX #0
name_loop:
    LDA name_data,X
    STA $2007       ; Write to PPU (auto-increments)
    INX
    CPX #240
    BNE name_loop
    
    ; Update palette
    LDA $2002       ; Reset latch again
    LDA #$3F
    STA $2006       ; Palette address high
    LDA #$00
    STA $2006       ; Palette address low
    
    LDX #0
palette_loop:
    LDA palette_data,X
    STA $2007
    INX
    CPX #32
    BNE palette_loop
    
    ; Update scroll (must be done every frame)
    LDA scroll_x
    STA $2005       ; X scroll
    LDA scroll_y
    STA $2005       ; Y scroll
    
    RTS

; UNSAFE: Writing during rendering (DO NOT DO THIS)
unsafe_update:
    LDA #$20
    STA $2006       ; Writing during scanline 100 = CORRUPTION
    LDA #$00
    STA $2006
    LDA #$42
    STA $2007       ; This will corrupt the display
    RTS
```

## Cross-References

- Related Fundamentals: 1.4 (PPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.2 (NMI & VBlank Discipline)
- Related Core Concepts: 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets), 4.4 (Timing Cheatsheets)
