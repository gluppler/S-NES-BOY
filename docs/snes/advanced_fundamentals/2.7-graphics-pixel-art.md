# 2.7 Graphics & Pixel Art

## System Applicability

**This document applies to:**
- ✅ **SNES: Primary focus

## Overview of PPU Concepts

### Super PPU


### VRAM (Video RAM)

**VRAM** is RAM used by the Super PPU to hold tiles.

* **Size**: 64 KB total
* **Tile Sizes**: Each screen mode uses different tile sizes
  - Usually 8×8 pixels or 16×16 pixels per tile
  - Tile size depends on the selected video mode

### OAM (Object Attribute Memory)

**OAM** holds sprite definition data and can hold data for up to a maximum of 128 sprites.


#### OAM Data for Each Sprite

* **X Position**: 9-bit value (0-511 or $00-$1FF)
* **Y Position**: 8-bit value (0-239 or $00-$EF)
  - Values 0-239 are on-screen
  - Values -63 through -1 are "off the top", so the bottom part of the sprite comes in at the top of the screen
  - Note: This implies a really big sprite can go off the bottom and come back in at the top
* **First Tile ID**: 8-bit index
* **Nametable**: Sprite nametable reference
* **Palette ID**: 0-7 ($00-$07)
  - Recall: Sprites use subpalette indices in latter 8 sub palettes, so ID used is 7+N
* **Sprite Size**: 1-bit
  - 0 = smaller sprite size available for mode (usually 1 tile of 16×16px)
  - 1 = larger sprite size available for mode (usually 4 tiles: 2×2 16×16px tiles)
* **Sprite Priority**: 2-bit
  - OAM priority: These bits determine sprite's priority with respect to background planes
  - Priority with respect to other sprites:
    - 0th sprite in OAM has the highest priority
    - 1st sprite in OAM has a lower priority
    - 2nd sprite in OAM has even lower priority, etc.

## Machine Types

### NTSC Machines

* North America
* Certain countries in South America
* The Philippines, Myanmar, Taiwan, South Korea, and Japan


**Note**: Mega Cat games are NTSC releases, so use these resolutions!

### PAL Machines

**"Super Famicom (SFC)"**, 50Hz machines, covers:
* Most of Western Europe
* China, India, Australia
* Most of Africa, and elsewhere

**Screen Resolution**: 256×240 px (just like PAL Famicom)

## Tilemaps


* Named **Mode 0-7**
* Mode 1 has a variation mode
* Mode 7 has a submode called Mode 7 Ext. BG
* Each mode has a different amount of background planes available
* Each mode has a different amount of colors for the available background planes for that mode
* Each mode has slightly different rendering properties
* **For all modes and for all graphics planes, color index 0 for any subpalette is the transparency color**

### Graphics Planes


### Tilemap Sizes

The tilemap sizes of the scroll planes can be either:
* 32×32 tiles
* 32×64 tiles
* 64×32 tiles
* 64×64 tiles

Depending on the size of each block in the tilemap:
* Blocks of 16×16 px (1 tile), or
* Blocks of 32×32 px (2×2 tiles)

The tilemap size can range from **256×256 px to 1024×1024 px**.

### Properties of Each Tile in a Tilemap

* **V/H Flip**: Vertical/Horizontal flip of tile
* **Tile Priority**: Low/high priority
* **Palette Number**: 3-bit (0-7/$00-$07)
  - Recall: Planes use the 1st 8 sub palettes of CGRAM; the 2nd 8 is used for sprites (OAM)
* **Tile ID**: Tile index reference

## Video Modes

### Mode 0

* **4 BGs** each with **4 colors**
* **BG Priority** (from front to back): BG4, BG3, BG2, BG1

### Mode 1

* **2 BGs** of **16 colors**
* **1 BG** of **4 colors**
* **BG Priority** (front to back): Varies depending upon the setting of bit 3 of $2105

### Mode 2

* **2 BGs** with **16 colors** each
* **BG Priority** (front to back): BG2, BG1
* **1st "offset-per-tile" mode** (read Mode 2 documentation for more info)

### Mode 3

* **1 BG** with **256 colors**
* **1 BG** with **16 colors**
* **BG Priority** (from front to back): BG2, BG1
* **Direct Color Mode** available (register $2130)

### Mode 4

* **1 BG** with **256 Colors**
* **1 BG** with **4 colors**
* **BG Priority** (from front to back): BG2, BG1
* **2nd "offset-per-tile" mode** (read Mode 4 documentation for more info)

### Mode 5

* **1 BG** with **16 colors**
* **1 BG** with **4 colors**
* **BG Priority** (from front to back): BG2, BG1
* **Special Properties**: Mode 5 is rather different from the previous modes
  - Instead of using an 8/16 pixel wide tile as normal, it always takes a 16-pixel wide tile (the height may still be 8 or 16)
  - Only uses half the pixels (zero-based, the even pixels for subscreen tiles and the odd pixels for main screen tiles)
  - Forces pseudo-hires on to render a 512-pixel wide scanline
  - If Interlace mode is on (see bit 0 of $2133), the screen is 448 or 478 half-lines high instead of 224 or 239
  - Either the odd half-lines or the even half-lines are drawn each frame, as indicated by bit 7 of $213f
  - **Note**: You must set $212c and $212d to the same value to get the 'expected' display

### Mode 6

* **1 BG** with **16 colors**
* **BG Priority** (from front to back): BG1
* **Special Properties**:
  - Has same oddities as Mode 5
  - Is also an offset-per-tile mode (like Mode 2)
  - However, remember that Mode 6 always uses 8 pixels (16 half-pixel) wide tiles, this applies to BG3 as well as BG1
  - You can't apply the offset to an 8-half-pixel tile nor to a 16-pixel wide-area (except by using two offset values for the two 8-pixel areas)

### Mode 7

* **1 BG** of **256 colors**
* **Very special mode**: Allows for matrix transformations of BG layer
* Used for the pseudo-3D effects in games such as Super Mario Kart, F-Zero, etc.
* Read Mode 7 documentation for full details

## CGRAM (Color Graphics RAM)

**CGRAM** holds color information for palettes.

* **Total Capacity**: 256 ($FF) color palette entries
* **Subpalette Division**: Each graphics mode divides the 256 palette entries into sub palettes, each with N colors
  - "N" depends on the video mode
  - By default, each subpalette is 16 color entries (256 colors ÷ 16 colors per subpalette = 16 subpalettes)
* **Subpalette Allocation**:
  - **First 8 subpalettes** (subpalette IDs 0-7/$00-$07, palette entry IDs 0-63/$00-$3F): Used for background tiles
  - **Last 8 subpalettes** (subpalette IDs 8-15/$08-$0F, palette entry IDs 64-127/$40-$7F): Used for sprite objects
* **Transparency**: First color entry in a subpalette will be rendered transparent for tiles/sprite tiles that use the subpalette

### 15-bit BGR Color Format

Each color entry in CGRAM is in the format of **2 bytes (a "word")** of format:

```
0BBBBBGG GGGRRRRR
```

Where:
* **B** = Blue bits (5 bits)
* **G** = Green bits (5 bits)
* **R** = Red bits (5 bits)
* **16-bit total**, 1st bit is unused, so **15-bit color range**
* Each color component (B, G, R) ranges from values of **0-31** (decimal) or **$00-$1F** (hexadecimal)

This provides **32,768 total colors** (2^15) in the color space.

## Hardware Constraints

### Tile-Based Graphics

* **Tile Size**: 8×8 pixels or 16×16 pixels (depending on mode)
* **VRAM**: 64 KB total for all tiles
* **Tile Limits**: Varies by mode and VRAM usage

### Color Constraints

* **Color Depth**: 2, 4, or 8 bits per pixel (depending on mode)
* **Palette System**: 256 colors from 15-bit palette (32,768 total colors)
* **Subpalettes**: 16 colors per subpalette (default)
* **Background Palettes**: First 8 subpalettes (128 colors)
* **Sprite Palettes**: Last 8 subpalettes (128 colors)

### Sprite Constraints

* **Sprite Limit**: 128 sprites per frame, 32 per scanline
* **Sprite Size**: 8×8 to 64×64 pixels (in 8×8 increments)
* **Sprite Priority**: Determined by OAM order and priority bits

### Layer Constraints

* **Background Layers**: Up to 4 background layers (BG1-BG4)
* **Sprite Layer**: 1 sprite layer
* **Layer Priority**: Configurable per mode

## Core Principles

### 1. Tile-Based Thinking

**Rule**: All graphics must fit within tile boundaries (8×8 or 16×16 pixels depending on mode).

* **Background Art**: Composed of tiles arranged in tilemaps
* **Sprites**: Individual tiles or multi-tile sprites
* **Reusability**: Design tiles to be reused across the game
* **VRAM Management**: Plan tile usage carefully within 64 KB VRAM limit

### 2. Color Palette Constraints

* 256-color palettes from 15-bit color space (32,768 total colors)
* Each sprite can use 16 colors from a 256-color palette
* Background layers can use 4, 16, or 256 colors depending on mode
* Color index 0 is always transparent

**Technique**: Design with palette limitations in mind. Use color strategically to maximize visual impact within constraints.

### 3. Mode Selection

Choose the appropriate video mode based on your needs:

* **Mode 0**: Maximum layers (4 BGs), minimal colors (4 per BG)
* **Mode 1**: Balanced (2 BGs with 16 colors, 1 BG with 4 colors)
* **Mode 2**: Offset-per-tile mode with 2 BGs, 16 colors each
* **Mode 3**: High color background (256 colors) + 16-color BG
* **Mode 4**: High color background (256 colors) + 4-color BG, offset-per-tile
* **Mode 5**: High resolution mode (512 pixels wide)
* **Mode 6**: High resolution + offset-per-tile
* **Mode 7**: 3D effects, rotation/scaling

### 4. Pixel Art Techniques

#### Clean Shapes

* Use clear, readable forms
* Every pixel matters; avoid unnecessary detail
* Maximize visual impact with minimal colors

#### Color Economy

* Use subpalettes efficiently
* Share colors between tiles when possible
* Plan palette usage across layers

#### Readability

* Characters and objects must be recognizable at small sizes
* Consider sprite size limitations (8×8 to 64×64)
* Test on actual hardware or accurate emulator

### 5. Sprite Design

#### Single-Tile Sprites (8×8)

* **Use Case**: Small objects, particles, UI elements
* **Limitation**: Very limited detail
* **Technique**: Focus on silhouette and key features

#### Multi-Tile Sprites

* **2×2 (16×16)**: Common for characters, medium objects
* **4×4 (32×32)**: Larger characters, bosses
* **Up to 8×8 (64×64)**: Very large sprites
* **Technique**: Design as complete image, then split into tiles

#### Sprite Priority

* **OAM Order**: Lower indices render on top
* **Background Priority**: Sprites can appear behind background tiles
* **Priority Bits**: 2-bit priority value affects rendering order
* **Technique**: Order sprites by depth (background → foreground)

### 6. Background Art

#### Tile Reuse

* **Metatiles**: Groups of tiles that form reusable patterns
* **Compression**: Store metatiles instead of individual tiles
* **Technique**: Design level with reusable tile combinations

#### Tilemap Organization

* **Tilemap Sizes**: 32×32, 32×64, 64×32, or 64×64 tiles
* **Block Sizes**: 16×16 px (1 tile) or 32×32 px (2×2 tiles)
* **Total Size**: 256×256 px to 1024×1024 px

#### Scrolling Considerations

* **Tile Alignment**: Tiles must align to tile grid
* **Scroll Granularity**: Fine scroll + coarse scroll (tiles)
* **Technique**: Design tiles to tile seamlessly horizontally and vertically

### 7. Animation Techniques

#### Frame-Based Animation

* **Sprite Animation**: Cycle through tile indices
* **Frame Tables**: Lookup tables mapping frame → tile indices
* **Timing**: Update frames at consistent intervals

#### Tile Animation

* **Technique**: Swap tiles in VRAM during VBlank
* **Use Case**: Animated backgrounds, water, fire
* **Constraint**: Must update during VBlank to avoid corruption

#### Palette Cycling

* **Technique**: Rotate palette colors to create animation effect
* **Use Case**: Pulsing effects, rainbow effects, status indicators
* **Implementation**: Update CGRAM during VBlank



* **32,768 Total Colors**: 15-bit color space
* **256 Colors Available**: From CGRAM at any time
* **Subpalette System**: 16 colors per subpalette
* **Transparency**: Color index 0 is always transparent

#### Effective Color Use

* **Contrast**: Use high contrast for readability
* **Hue Separation**: Use distinct hues for different objects
* **Subpalette Planning**: Group related tiles in same subpalette

#### Palette Optimization

* **Shared Colors**: Use color index 0 for common elements (transparency)
* **Subpalette Grouping**: Group related tiles in same subpalette
* **Technique**: Analyze tile usage to optimize palette assignments

## Recommended Debugging and Art Tools


### Art Software

#### YY-CHR

* **Multi-platform tile editor**
* **Newer C# version**: Available
* **Old C++ version**: Available
* **Use Case**: Tile editing, palette management, CHR ROM editing

#### Irfanview

* **Generic image viewer/editor** with plugins and very large support for many image file types
* **Features**:
  - Can edit, export, and import palettes
  - Can increase/decrease the color count of images
  - Can view color count
  - FOSS software
  - Has PNG plugin to change color depth while preserving palette order
* **Info**: Homepage website

### Recommended Specialty Emulators for Super PPU Debugging

#### No$sns

* **Features**:
  - Can view machine/CPU state
  - Can view BG layers on-the-fly
  - Can view OAM on-the-fly
  - Can view VRAM tile contents in various color modes
  - Can view CGRAM contents
* **Use Case**: PPU debugging, sprite debugging, palette debugging

#### Higan

* **Emulator emulating various retro consoles**
* **Features**:
* **Use Case**: Accurate hardware testing, cycle-accurate debugging

## Best Practices

### Design Principles

1. **Start Simple**: Begin with basic shapes, add detail gradually
2. **Test Early**: View graphics on actual hardware or accurate emulator
3. **Iterate**: Refine based on hardware appearance
4. **Consistency**: Maintain consistent style and palette usage
5. **Readability**: Prioritize clarity over detail

### Technical Practices

1. **VBlank Updates**: Only update graphics during VBlank
2. **Tile Organization**: Plan tile layout before implementation
3. **Palette Planning**: Design with palette constraints in mind
4. **Sprite Budget**: Track sprite usage to avoid overflow
5. **VRAM Budget**: Track VRAM usage (64 KB total)
6. **Mode Selection**: Choose appropriate mode for your needs

### Quality Checklist

- [ ] All tiles fit within tile boundaries (8×8 or 16×16 depending on mode)
- [ ] Colors respect palette constraints (4, 16, or 256 colors per layer depending on mode)
- [ ] Tiles tile seamlessly for backgrounds
- [ ] Sprites are readable at target size
- [ ] Tile usage is optimized (minimal duplicates)
- [ ] Palette usage is optimized
- [ ] Graphics tested on hardware/accurate emulator
- [ ] Sprite count within limits (128 total, 32 per scanline)
- [ ] VRAM usage within 64 KB limit
- [ ] Appropriate video mode selected for needs

## Cross-References

- [1.4 PPU Fundamentals](../01-fundamentals/1.4-ppu-fundamentals.md) - Tiles, pattern tables, sprites
- [2.3 PPU Rendering Rules](2.3-ppu-rendering-rules.md) - VRAM access, VBlank
- [3.3 Rendering Architecture](../03-core-concepts/3.3-rendering-architecture.md) - OAM buffering, rendering pipeline
- [4.2 PPU Cheatsheets](../04-cheatsheets/4.2-ppu-cheatsheets.md) - Register reference, sprite attributes
- [5.1 Sprite Engine Patterns](../05-applied-patterns/5.1-sprite-engine-patterns.md) - Sprite management
- [5.4 Animation Systems](../05-applied-patterns/5.4-animation-systems.md) - Animation techniques

## External Resources

- [PAL/NTSC Thread](https://snes.nesdev.org/wiki/PAL) - PAL vs NTSC differences

---

**Note**: This guide follows the hardware-first, assembly-aware philosophy of this framework. All techniques are verified against actual hardware behavior and constraints. Information based on Mega Cat Studios Super PPU Graphics Guide v0.1 (10/09/17).
