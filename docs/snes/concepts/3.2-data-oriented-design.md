# 3.2 Data-Oriented Design (SNES Style)

## System Applicability

**This document applies to:**
- ✅ **SNES: Primary focus

## Concept Definition

Data-oriented design on SNES focuses on organizing memory for efficient CPU access patterns, leveraging WRAM, direct page addressing, and struct-of-arrays patterns to maximize performance within the 65816 CPU's capabilities.


## Subsystems Involved

* **CPU: Accesses data structures, performs computations
* **WRAM: Stores game state, entity data, temporary variables (128 KB)
* **Direct Page: Fast-access memory for frequently used variables (similar to zero page)
* **Stack: Used for subroutine calls and temporary storage (in WRAM)
* **ROM: Contains lookup tables, constant data, compressed level data

## Step-by-Step Data Flow

1. **Data Allocation:
   - Critical variables → Direct page (set via DP register)
   - Entity arrays → WRAM ($7E0000–$7FFFFF)
   - Lookup tables → ROM (read-only)
   - Temporary data → Stack or scratch WRAM

2. **Data Access Patterns:
   - Sequential iteration: Use indexed addressing (LDY #0 ... INY ... CPY #count)
   - Hot loops: Keep loop counters in direct page
   - Entity updates: Process all entities of same type together (struct-of-arrays)
   - Lookup tables: Pre-compute values in ROM, index with direct page pointer

3. **Memory Hierarchy:
   - Direct page: Variables accessed >10 times per frame
   - WRAM: Entity state, buffers, game state (128 KB available)
   - ROM: Constants, lookup tables, level data

## Timing Implications

* **Direct page access: Faster than absolute addressing
* **Indexed direct page: Efficient for sequential access
* **Struct-of-arrays: Enables efficient batch processing (all X positions, then all Y positions)
* **Lookup tables: Single indexed read vs computation (saves cycles)
* **Memory layout: Sequential access is faster than random access

## Hardware Rationale

* **65816 CPU: 3.58 MHz (NTSC) requires cycle-efficient code
* **WRAM: 128 KB available, more space than NES but still requires efficient use
* **Direct page advantage: Hardware-optimized addressing mode saves cycles
* **Cache-like behavior: Sequential access patterns benefit from CPU prefetching
* **Deterministic timing: Predictable memory access enables frame-perfect gameplay

## Failure Modes and Visible Symptoms

* **Direct page waste: Using absolute addressing for hot variables wastes cycles
* **Array-of-structs: Random memory access patterns slow down entity updates
* **Stack overflow: Deep recursion or large stack frames corrupt WRAM
* **Memory fragmentation: Poor allocation causes wasted WRAM
* **Lookup table misses: Computing values at runtime instead of using ROM tables

## Minimal Example

```asm
; Struct-of-arrays: All X positions, then all Y positions
; Better for batch processing than array-of-structs

; Entity data in WRAM (10 entities)
entity_x = $7E0200      ; 10 bytes: X positions
entity_y = $7E020A      ; 10 bytes: Y positions
entity_vx = $7E0214     ; 10 bytes: X velocities
entity_vy = $7E021E     ; 10 bytes: Y velocities
entity_type = $7E0228   ; 10 bytes: Entity types

; Direct page pointer
dp_entity_ptr = $00     ; 16-bit pointer to current entity data

; Update all entity positions (struct-of-arrays pattern)
update_entities:
    SEP #$20            ; 8-bit accumulator
    LDY #0             ; Entity index
update_loop:
    ; Update X position
    LDA entity_x,Y
    CLC
    ADC entity_vx,Y
    STA entity_x,Y
    
    ; Update Y position
    LDA entity_y,Y
    CLC
    ADC entity_vy,Y
    STA entity_y,Y
    
    INY
    CPY #10            ; 10 entities
    BNE update_loop
    
    RTS

; Direct page usage for hot variables
dp_player_x = $00       ; Player X (accessed frequently)
dp_player_y = $01       ; Player Y (accessed frequently)
dp_temp = $02         ; Temporary variable
dp_ptr = $03           ; 16-bit pointer (low, high at $03, $04)

; Initialize direct page
init_direct_page:
    REP #$20            ; 16-bit accumulator
    LDA #$0000
    TCD                 ; Set direct page to $0000
    SEP #$20            ; 8-bit accumulator
    RTS

; Using direct page for fast access
update_player:
    LDA dp_player_x     ; Direct page access (faster)
    CLC
    ADC #1
    STA dp_player_x
    
    RTS

; Lookup table in ROM (faster than computation)
sine_table:
    .byte 0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90
    ; ... more values ...

; Use lookup table instead of computing sine
get_sine:
    TAY
    LDA sine_table,Y    ; Indexed absolute
    RTS
```

## Cross-References

- Related Fundamentals: 1.2 (65816 CPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.1 (CPU Timing & Cycles)
- Related Core Concepts: 3.1 (Game Loop), 3.5 (Map & Level Systems)
- Related Cheatsheets: 4.1 (CPU Cheatsheets), 4.3 (Memory Cheatsheets)
