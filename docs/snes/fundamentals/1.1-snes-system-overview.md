# 1.1 SNES System Overview

## System Applicability

**This document applies to:**
- ✅ **SNES (Super Nintendo Entertainment System): Primary focus

## Physical Hardware Overview

The Super Nintendo Entertainment System (SNES) is a composite system consisting of:

* **65C816 CPU** (65816 variant, ~3.58 MHz NTSC, ~3.28 MHz PAL)
* **PPU** (Picture Processing Unit, ~21.477 MHz NTSC, ~21.281 MHz PAL)
* **SPC700** (Audio Processing Unit, separate 8-bit CPU)
* **Cartridge slot** (connects PRG ROM, CHR ROM, and optional mapper hardware)
* **128 KB WRAM** (Work RAM, CPU-accessible)
* **64 KB VRAM** (Video RAM, PPU-accessible)
* **512 bytes CGRAM** (Color palette RAM)
* **544 bytes OAM** (Object Attribute Memory, sprite data)

The CPU and PPU operate on separate buses. The CPU cannot directly access PPU memory; all communication occurs through memory-mapped I/O registers ($2100–$213F).

## SNES Terminology Definitions

* **NTSC: North American/Japanese video standard (60.098 Hz frame rate, 262 scanlines)
* **PAL: European video standard (50.007 Hz frame rate, 312 scanlines)
* **VBlank: Vertical blanking period when PPU is not rendering
* **Scanline: One horizontal line of video output
* **Frame: One complete screen refresh
* **NMI: Non-Maskable Interrupt, triggered at start of VBlank
* **LoROM: Low ROM mapping mode (banks $00–$7F)
* **HiROM: High ROM mapping mode (banks $40–$7D)
* **Native Mode: 65816 CPU mode with 16-bit registers
* **Emulation Mode: 6502-compatible mode for backward compatibility

## CPU Architecture

The SNES uses the 65C816 processor, which is a 16-bit extension of the 6502:

* **Native Mode: Full 16-bit operation with 24-bit addressing
* **Emulation Mode: 6502-compatible mode (8-bit registers, 16-bit addressing)
* **Register Sizes: Configurable (8-bit or 16-bit accumulator, 8-bit or 16-bit index registers)
* **Addressing: 24-bit address bus (16 MB address space)

## Memory Architecture

* **WRAM: 128 KB work RAM ($7E:0000–$7F:FFFF)
* **VRAM: 64 KB video RAM (accessed via $2116–$2119)
* **CGRAM: 512 bytes color palette RAM (256 colors, 15-bit RGB)
* **OAM: 544 bytes object attribute memory (128 sprites)
* **ROM: Cartridge ROM mapped to CPU address space

## PPU Architecture

The SNES PPU supports multiple background modes:

* **Mode 0: 4 backgrounds, 2bpp (4 colors per tile)
* **Mode 1: 3 backgrounds, 4bpp + 2bpp
* **Mode 2: 2 backgrounds, 4bpp
* **Mode 3: 2 backgrounds, 8bpp + 4bpp
* **Mode 4: 2 backgrounds, 8bpp + 2bpp
* **Mode 5: 2 backgrounds, 4bpp (512×448 resolution)
* **Mode 6: 1 background, 4bpp (512×448 resolution)
* **Mode 7: 1 background, 8bpp with affine transformation

## Audio Architecture

The SNES uses a separate SPC700 processor for audio:

* **8 channels: 4 pulse wave channels, 1 noise channel, 1 sample channel, 2 echo channels
* **64 KB RAM: Sample data and program storage
* **Communication: CPU communicates via $2140–$2143 registers

## Reference Implementation

The canonical minimal SNES example is snes-hello (https://github.com/SlithyMatt/snes-hello), which demonstrates:

- Correct native 65816 mode entry
- Proper register size configuration
- LoROM mapping with correct header placement
- DMA-based VRAM operations
- Hardware-accurate PPU initialization

Note: Gold standard examples are maintained in `docs/snes/gold_standard/` and will only include verified, authoritative reference implementations.

## Core Rules and Invariants

* Everything revolves around **VBlank**. Safe PPU VRAM/CGRAM/OAM access occurs only during VBlank or forced blanking.
* The CPU runs at ~3.58 MHz (NTSC). One frame = ~21,477 CPU cycles.
* The PPU renders 224 visible scanlines, then enters VBlank for ~38 scanlines (NTSC).
* NMI fires once per frame at the start of VBlank (scanline 225).
* CPU memory map includes WRAM ($7E0000–$7FFFFF), ROM (banks $00–$FF), and I/O registers ($2100–$21FF, $4200–$43FF).
* PPU memory map: VRAM (64 KB, accessed via $2116–$2119), CGRAM (512 bytes, accessed via $2121–$2122), OAM (544 bytes, accessed via $2102–$2104).
* Native 65816 mode must be entered explicitly via XCE instruction.
* Direct page (DP register) provides fast addressing similar to zero page on 6502.

## Minimal Correct Usage Example

```asm
; Minimal SNES initialization
reset:
    ; Switch to native mode
    REP #$38     ; Native mode, clear decimal, clear accumulator width
    XCE          ; Switch from emulation to native mode
    
    ; Set 8-bit mode
    SEP #$30     ; 8-bit A, X, Y
    
    ; Initialize stack
    LDA #$01FF
    TCS          ; Stack pointer = $01FF
    
    ; Initialize direct page
    LDA #$0000
    TCD          ; Direct page = $0000
    
    ; Disable PPU rendering
    LDA #$80
    STA INIDISP  ; Force blanking
    
    ; Clear WRAM
    ; (WRAM clearing code here)
    
    ; Initialize PPU
    ; (PPU initialization code here)
    
    ; Enable NMI
    LDA #$80
    STA NMITIMEN ; Enable NMI
    
    ; Main loop
game_loop:
    WAI          ; Wait for interrupt (VBlank)
    JMP game_loop

nmi:
    RTI
```

## Gold Standard Example

```asm
; Complete SNES initialization following all hardware requirements
reset:
    ; Switch to native mode
    REP #$38     ; Set native mode flags
    XCE          ; Switch to native mode
    
    ; Set 8-bit mode for most operations
    SEP #$30     ; 8-bit A, X, Y
    
    ; Initialize stack
    LDA #$01FF
    TCS          ; Stack pointer = $01FF
    
    ; Initialize direct page
    LDA #$0000
    TCD          ; Direct page = $0000
    
    ; Disable PPU rendering
    LDA #$80
    STA INIDISP  ; Force blanking (bit 7 = 1)
    
    ; Clear WRAM
    ; (WRAM clearing via DMA or manual loop)
    
    ; Clear VRAM
    JSR ClearVRAM
    
    ; Initialize PPU registers
    ; (PPU initialization code)
    
    ; Enable NMI
    LDA #$80
    STA NMITIMEN ; Enable NMI
    
    ; Enter main loop
    JMP game_loop

game_loop:
    WAI          ; Wait for interrupt (VBlank)
    ; Game logic here
    JMP game_loop

nmi:
    ; VBlank handler
    ; Update PPU registers, OAM, etc.
    RTI
```

## Validation Rules

### Hardware Requirements

1. **Native Mode Entry: Must execute XCE to switch from emulation to native mode
2. **Stack Initialization: Stack pointer must be set before using stack
3. **Direct Page Initialization: Direct page register must be set before using direct page addressing
4. **PPU Disable: PPU must be disabled (forced blanking) before VRAM/CGRAM/OAM access
5. **VBlank Waits: Must wait for VBlank before enabling PPU rendering
6. **NMI Enable: NMI must be enabled after initialization complete

### Failure Modes

* **Missing Native Mode Switch: CPU remains in emulation mode, limited functionality
* **Uninitialized Stack: Stack operations corrupt WRAM
* **PPU Not Disabled: VRAM/CGRAM/OAM access during rendering causes corruption
* **VRAM Access Outside VBlank: Visual corruption, incorrect tiles/sprites
* **OAM Writes During Rendering: Sprite glitches, incorrect positions
* **Long NMI Handler: Delays main loop, causes frame drops, input lag

## Explicit Non-Goals

This section does not cover:
* Detailed CPU instruction set (see 1.2)
* Memory map specifics (see 1.3)
* PPU rendering details (see 1.4)
* ROM mapping details (see 1.5)
* Timing-critical operations (see 2.1, 2.2)
* Game loop architecture (see 3.1)

## Cross-References

- Related Fundamentals: 1.2 (65816 CPU Fundamentals), 1.3 (Memory Fundamentals), 1.4 (PPU Fundamentals), 1.5 (ROM Fundamentals)
- Related Advanced Fundamentals: 2.1 (CPU Timing & Cycles), 2.2 (NMI & VBlank Discipline)
- Related Core Concepts: 3.1 (The Game Loop)
- Related Cheatsheets: 4.3 (Memory Cheatsheets), 4.4 (Timing Cheatsheets)
