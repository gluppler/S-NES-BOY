# 5.3 Collision Systems

## System Applicability

**This document applies to:**
- ✅ **: Fully compatible (same tile system)


## Tile-Based Collision

**Pattern: Check collision by reading tile data from name tables. Entities collide with solid tiles (non-zero tile indices or specific collision flags).

**Advantages:
* Simple and fast
* Works well with tile-based levels
* Deterministic (same tile = same collision)

**Disadvantages:
* Only works with tile-aligned entities
* Requires tile-to-pixel coordinate conversion

**Implementation:
```asm
; Tile-based collision check
; Input: X = entity X (pixels), Y = entity Y (pixels)
; Output: A = tile index (0 = empty, non-zero = solid)
check_tile_collision:
    ; Convert pixel X to tile X
    TXA
    LSR A
    LSR A
    LSR A             ; Divide by 8
    STA tile_x
    
    ; Convert pixel Y to tile Y
    TYA
    LSR A
    LSR A
    LSR A             ; Divide by 8
    STA tile_y
    
    ; Calculate name table address
    ; Address = $2000 + (tile_y * 32) + tile_x
    LDA tile_y
    ASL A
    ASL A
    ASL A
    ASL A
    ASL A             ; tile_y * 32
    CLC
    ADC tile_x
    STA tile_addr_low
    LDA #$20          ; Name table 0 base
    STA tile_addr_high
    
    ; Read tile from name table (via PPU)
    ; Note: This requires VRAM access, so must be done during VBlank
    ; Or use a RAM buffer of the name table
    
    ; Alternative: Use RAM buffer
    LDA tile_y
    ASL A
    ASL A
    ASL A
    ASL A
    ASL A             ; tile_y * 32
    CLC
    ADC tile_x
    TAX
    LDA name_table_buffer,X  ; Read from RAM buffer
    
    RTS

; Check collision for entity movement
check_entity_collision:
    ; Get entity position
    LDA entity_x
    CLC
    ADC entity_vx     ; New X position
    TAX
    
    LDA entity_y
    CLC
    ADC entity_vy     ; New Y position
    TAY
    
    ; Check collision at new position
    JSR check_tile_collision
    BEQ no_collision  ; Tile = 0 (empty)
    
    ; Collision detected, don't move
    RTS
    
no_collision:
    ; No collision, update position
    STX entity_x
    STY entity_y
    RTS

; Name table buffer (RAM copy of current name table)
name_table_buffer = $0500  ; 960 bytes (32×30)
```

## Bounding Box Collision

**Pattern: Check collision between entities using axis-aligned bounding boxes (AABB). Each entity has a rectangular collision box.

**Advantages:
* Works with pixel-precision entities
* Fast (simple rectangle overlap test)
* Works for entity-to-entity collision

**Disadvantages:
* Less precise than pixel-perfect collision
* Requires bounding box data per entity

**Implementation:
```asm
; Bounding box collision check
; Input: entity1 (x1, y1, w1, h1), entity2 (x2, y2, w2, h2)
; Output: A = 1 if collision, 0 if no collision
check_bounding_box:
    ; Calculate entity1 right edge
    LDA entity1_x
    CLC
    ADC entity1_w
    STA entity1_right
    
    ; Calculate entity1 bottom edge
    LDA entity1_y
    CLC
    ADC entity1_h
    STA entity1_bottom
    
    ; Calculate entity2 right edge
    LDA entity2_x
    CLC
    ADC entity2_w
    STA entity2_right
    
    ; Calculate entity2 bottom edge
    LDA entity2_y
    CLC
    ADC entity2_h
    STA entity2_bottom
    
    ; Check if entity1 left < entity2 right
    LDA entity1_x
    CMP entity2_right
    BCS no_collision
    
    ; Check if entity1 right > entity2 left
    LDA entity1_right
    CMP entity2_x
    BCC no_collision
    
    ; Check if entity1 top < entity2 bottom
    LDA entity1_y
    CMP entity2_bottom
    BCS no_collision
    
    ; Check if entity1 bottom > entity2 top
    LDA entity1_bottom
    CMP entity2_y
    BCC no_collision
    
    ; Collision detected
    LDA #1
    RTS
    
no_collision:
    LDA #0
    RTS

; Check collision between player and all enemies
check_player_enemy_collision:
    ; Get player bounding box
    LDA player_x
    STA entity1_x
    LDA player_y
    STA entity1_y
    LDA #8           ; Player width
    STA entity1_w
    LDA #8           ; Player height
    STA entity1_h
    
    ; Check against all enemies
    LDX #0
enemy_collision_loop:
    LDA enemy_active,X
    BEQ next_enemy   ; Enemy not active
    
    ; Get enemy bounding box
    LDA enemy_x,X
    STA entity2_x
    LDA enemy_y,X
    STA entity2_y
    LDA #8           ; Enemy width
    STA entity2_w
    LDA #8           ; Enemy height
    STA entity2_h
    
    ; Check collision
    JSR check_bounding_box
    BEQ next_enemy   ; No collision
    
    ; Collision detected
    JSR player_hit
    RTS
    
next_enemy:
    INX
    CPX #enemy_count
    BNE enemy_collision_loop
    
    ; No collisions
    RTS
```

## Hybrid Collision (Tile + Bounding Box)

**Pattern: Use tile-based collision for level geometry and bounding box collision for entity-to-entity interactions.

**Implementation:
```asm
; Hybrid collision system
check_hybrid_collision:
    ; First check tile collision (level geometry)
    LDA entity_x
    TAX
    LDA entity_y
    TAY
    JSR check_tile_collision
    BNE collision_detected  ; Hit solid tile
    
    ; Then check bounding box collision (entities)
    JSR check_player_enemy_collision
    BNE collision_detected  ; Hit enemy
    
    ; No collision
    LDA #0
    RTS
    
collision_detected:
    LDA #1
    RTS
```

## Cross-References

- Related Fundamentals: 1.4 (PPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Core Concepts: 3.4 (Input → State → Output), 3.5 (Map & Level Systems)
- Related Applied Patterns: 5.2 (Scrolling Patterns)
