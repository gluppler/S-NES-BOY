# 1.1 Game Boy System Overview

## System Applicability

**This document applies to:**
- ✅ **Game Boy (DMG): Primary focus
- ✅ **Game Boy Color (CGB): Differences explicitly labeled
- ❌ **NES/SNES: Does not apply (different architecture - see system-specific documentation)

## Physical Hardware Overview

The Nintendo Game Boy (DMG) is a composite system consisting of:

* **LR35902 CPU** (Z80-like, ~4.19 MHz)
* **PPU** (Picture Processing Unit, LCD controller)
* **Cartridge slot** (connects ROM and optional MBC chips)
* **8 KB WRAM** (Work RAM, CPU-accessible)
* **8 KB VRAM** (Video RAM, PPU-accessible)
* **160 bytes OAM** (Object Attribute Memory, sprite data)
* **128 bytes HRAM** (High RAM, fast access)
* **LCD** (160×144 pixels, monochrome on DMG)

The CPU and PPU operate on separate buses. The CPU cannot directly access PPU memory during certain LCD modes; all communication occurs through memory-mapped I/O registers.

## Game Boy Terminology Definitions

* **DMG: Original Game Boy (Dot Matrix Game)
* **CGB: Game Boy Color (enhanced hardware, backward compatible)
* **VBlank: Vertical blanking period when LCD is not rendering
* **HBlank: Horizontal blanking period between scanlines
* **Scanline: One horizontal line of video output (160 pixels)
* **Frame: One complete screen refresh (144 scanlines + 10 VBlank lines = 154 total)
* **LCD Mode: PPU rendering state (Mode 0-3)
* **MBC: Memory Bank Controller (cartridge mapper chip)
* **OAM: Object Attribute Memory (sprite data)
* **VRAM: Video RAM (tile and tilemap data)
* **HRAM: High RAM (fast access RAM at $FF80-$FFFE)

## Core Rules and Invariants

* Everything revolves around **VBlank**. Safe VRAM/OAM access occurs only during VBlank (Mode 1) or HBlank (Mode 0).
* The CPU runs at ~4.19 MHz. One frame = ~59,727 CPU cycles.
* The PPU renders visible scanlines (0-143), then enters VBlank (144-153).
* VBlank interrupt fires once per frame at the start of VBlank (scanline 144).
* CPU memory map includes WRAM, ROM, I/O registers, and cartridge space.
* PPU memory map: VRAM (tiles, tilemaps), OAM (sprites).
* LCD modes restrict VRAM/OAM access timing.

## Minimal Correct Usage Example

```asm
; Minimal Game Boy initialization
SECTION "Reset", ROM0[$0000]
reset:
    di              ; Disable interrupts
    ld sp, $FFFE    ; Initialize stack pointer
    
    ; Wait for VBlank
    call wait_vblank
    
    ; Disable LCD
    xor a
    ld [rLCDC], a
    
    ; Clear VRAM
    ld hl, $8000
    ld bc, $2000
    call clear_mem
    
    ; Clear OAM
    ld hl, $FE00
    ld bc, $00A0
    call clear_mem
    
    ; Initialize game
    call init_game
    
    ; Enable LCD
    ld a, %10010001 ; LCD on, BG on, tiles at $8000
    ld [rLCDC], a
    
    ; Enable VBlank interrupt
    ld a, %00000001
    ld [rIE], a
    ei
    
    jp main_loop

wait_vblank:
    ld a, [rLY]
    cp 144
    jr c, wait_vblank
    ret

clear_mem:
    xor a
.loop:
    ld [hli], a
    dec bc
    ld a, b
    or c
    jr nz, .loop
    ret
```

## Gold Standard Example

```asm
; Complete Game Boy initialization following hardware requirements
SECTION "Reset", ROM0[$0000]
reset:
    ; Disable interrupts
    di
    
    ; Initialize stack pointer
    ld sp, $FFFE
    
    ; Wait for VBlank before disabling LCD
    ; Per Pan Docs: Must wait for VBlank before accessing VRAM
    call wait_vblank
    
    ; Disable LCD
    ; Per Pan Docs: LCD must be disabled before VRAM/OAM access
    xor a
    ld [rLCDC], a
    
    ; Clear WRAM
    ld hl, $C000
    ld bc, $2000
    call clear_memory
    
    ; Clear VRAM
    ld hl, $8000
    ld bc, $2000
    call clear_memory
    
    ; Clear OAM
    ld hl, $FE00
    ld bc, $00A0
    call clear_memory
    
    ; Clear HRAM
    ld hl, $FF80
    ld bc, $007F
    call clear_memory
    
    ; Initialize PPU registers
    xor a
    ld [rSCY], a    ; Scroll Y = 0
    ld [rSCX], a    ; Scroll X = 0
    ld [rBGP], a    ; Background palette = all black
    ld [rOBP0], a   ; Object palette 0 = all black
    ld [rOBP1], a   ; Object palette 1 = all black
    ld [rWY], a     ; Window Y = 0
    ld [rWX], a     ; Window X = 0
    
    ; Load tiles, tilemaps, palettes
    call load_tiles
    call load_tilemap
    call load_palettes
    
    ; Enable VBlank interrupt
    ld a, %00000001 ; VBlank interrupt only
    ld [rIE], a
    
    ; Enable LCD
    ; Per Pan Docs: Enable during VBlank
    call wait_vblank
    ld a, %10010001 ; LCD on, BG on, tiles at $8000, BG tilemap at $9800
    ld [rLCDC], a
    
    ; Enable interrupts
    ei
    
    jp main_loop

wait_vblank:
    ld a, [rLY]
    cp 144
    jr c, wait_vblank
    ret

clear_memory:
    xor a
.loop:
    ld [hli], a
    dec bc
    ld a, b
    or c
    jr nz, .loop
    ret
```

## Validation Rules

### Hardware Requirements

1. **Stack Initialization: Stack pointer must be set to valid WRAM address ($FFFE recommended)
2. **VBlank Wait: Must wait for VBlank before disabling LCD
3. **LCD Disable: LCD must be disabled before VRAM/OAM access
4. **Memory Clearing: WRAM, VRAM, OAM should be initialized
5. **Register Initialization: PPU registers must be set before enabling LCD
6. **Interrupt Enable: Interrupts must be enabled after initialization complete

### Failure Modes

* **Missing VBlank Wait: VRAM access during rendering causes corruption
* **Uninitialized Stack: Stack operations corrupt memory
* **VRAM Access During Rendering: Visual corruption, incorrect tiles
* **Missing LCD Disable: Cannot safely access VRAM/OAM
* **Uninitialized Registers: Display shows garbage or nothing

## Cross-References

- Related Fundamentals: 1.2 (LR35902 CPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.2 (LCD Controller Modes)
- Related Core Concepts: 3.1 (The Game Loop)
