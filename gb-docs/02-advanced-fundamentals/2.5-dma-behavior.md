# 2.5 DMA Behavior

## System Applicability

**This document applies to:**
- ✅ **Game Boy (DMG): Primary focus
- ✅ **Game Boy Color (CGB): Fully compatible
- ❌ **NES/SNES: Does not apply (different DMA system)

## Physical Hardware Overview

The Game Boy has a dedicated OAM DMA controller that transfers sprite data from WRAM/HRAM to OAM. DMA is initiated by writing the source address high byte to the DMA register ($FF46). The DMA transfer takes 160 cycles and blocks CPU access to most memory during transfer.

DMA characteristics:
* **Transfer Size: 160 bytes (40 sprites × 4 bytes)
* **Transfer Time: 160 CPU cycles
* **Source: WRAM/HRAM ($C000-$DFFF, $FF80-$FFFE)
* **Destination: OAM ($FE00-$FE9F)
* **CPU Blocking: CPU can only access HRAM during DMA

## Game Boy Terminology Definitions

* **DMA: Direct Memory Access (hardware transfer)
* **OAM DMA: Sprite data transfer to OAM
* **DMA Register: rDMA ($FF46), source address high byte
* **DMA Transfer: 160-cycle hardware transfer
* **CPU Blocking: CPU access restrictions during DMA

## Core Rules and Invariants

### DMA Operation

* **Initiation: Write source address high byte to $FF46
* **Transfer: 160 bytes copied automatically (160 cycles)
* **Source Range: $XX00-$XX9F (160 bytes from any 256-byte aligned address)
* **Destination: OAM ($FE00-$FE9F)
* **CPU Access: Only HRAM accessible during DMA

### DMA Timing

* **Transfer Duration: Exactly 160 CPU cycles
* **CPU Blocking: CPU blocked from most memory during transfer
* **HRAM Access: HRAM ($FF80-$FFFE) remains accessible during DMA
* **Completion: DMA completes automatically after 160 cycles

## Minimal Correct Usage Example

```asm
; OAM DMA transfer
start_dma:
    ld a, $C0        ; Source address high byte (WRAM $C000)
    ld [rDMA], a      ; Start DMA transfer
    ld a, 40         ; Wait 160 cycles (40 × 4 cycles)
.wait:
    dec a
    jr nz, .wait
    ret
```

## Gold Standard Example

```asm
; Complete OAM DMA usage example
SECTION "Code", ROM0[$0150]

; OAM buffer in WRAM
SECTION "OAM Buffer", WRAM0[$C000]
oam_buffer:
    ds $00A0         ; 160 bytes (40 sprites)

SECTION "Code", ROM0[$0150]

; Start OAM DMA transfer
start_oam_dma:
    ; Per Pan Docs: Write source address high byte to $FF46
    ; Source must be in WRAM ($C000-$DFFF) or HRAM ($FF80-$FFFE)
    ld a, HIGH(oam_buffer)  ; High byte of source address
    ld [rDMA], a            ; Start DMA transfer
    
    ; Per Pan Docs: DMA takes 160 cycles
    ; Wait for DMA to complete
    ; CPU can only access HRAM during DMA
    ld a, 40                ; 40 × 4 cycles = 160 cycles
.wait:
    dec a
    jr nz, .wait
    
    ret

; Alternative: Use HRAM during DMA wait
start_oam_dma_hram:
    ; Start DMA
    ld a, HIGH(oam_buffer)
    ld [rDMA], a
    
    ; Use HRAM during DMA (only memory accessible)
    ld a, $42
    ld [$FF80], a           ; HRAM access allowed during DMA
    ld a, [$FF80]           ; HRAM read allowed during DMA
    
    ; Wait for DMA completion
    ld a, 40
.wait:
    dec a
    jr nz, .wait
    
    ret

; Update OAM buffer and transfer
update_oam:
    ; Update OAM buffer in WRAM
    ld hl, oam_buffer
    ld a, $10        ; Y position
    ld [hl+], a
    ld a, $08        ; X position
    ld [hl+], a
    ld a, $00        ; Tile number
    ld [hl+], a
    ld a, $00        ; Attributes
    ld [hl], a
    
    ; Transfer to OAM via DMA
    call start_oam_dma
    
    ret
```

## Validation Rules

### DMA Requirements

1. **Source Alignment: Source address must be 256-byte aligned ($XX00)
2. **Source Range: Source must be in WRAM or HRAM
3. **Transfer Timing: Must wait 160 cycles for DMA completion
4. **CPU Access: Only HRAM accessible during DMA
5. **OAM Access: OAM must be accessible (Mode 0 or Mode 1)

### Failure Modes

* **Wrong Source Address: DMA reads from wrong location
* **Source Not Aligned: Undefined behavior
* **Missing Wait: Accessing OAM before DMA completes causes corruption
* **Memory Access During DMA: Accessing blocked memory causes undefined behavior
* **OAM Access During Wrong Mode: Accessing OAM during Mode 2-3 causes corruption

## Cross-References

- Related Fundamentals: 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.2 (LCD Controller Modes), 2.3 (Memory Access Restrictions)
- Related Core Concepts: 3.2 (Rendering Pipeline)
