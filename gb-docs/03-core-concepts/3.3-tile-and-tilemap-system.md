# 3.3 Tile and Tilemap System

## System Applicability

**This document applies to:**
- ✅ **Game Boy (DMG): Primary focus
- ✅ **Game Boy Color (CGB): Differences explicitly labeled
- ❌ **NES/SNES: Does not apply (different tile system)

## Concept Definition

The Game Boy uses a tile-based rendering system. Tiles are 8×8 pixel patterns stored in VRAM. Tilemaps define which tiles appear at each screen position. The PPU reads tilemaps and tiles to generate the background and window layers. Sprites also use tiles but are defined in OAM rather than tilemaps.

Tile system components:
* **Tiles: 8×8 pixel patterns (16 bytes per tile, 2bpp)
* **Tilemap: 32×32 tile grid (1024 bytes, defines background)
* **Tile Numbers: Index into tile data (0-255 for 8 KB VRAM)
* **Attributes: Tile properties (palette, priority, flip - CGB only)

## Subsystems Involved

* **VRAM: Stores tile graphics ($8000-$97FF) and tilemaps ($9800-$9BFF or $9C00-$9FFF)
* **PPU: Reads tiles and tilemaps during rendering
* **CPU: Updates tiles and tilemaps during VBlank
* **Palette Registers: Define tile colors

## Step-by-Step Data Flow

1. **Tile Data Storage:
   - Tiles stored in VRAM $8000-$97FF (384 tiles × 16 bytes)
   - Each tile is 16 bytes (8 rows × 2 bytes per row)
   - 2bpp format: 2 bits per pixel = 4 colors per tile

2. **Tilemap Storage:
   - Tilemap stored in VRAM $9800-$9BFF or $9C00-$9FFF
   - 32×32 tile grid = 1024 bytes
   - Each byte = tile number (0-255)

3. **Rendering (PPU Automatic):
   - PPU reads tilemap byte for screen position
   - PPU uses tile number to index tile data
   - PPU reads tile graphics (16 bytes)
   - PPU applies palette to generate pixels
   - PPU outputs pixels to LCD

4. **CPU Updates (VBlank):
   - CPU writes new tile data to VRAM
   - CPU writes new tilemap entries to VRAM
   - Updates take effect next frame

## Timing Implications

* **Tile Loading: Must occur during VBlank (safe VRAM access)
* **Tilemap Updates: Must occur during VBlank
* **Tile Size: 16 bytes per tile (2bpp, 8×8 pixels)
* **Tilemap Size: 1024 bytes (32×32 tiles)
* **VRAM Capacity: 384 tiles in 8 KB VRAM

## Why This Pattern Exists on Game Boy Specifically

* **Memory Efficiency: Tiles allow reuse of graphics data
* **Hardware Acceleration: PPU handles tile rendering automatically
* **Limited VRAM: 8 KB requires efficient tile reuse
* **Tile-Based Scrolling: Efficient scrolling by updating tilemap
* **2bpp Format: 4 colors per tile (sufficient for monochrome display)

## Failure Modes and Visible Symptoms

* **Wrong Tile Numbers: Incorrect tiles displayed
* **Tilemap Corruption: Background shows wrong tiles
* **VRAM Overflow: Writing beyond VRAM bounds causes corruption
* **Timing Violations: Updating VRAM during Mode 3 causes glitches

## Minimal Example

```asm
; Load tile to VRAM
load_tile:
    call wait_vblank
    ld hl, $8000
    ld de, tile_data
    ld bc, 16       ; 16 bytes per tile
    call copy_memory
    ret
```

## Gold Standard Example

```asm
; Complete Game Boy tile and tilemap system example
SECTION "Code", ROM0[$0150]

; Load tiles to VRAM
load_tiles:
    ; Per Pan Docs: Must be done during VBlank
    call wait_vblank
    
    ; Copy tile data to VRAM $8000-$97FF
    ; 384 tiles × 16 bytes = 6144 bytes
    ld hl, tile_data
    ld de, $8000
    ld bc, $1800
    call copy_memory
    
    ret

; Load tilemap to VRAM
load_tilemap:
    ; Per Pan Docs: Must be done during VBlank
    call wait_vblank
    
    ; Copy tilemap to VRAM $9800-$9BFF
    ; 32×32 tiles = 1024 bytes
    ld hl, tilemap_data
    ld de, $9800
    ld bc, $0400
    call copy_memory
    
    ret

; Update single tile in tilemap
update_tilemap_tile:
    ; Input: B = X position (0-31), C = Y position (0-31), A = tile number
    ; Per Pan Docs: Must be done during VBlank
    call wait_vblank
    
    ; Calculate tilemap address: $9800 + (Y * 32) + X
    push af
    ld a, c
    ld hl, $9800
    ; Multiply Y by 32
    add a, a        ; ×2
    add a, a        ; ×4
    add a, a        ; ×8
    add a, a        ; ×16
    add a, a        ; ×32
    ld e, a
    ld d, 0
    add hl, de
    ; Add X
    ld a, b
    ld e, a
    ld d, 0
    add hl, de
    ; Write tile number
    pop af
    ld [hl], a
    
    ret

; Copy memory
copy_memory:
    ld a, [hl+]
    ld [de], a
    inc de
    dec bc
    ld a, b
    or c
    jr nz, copy_memory
    ret

; Tile data (2bpp, 16 bytes per tile)
tile_data:
    ; Tile 0: Space (empty)
    DB $00, $00, $00, $00, $00, $00, $00, $00
    DB $00, $00, $00, $00, $00, $00, $00, $00
    
    ; Tile 1: Character tile
    ; ... tile graphics data ...

; Tilemap data (32×32 = 1024 bytes)
tilemap_data:
    ; 32×32 grid of tile numbers
    ; ... tilemap data ...
```

## Cross-References

- Related Fundamentals: 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.2 (LCD Controller Modes), 2.3 (Memory Access Restrictions)
- Related Core Concepts: 3.2 (Rendering Pipeline)
