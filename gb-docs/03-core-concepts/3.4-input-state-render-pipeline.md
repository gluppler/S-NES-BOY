# 3.4 Input → State → Render Pipeline

## System Applicability

**This document applies to:**
- ✅ **Game Boy (DMG): Primary focus
- ✅ **Game Boy Color (CGB): Fully compatible
- ❌ **NES/SNES: Does not apply (different input system)

## Concept Definition

The Game Boy input → state → render pipeline processes user input, updates game state, and prepares rendering data in a deterministic sequence. Input is read from the joypad register, game state is updated based on input and game logic, and rendering data (OAM, tiles, tilemaps) is prepared for the next frame. This pipeline ensures consistent frame-based updates synchronized with VBlank.

## Subsystems Involved

* **Joypad: User input (directional pad, buttons)
* **CPU: Processes input and updates game state
* **WRAM: Stores game state (player position, entity data)
* **OAM Buffer: Sprite data for next frame
* **VRAM: Tile and tilemap data
* **VBlank Interrupt: Frame synchronization boundary

## Step-by-Step Data Flow

1. **Input Processing (Main Loop):
   - Read joypad register ($FF00)
   - Decode button states (directional pad, A, B, Start, Select)
   - Update input state variables
   - Detect button press/release events

2. **State Update (Main Loop):
   - Process input events
   - Update player position/velocity
   - Update entity positions
   - Update game logic (collisions, AI, etc.)
   - Update frame counter

3. **Rendering Preparation (Main Loop):
   - Clear OAM buffer (set all sprites off-screen)
   - Build sprite list from entities
   - Update tilemap (if needed)
   - Update scroll registers
   - Prepare palette changes (CGB)

4. **Rendering Execution (VBlank Interrupt):
   - OAM DMA: Transfer OAM buffer to OAM
   - Update scroll registers
   - Update window position (if used)
   - Update tiles/tilemaps (if needed)
   - Increment frame counter

5. **Frame Boundary:
   - Wait for next VBlank
   - Process repeats

## Timing Implications

* **Input Read: ~8 cycles (read joypad register)
* **State Update: Variable (depends on game complexity)
* **Rendering Prep: Variable (depends on number of sprites/updates)
* **VBlank Handler: Must complete within ~4560 cycles
* **Frame Rate: 60 Hz (one complete pipeline per frame)

## Why This Pattern Exists on Game Boy Specifically

* **Frame Synchronization: VBlank provides consistent 60 Hz frame boundary
* **Input Timing: Joypad register must be read at specific times
* **Rendering Constraints: VRAM/OAM updates only safe during VBlank
* **Deterministic Updates: Frame-based updates ensure consistent behavior
* **Power Efficiency: HALT instruction saves power between frames

## Failure Modes and Visible Symptoms

* **Input Lag: Reading joypad at wrong time causes missed inputs
* **State Desync: Game state updates at inconsistent rates
* **Rendering Glitches: VRAM updates outside VBlank cause corruption
* **Frame Drops: VBlank handler exceeds time budget
* **Input Debouncing: Missing button press/release detection

## Minimal Example

```asm
main_loop:
    halt
    call read_input
    call update_game
    call prepare_rendering
    jp main_loop
```

## Gold Standard Example

```asm
; Complete input → state → render pipeline example
SECTION "Game State", WRAM0[$C000]
player_x:
    ds 1
player_y:
    ds 1
input_state:
    ds 1
input_prev:
    ds 1

SECTION "OAM Buffer", WRAM0[$C100]
oam_buffer:
    ds $00A0

SECTION "VBlank", ROM0[$0040]
    jp vblank_handler

SECTION "Code", ROM0[$0150]

; Main game loop
main_loop:
    ; Per Pan Docs: Use halt for power efficiency
    halt            ; Wait for interrupt
    
    ; Input → State → Render pipeline
    call read_input
    call update_game_state
    call prepare_rendering
    
    jp main_loop

; Read input from joypad
read_input:
    ; Per Pan Docs: Must select button group before reading
    ; Select directional pad
    ld a, %00100000  ; Select d-pad (bit 5 = 0)
    ld [rP1], a
    ; Read d-pad (register needs time to stabilize)
    ld a, [rP1]
    ld a, [rP1]
    ld a, [rP1]
    ld a, [rP1]
    and %00001111   ; Lower 4 bits are d-pad
    ld b, a
    
    ; Select buttons
    ld a, %00010000  ; Select buttons (bit 4 = 0)
    ld [rP1], a
    ; Read buttons
    ld a, [rP1]
    ld a, [rP1]
    ld a, [rP1]
    ld a, [rP1]
    and %00001111   ; Lower 4 bits are buttons
    swap a          ; Move to upper 4 bits
    or b            ; Combine with d-pad
    cpl             ; Invert (0 = pressed, 1 = not pressed)
    
    ; Store input state
    ld [input_prev], a
    ld [input_state], a
    
    ; Deselect joypad
    ld a, %00110000  ; Deselect all (bits 4-5 = 1)
    ld [rP1], a
    
    ret

; Update game state based on input
update_game_state:
    ld a, [input_state]
    ld b, a
    
    ; Check directional pad
    bit 3, b        ; Down?
    jr z, .move_down
    bit 2, b        ; Up?
    jr z, .move_up
    bit 1, b        ; Left?
    jr z, .move_left
    bit 0, b        ; Right?
    jr z, .move_right
    jr .done
    
.move_down:
    ld a, [player_y]
    inc a
    ld [player_y], a
    jr .done
    
.move_up:
    ld a, [player_y]
    dec a
    ld [player_y], a
    jr .done
    
.move_left:
    ld a, [player_x]
    dec a
    ld [player_x], a
    jr .done
    
.move_right:
    ld a, [player_x]
    inc a
    ld [player_x], a
    jr .done
    
.done:
    ret

; Prepare rendering data
prepare_rendering:
    ; Clear OAM buffer
    ld hl, oam_buffer
    ld bc, $00A0
    xor a
    call clear_memory
    
    ; Build sprite list
    ld hl, oam_buffer
    ld a, [player_y]
    ld [hl+], a     ; Sprite Y
    ld a, [player_x]
    ld [hl+], a     ; Sprite X
    ld a, $00       ; Tile number
    ld [hl+], a
    ld a, $00       ; Attributes
    ld [hl], a
    
    ; Update scroll
    ld a, [player_x]
    ld [rSCX], a
    ld a, [player_y]
    ld [rSCY], a
    
    ret

; VBlank interrupt handler
vblank_handler:
    push af
    push bc
    push de
    push hl
    
    ; Execute rendering updates
    call update_oam_dma
    
    pop hl
    pop de
    pop bc
    pop af
    reti

; Update OAM via DMA
update_oam_dma:
    ld a, HIGH(oam_buffer)
    ld [rDMA], a
    ld a, 40
.wait:
    dec a
    jr nz, .wait
    ret
```

## Cross-References

- Related Fundamentals: 1.5 (Execution Flow)
- Related Advanced Fundamentals: 2.4 (Interrupt System)
- Related Core Concepts: 3.1 (The Game Loop), 3.2 (Rendering Pipeline)
