# 6.1 VBlank-Safe Background Tile Update (DMG)

## System Applicability

**This example applies to:**
- ✅ **Game Boy (DMG): Primary focus
- ❌ **Game Boy Color (CGB): Uses different palette system
- ❌ **NES/SNES: Does not apply

## Hardware Behavior

Per Pan Docs: VRAM is only accessible during LCD Mode 0 (HBlank) or Mode 1 (VBlank). Writing to VRAM during Mode 3 (Pixel Transfer) causes corruption because the PPU is actively reading VRAM to generate pixels.

VBlank provides a safe window of ~4560 cycles (10 scanlines × 456 cycles) for VRAM updates. This is sufficient for updating multiple tiles or tilemap entries.

## Why This Pattern Exists

- **VBlank Constraint: VRAM access only safe during VBlank
- **Tile Updates: Background tiles may need to change during gameplay
- **Efficient Updates: VBlank window allows multiple tile updates per frame
- **Hardware Requirement: PPU reads VRAM during Mode 3, CPU writes would corrupt

## Gold Standard Implementation

```asm
; VBlank-Safe Background Tile Update (DMG)
; Per Pan Docs: VRAM access only safe during Mode 0 (HBlank) or Mode 1 (VBlank)

SECTION "Tile Update Queue", WRAM0[$C000]
tile_update_count:
    ds 1
tile_update_queue:
    ds 64          ; 32 updates × 2 bytes (address, tile)

SECTION "VBlank", ROM0[$0040]
    jp vblank_handler

SECTION "Code", ROM0[$0150]

; Add tile update to queue
; Input: B = X position (0-31), C = Y position (0-31), A = tile number
queue_tile_update:
    push af
    push bc
    push hl
    
    ; Check if queue is full
    ld a, [tile_update_count]
    cp 32          ; Max 32 updates per frame
    jr nc, .queue_full
    
    ; Calculate tilemap address: $9800 + (Y * 32) + X
    push af
    ld a, c
    ; Multiply Y by 32
    add a, a       ; ×2
    add a, a       ; ×4
    add a, a       ; ×8
    add a, a       ; ×16
    add a, a       ; ×32
    ld hl, $9800
    ld e, a
    ld d, 0
    add hl, de
    ; Add X
    ld a, b
    ld e, a
    ld d, 0
    add hl, de
    ; Store address in queue
    ld a, l
    ld [tile_update_queue], a
    ld a, h
    ld [tile_update_queue+1], a
    pop af
    ; Store tile number
    ld [tile_update_queue+2], a
    
    ; Increment queue count
    ld a, [tile_update_count]
    inc a
    ld [tile_update_count], a
    
.queue_full:
    pop hl
    pop bc
    pop af
    ret

; Process tile update queue during VBlank
process_tile_updates:
    ; Per Pan Docs: Must be called during VBlank (Mode 1)
    ld a, [tile_update_count]
    or a
    ret z          ; No updates
    
    ld hl, tile_update_queue
    ld b, a        ; Update count
    
.update_loop:
    ; Load address
    ld a, [hl+]
    ld e, a
    ld a, [hl+]
    ld d, a
    ; Load tile number
    ld a, [hl+]
    
    ; Write tile to VRAM
    ; Per Pan Docs: VRAM is accessible during VBlank
    push hl
    ld h, d
    ld l, e
    ld [hl], a     ; Write tile number to tilemap
    pop hl
    
    dec b
    jr nz, .update_loop
    
    ; Clear queue
    xor a
    ld [tile_update_count], a
    
    ret

; VBlank interrupt handler
vblank_handler:
    push af
    push bc
    push de
    push hl
    
    ; Process tile updates (safe during VBlank)
    call process_tile_updates
    
    ; Other VBlank processing
    call update_oam_dma
    call update_scroll
    
    pop hl
    pop de
    pop bc
    pop af
    reti
```

## Validation

- ✅ VRAM access only during VBlank (Mode 1)
- ✅ Queue prevents overflow (max 32 updates)
- ✅ Efficient batch updates during VBlank
- ✅ Follows Pan Docs memory access rules
- ✅ Uses correct tilemap addressing

## Failure Modes

- ❌ Accessing VRAM outside VBlank: Corruption
- ❌ Queue overflow: Updates lost
- ❌ Wrong tilemap address: Tiles appear in wrong location

## Cross-References

- Pan Docs: VRAM Access Restrictions
- Pan Docs: LCD Controller Modes
- Related Advanced Fundamentals: 2.2 (LCD Controller Modes), 2.3 (Memory Access Restrictions)
- Related Core Concepts: 3.2 (Rendering Pipeline), 3.3 (Tile and Tilemap System)
