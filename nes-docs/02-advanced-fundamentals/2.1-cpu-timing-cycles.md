# 2.1 CPU Timing & Cycles

## System Applicability

**This document applies to:
- ✅ **NES: Primary focus (Ricoh 2A03 CPU timing)
- ✅ **: Fully compatible (same Ricoh 2A03 CPU)
- ⚠️ **SNES: Partially applicable (SNES 65816 has different cycle counts and timing characteristics)

**Note: SNES 65816 CPU has different instruction timing and cycle counts. This document covers 6502/2A03 timing only.

## Hardware Behavior

The Ricoh 2A03 CPU executes instructions over a variable number of **cycles**. Each cycle corresponds to one master clock period. On NTSC systems, the CPU runs at 1.789773 MHz, meaning one cycle = ~559 nanoseconds.

The CPU fetches and executes instructions sequentially. Most instructions require 2–7 cycles, depending on:
* Addressing mode (zero page vs absolute)
* Page boundary crossings
* Branch taken/not taken
* Index register usage

## Why This Behavior Exists

The 6502 architecture was designed for cost-effectiveness. Simpler addressing modes (zero page) use fewer cycles because they require fewer memory accesses. Page boundary crossings add cycles because the address calculation must fetch an additional byte.

Branch instructions use relative addressing (±127 bytes) to save space, but taken branches require an extra cycle to update the program counter.

## Exact Rules and Constraints

### Instruction Cycle Counts

| Instruction | Addressing Mode | Cycles | Notes |
|------------|----------------|--------|-------|
| LDA | Immediate | 2 | |
| LDA | Zero Page | 3 | |
| LDA | Zero Page,X | 4 | |
| LDA | Absolute | 4 | |
| LDA | Absolute,X | 4–5 | +1 if page crossed |
| LDA | Absolute,Y | 4–5 | +1 if page crossed |
| LDA | (Indirect,X) | 6 | |
| LDA | (Indirect),Y | 5–6 | +1 if page crossed |
| STA | Zero Page | 3 | |
| STA | Absolute | 4 | |
| STA | Absolute,X | 5 | |
| STA | (Indirect,X) | 6 | |
| STA | (Indirect),Y | 6 | |
| JMP | Absolute | 3 | |
| JMP | Indirect | 5 | |
| JSR | Absolute | 6 | |
| RTS | Implied | 6 | |
| Branch (taken) | Relative | 3 | +1 if page crossed |
| Branch (not taken) | Relative | 2 | |

### Branch Penalties

* **Branch taken: 3 cycles (2 if not taken)
* **Page boundary crossing: +1 cycle (when branch target crosses $XX00/$XXFF)
* **Branch distance: ±127 bytes maximum (signed 8-bit offset)

### Page Boundary Crossings

A page boundary crossing occurs when:
* Indexed addressing crosses $XXFF → $YY00
* Branch target crosses $XXFF → $YY00

Examples:
* `LDA $12FF,X` with X=1 crosses from $1300 to $1300 (no crossing)
* `LDA $12FF,X` with X=2 crosses from $1301 to $1300 (crossing, +1 cycle)
* `BEQ target` where target is at $1300 and PC is at $12FF (crossing, +1 cycle)

## Timing Considerations

### Frame Timing (NTSC)

* One frame = 262 scanlines
* One scanline = ~341 CPU cycles (63.5 µs)
* One frame = ~29,780 CPU cycles (~16.67 ms)
* VBlank period = ~2,270 CPU cycles (~1.27 ms)

### Cycle Accuracy Matters Because

* **Audio timing: APU registers must be updated at precise intervals
* **PPU synchronization: VRAM writes must occur during safe windows
* **Controller polling: Must read controller state at consistent times
* **Sprite DMA: OAM DMA ($4014) takes exactly 513 cycles
* **Deterministic gameplay: Frame-perfect inputs require cycle accuracy

## Common Mistakes and Incorrect Assumptions

* **Assuming all instructions take the same time: Cycle counts vary significantly
* **Ignoring page boundary penalties: Can cause timing drift
* **Not accounting for branch penalties: Taken branches are slower
* **Using absolute addressing when zero page would work: Wastes cycles
* **Assuming emulator timing matches hardware: Some emulators are inaccurate

## Observable Symptoms When Rules Are Violated

* **Audio glitches: APU updates too early/late cause clicks/pops
* **Sprite flicker: OAM DMA timing errors cause sprite corruption
* **Input lag: Controller polling at wrong times causes missed inputs
* **Racing conditions: Timing-dependent code fails intermittently
* **Emulator-only bugs: Code works in emulator but fails on hardware

## Minimal Example

```asm
; Cycle-accurate delay loop
; Each iteration: DEX (2) + BNE (3 if taken, 2 if not) = 5 cycles (last = 4)
; For 256 iterations: 255 × 5 + 4 = 1279 cycles
delay_256:
    LDX #0
delay_loop:
    DEX
    BNE delay_loop    ; 5 cycles per iteration (except last)

; Precise timing for APU update
; Must update APU registers at specific frame intervals
update_audio:
    LDA frame_counter
    AND #$03         ; Every 4 frames
    BNE skip_update
    ; Update APU registers here (must be cycle-accurate)
skip_update:
    RTS
```

## Cross-References

- Related Fundamentals: 1.2 (6502 CPU Fundamentals)
- Related Advanced Fundamentals: 2.2 (NMI & VBlank Discipline), 2.5 (Audio Fundamentals)
- Related Core Concepts: 3.1 (Game Loop)
- Related Cheatsheets: 4.1 (CPU Cheatsheets), 4.4 (Timing Cheatsheets)
