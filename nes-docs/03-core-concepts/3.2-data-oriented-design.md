# 3.2 Data-Oriented Design (NES Style)

## System Applicability

**This document applies to:
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same memory architecture)
- ⚠️ **SNES: Concepts apply but SNES has more RAM and different memory organization

**Note: Data-oriented design principles apply to SNES, but SNES has 128 KB RAM (vs 2 KB on NES) which changes optimization priorities.

## Concept Definition

Data-oriented design on the NES prioritizes **memory layout and access patterns** over object-oriented abstractions. The goal is to minimize CPU cycles by organizing data for efficient sequential access, leveraging zero page for hot variables, and using struct-of-arrays instead of array-of-structs when beneficial. This pattern is essential due to the NES's limited CPU speed and memory constraints.

## Subsystems Involved

* **CPU: Accesses data structures, performs computations
* **RAM: Stores game state, entity data, temporary variables
* **Zero Page: Fast-access memory for frequently used variables
* **Stack: Used for subroutine calls and temporary storage
* **ROM: Contains lookup tables, constant data, compressed level data

## Step-by-Step Data Flow

1. **Data Allocation:
   - Critical variables → Zero page ($0000–$00FF)
   - Entity arrays → Regular RAM ($0200–$07FF)
   - Lookup tables → ROM (read-only)
   - Temporary data → Stack or scratch RAM

2. **Data Access Patterns:
   - Sequential iteration: Use indexed addressing (LDY #0 ... INY ... CPY #count)
   - Hot loops: Keep loop counters in zero page
   - Entity updates: Process all entities of same type together (struct-of-arrays)
   - Lookup tables: Pre-compute values in ROM, index with zero page pointer

3. **Memory Hierarchy:
   - Zero page: Variables accessed >10 times per frame
   - Regular RAM: Entity state, buffers, game state
   - ROM: Constants, lookup tables, level data

## Timing Implications

* **Zero page access: 3 cycles (vs 4 cycles for absolute)
* **Indexed zero page: 4 cycles (vs 5 cycles for absolute indexed)
* **Struct-of-arrays: Enables efficient batch processing (all X positions, then all Y positions)
* **Lookup tables: Single indexed read (4 cycles) vs computation (10+ cycles)
* **Memory layout: Sequential access is faster than random access

## Why This Pattern Exists on NES Specifically

* **Limited CPU: 1.79 MHz (NTSC) requires cycle-efficient code
* **Small RAM: 2 KB total, must be used efficiently
* **Zero page advantage: Hardware-optimized addressing mode saves cycles
* **Cache-like behavior: Sequential access patterns benefit from CPU prefetching
* **Deterministic timing: Predictable memory access enables frame-perfect gameplay

## Failure Modes and Visible Symptoms

* **Zero page waste: Using absolute addressing for hot variables wastes cycles
* **Array-of-structs: Random memory access patterns slow down entity updates
* **Stack overflow: Deep recursion or large stack frames corrupt memory
* **Memory fragmentation: Poor allocation causes wasted RAM
* **Lookup table misses: Computing values at runtime instead of using ROM tables

## Minimal Example

```asm
; Struct-of-arrays: All X positions, then all Y positions
; Better for batch processing than array-of-structs

; Entity data (10 entities)
entity_x = $0200      ; 10 bytes: X positions
entity_y = $020A      ; 10 bytes: Y positions
entity_vx = $0214    ; 10 bytes: X velocities
entity_vy = $021E    ; 10 bytes: Y velocities
entity_type = $0228  ; 10 bytes: Entity types

; Zero page pointers
zp_entity_ptr = $10  ; 16-bit pointer to current entity data

; Update all entity positions (struct-of-arrays pattern)
update_entities:
    LDY #0           ; Entity index
update_loop:
    ; Update X position
    LDA entity_x,Y
    CLC
    ADC entity_vx,Y
    STA entity_x,Y
    
    ; Update Y position
    LDA entity_y,Y
    CLC
    ADC entity_vy,Y
    STA entity_y,Y
    
    INY
    CPY #10          ; 10 entities
    BNE update_loop
    
    RTS

; Zero page usage for hot variables
zp_player_x = $00    ; Player X (accessed frequently)
zp_player_y = $01    ; Player Y (accessed frequently)
zp_temp = $02        ; Temporary variable
zp_ptr = $03         ; 16-bit pointer (low, high at $03, $04)

; Using zero page for fast access
update_player:
    LDA zp_player_x  ; 3 cycles (zero page)
    CLC
    ADC #1
    STA zp_player_x  ; 3 cycles
    
    ; vs absolute addressing (slower):
    ; LDA player_x   ; 4 cycles
    ; CLC
    ; ADC #1
    ; STA player_x   ; 4 cycles
    
    RTS

; Lookup table in ROM (faster than computation)
sine_table:
    .byte 0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90
    ; ... more values ...

; Use lookup table instead of computing sine
get_sine:
    TAY
    LDA sine_table,Y ; 4 cycles (indexed absolute)
    RTS
```

## Cross-References

- Related Fundamentals: 1.2 (6502 CPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.1 (CPU Timing & Cycles)
- Related Core Concepts: 3.1 (Game Loop), 3.5 (Map & Level Systems)
- Related Cheatsheets: 4.1 (CPU Cheatsheets), 4.3 (Memory Cheatsheets)
