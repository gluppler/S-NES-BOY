# 5.4 Animation Systems

## System Applicability

**This document applies to:
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same sprite and tile system)
- ⚠️ **SNES: Concepts apply but SNES has different sprite system and animation capabilities

**Note: SNES animation follows similar patterns but SNES has more sprites and different OAM organization. This document covers NES/ animation patterns.

## Frame Tables

**Pattern: Store animation frame sequences in lookup tables. Each animation is a list of tile indices that cycle over time.

**Implementation:
```asm
; Animation frame tables (ROM)
anim_player_walk:
    .byte 0, 1, 2, 1  ; 4 frames, loops
anim_player_idle:
    .byte 0           ; 1 frame (static)
anim_player_jump:
    .byte 3           ; 1 frame (static)

; Entity animation state
entity_anim_frame = $0300  ; Current frame index (per entity)
entity_anim_timer = $0310  ; Frame timer (per entity)
entity_anim_id = $0320     ; Current animation ID (per entity)

; Animation definitions
ANIM_IDLE = 0
ANIM_WALK = 1
ANIM_JUMP = 2

; Update entity animation
update_entity_animation:
    LDX #0          ; Entity index
    
anim_loop:
    ; Get animation timer
    LDA entity_anim_timer,X
    BEQ next_frame  ; Timer expired, advance frame
    
    ; Decrement timer
    DEC entity_anim_timer,X
    JMP next_entity
    
next_frame:
    ; Get current animation ID
    LDA entity_anim_id,X
    ASL A           ; Multiply by 2 (each anim has 2-byte pointer)
    TAY
    
    ; Get animation table pointer
    LDA anim_table,Y
    STA anim_ptr
    LDA anim_table+1,Y
    STA anim_ptr+1
    
    ; Get current frame index
    LDA entity_anim_frame,X
    TAY
    
    ; Get tile index from animation table
    LDA (anim_ptr),Y
    CMP #$FF        ; End marker?
    BNE set_tile
    
    ; Animation ended, loop or switch
    LDA #0          ; Reset to frame 0
    STA entity_anim_frame,X
    TAY
    LDA (anim_ptr),Y
    
set_tile:
    ; Set entity tile
    STA entity_tile,X
    
    ; Advance frame
    INY
    STY entity_anim_frame,X
    
    ; Reset timer (8 frames per animation frame)
    LDA #8
    STA entity_anim_timer,X
    
next_entity:
    INX
    CPX #entity_count
    BNE anim_loop
    
    RTS

; Animation table (pointers to frame tables)
anim_table:
    .addr anim_player_idle
    .addr anim_player_walk
    .addr anim_player_jump
```

## Timers

**Pattern: Use frame counters to control animation speed and timing. Each animation frame displays for N frames before advancing.

**Implementation:
```asm
; Timer-based animation
entity_anim_timer = $0310  ; Frames until next animation frame

; Update animation with timer
update_animation_timer:
    LDX #0
    
timer_loop:
    ; Decrement timer
    DEC entity_anim_timer,X
    BNE timer_next  ; Timer not expired
    
    ; Timer expired, advance animation frame
    INC entity_anim_frame,X
    
    ; Get animation length
    LDA entity_anim_id,X
    TAY
    LDA anim_lengths,Y  ; Get length of current animation
    
    ; Check if frame exceeded length
    CMP entity_anim_frame,X
    BCS timer_reset
    
    ; Animation ended, loop
    LDA #0
    STA entity_anim_frame,X
    
timer_reset:
    ; Reset timer
    LDA anim_speeds,Y  ; Get speed of current animation
    STA entity_anim_timer,X
    
timer_next:
    INX
    CPX #entity_count
    BNE timer_loop
    
    RTS

; Animation speeds (frames per animation frame)
anim_speeds:
    .byte 8   ; Idle: 8 frames per frame
    .byte 4   ; Walk: 4 frames per frame (faster)
    .byte 16  ; Jump: 16 frames per frame (slower)

; Animation lengths (number of frames)
anim_lengths:
    .byte 1   ; Idle: 1 frame
    .byte 4   ; Walk: 4 frames
    .byte 1   ; Jump: 1 frame
```

## State-Driven Animation

**Pattern: Animation is determined by entity state (idle, walking, jumping). State changes trigger animation changes.

**Implementation:
```asm
; Entity states
STATE_IDLE = 0
STATE_WALK = 1
STATE_JUMP = 2
STATE_FALL = 3

; Entity state
entity_state = $0330  ; Current state (per entity)
entity_state_prev = $0340  ; Previous state (per entity)

; Update state-driven animation
update_state_animation:
    LDX #0
    
state_loop:
    ; Check if state changed
    LDA entity_state,X
    CMP entity_state_prev,X
    BEQ state_same
    
    ; State changed, switch animation
    STA entity_state_prev,X
    
    ; Map state to animation ID
    TAY
    LDA state_to_anim,Y
    STA entity_anim_id,X
    
    ; Reset animation frame
    LDA #0
    STA entity_anim_frame,X
    
    ; Reset timer
    LDA anim_speeds,Y
    STA entity_anim_timer,X
    
state_same:
    ; Update current animation
    JSR update_entity_animation
    
    INX
    CPX #entity_count
    BNE state_loop
    
    RTS

; State to animation mapping
state_to_anim:
    .byte ANIM_IDLE  ; STATE_IDLE → ANIM_IDLE
    .byte ANIM_WALK  ; STATE_WALK → ANIM_WALK
    .byte ANIM_JUMP  ; STATE_JUMP → ANIM_JUMP
    .byte ANIM_JUMP  ; STATE_FALL → ANIM_JUMP (reuse jump anim)

; Update entity state based on game logic
update_entity_state:
    LDX #0
    
entity_state_loop:
    ; Check if entity is on ground
    LDA entity_on_ground,X
    BEQ entity_airborne
    
    ; Entity is on ground
    LDA entity_vx,X
    BEQ entity_idle_state
    
    ; Entity is moving
    LDA #STATE_WALK
    STA entity_state,X
    JMP entity_state_next
    
entity_idle_state:
    LDA #STATE_IDLE
    STA entity_state,X
    JMP entity_state_next
    
entity_airborne:
    ; Entity is in air
    LDA entity_vy,X
    BMI entity_jump_state  ; Moving up (negative)
    
    ; Entity is falling
    LDA #STATE_FALL
    STA entity_state,X
    JMP entity_state_next
    
entity_jump_state:
    LDA #STATE_JUMP
    STA entity_state,X
    
entity_state_next:
    INX
    CPX #entity_count
    BNE entity_state_loop
    
    RTS
```

## Cross-References

- Related Fundamentals: 1.4 (PPU Fundamentals)
- Related Core Concepts: 3.4 (Input → State → Output), 3.2 (Data-Oriented Design)
- Related Applied Patterns: 5.1 (Sprite Engine Patterns)
