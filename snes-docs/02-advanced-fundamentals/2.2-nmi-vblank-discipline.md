# 2.2 NMI & VBlank Discipline

## System Applicability

**This document applies to:
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same PPU and interrupt system)
- ⚠️ **SNES: Conceptually similar but different implementation (SNES has VBlank IRQ, different timing)

**Note: SNES uses VBlank IRQ (interrupt request) instead of NMI, and has different scanline counts and timing. This document covers NES/ NMI/VBlank only.

## Hardware Behavior

**NMI (Non-Maskable Interrupt)** is triggered by the PPU at the start of VBlank (scanline 241, NTSC). NMI cannot be disabled by the I flag; it always fires when:
1. PPU register $2000 bit 7 (NMI enable) is set
2. VBlank period begins (PPU status $2002 bit 7 becomes 1)

**VBlank** is the period when the PPU is not rendering visible scanlines. On NTSC:
* Scanlines 0–239: Visible rendering (PPU is busy)
* Scanline 240: Post-render (PPU is idle)
* Scanlines 241–260: VBlank (safe for VRAM access)
* Scanline 261: Pre-render (PPU prepares for next frame)

During VBlank, the PPU is idle and VRAM can be safely accessed via $2006/$2007.

## Why This Behavior Exists

VBlank exists because CRT displays require time to return the electron beam from the bottom-right to top-left of the screen. During this period, the PPU is not generating video signals, making it safe to update VRAM without visual corruption.

NMI provides a hardware-synchronized interrupt that fires exactly once per frame, ensuring game logic runs at a consistent 60 Hz (NTSC) or 50 Hz (PAL) rate.

## Exact Rules and Constraints

### What NMI Really Is

* **Hardware interrupt: Triggered by PPU, not software
* **Non-maskable: Cannot be disabled by SEI (I flag has no effect)
* **Automatic: Fires when VBlank begins (if enabled)
* **Synchronous: Always occurs at the same point in the frame

### What MUST Happen in NMI

* **Read $2002: Clears VBlank flag (prevents multiple NMI calls)
* **Update OAM: Use OAM DMA ($4014) or manual writes ($2003/$2004)
* **Update VRAM: Write to name tables, palettes, pattern tables (if CHR RAM)
* **Update scroll registers: $2005 (x, y scroll) and $2006 (name table select)
* **Frame counter increment: Track frame number for timing
* **Keep it fast: NMI should complete in < 2,270 cycles (VBlank duration)

### What Must NEVER Happen in NMI

* **Long calculations: NMI must return quickly (< ~2000 cycles)
* **Blocking operations: Infinite loops or long delays
* **Unnecessary register writes: Each $2006/$2007 write costs cycles
* **Missing $2002 read: Must read $2002 to clear VBlank flag
* **Re-enabling rendering mid-frame: Only enable at start of VBlank

### Frame Pacing

* **NTSC: 60.098 Hz (one NMI per ~16.67 ms)
* **PAL: 50.007 Hz (one NMI per ~20 ms)
* **Frame counter: Increment once per NMI for consistent timing
* **Game logic: Should run once per frame (in main loop, not NMI)

## Timing Considerations

### VBlank Duration

* **NTSC: ~2,270 CPU cycles (~1.27 ms, scanlines 241–260)
* **PAL: ~3,270 CPU cycles (~1.97 ms, scanlines 241–310)

### Safe VRAM Access Window

* **Start: After reading $2002 in NMI
* **End: Before scanline 240 (pre-render) of next frame
* **Optimal: Complete all VRAM updates early in VBlank

### NMI Timing Constraints

* **Maximum NMI duration: ~2,000 cycles (leave buffer for main loop)
* **OAM DMA: 513 cycles (must complete during VBlank)
* **VRAM writes: ~2 cycles per byte (via $2007)
* **Scroll updates: 5 cycles ($2005 write × 2)

## Common Mistakes and Incorrect Assumptions

* **Doing game logic in NMI: NMI should only handle rendering updates
* **Not reading $2002: VBlank flag remains set, causing issues
* **Updating VRAM outside VBlank: Causes visual corruption
* **Long NMI handlers: Delays main loop, causes frame drops
* **Assuming NMI fires exactly 60 times per second: Actual rate is 60.098 Hz (NTSC)
* **Not disabling rendering before VRAM updates: Can cause glitches

## Observable Symptoms When Rules Are Violated

* **Visual corruption: VRAM writes during rendering cause tile/sprite glitches
* **Sprite flicker: OAM updates at wrong time cause sprite disappearance
* **Frame drops: Long NMI handlers delay main loop
* **Input lag: Game logic runs at inconsistent rates
* **Audio desync: APU updates at wrong frame intervals
* **Scroll jitter: Scroll register updates during rendering cause tearing

## Minimal Example

```asm
; Correct NMI handler
nmi:
    PHA             ; Save registers
    TXA
    PHA
    TYA
    PHA
    
    LDA $2002       ; MUST read to clear VBlank flag
    
    ; Update OAM (sprite data)
    LDA #0
    STA $2003       ; OAM address = 0
    LDA #>oam_buffer
    STA $4014       ; Start OAM DMA (513 cycles)
    
    ; Update scroll (must be done every frame)
    LDA scroll_x
    STA $2005       ; X scroll
    LDA scroll_y
    STA $2005       ; Y scroll
    
    ; Update PPU control if needed
    LDA ppu_ctrl
    STA $2000
    
    ; Set frame_ready flag for main loop
    LDA #1
    STA frame_ready
    
    PLA             ; Restore registers
    TAY
    PLA
    TAX
    PLA
    RTI

; Main loop (game logic runs here, not in NMI)
main_loop:
    LDA frame_ready
    BEQ main_loop   ; Wait for NMI
    
    LDA #0
    STA frame_ready ; Clear flag
    
    ; Game logic here (input, physics, AI, etc.)
    JSR read_controllers
    JSR update_game_state
    
    JMP main_loop
```

## Cross-References

- Related Fundamentals: 1.1 (NES System Overview), 1.4 (PPU Fundamentals)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.3 (PPU Rendering Rules)
- Related Core Concepts: 3.1 (Game Loop), 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.2 (PPU Cheatsheets), 4.4 (Timing Cheatsheets)
