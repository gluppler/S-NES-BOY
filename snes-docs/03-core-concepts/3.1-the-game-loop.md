# 3.1 The Game Loop

## System Applicability

**This document applies to:
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same game loop architecture)
- ⚠️ **SNES: Conceptually similar but different implementation (SNES uses VBlank IRQ instead of NMI, different timing)

**Note: SNES game loop follows similar patterns (main loop + VBlank handler) but uses VBlank IRQ instead of NMI and has different timing characteristics. This document covers NES/ game loop patterns.

## Concept Definition

The NES game loop is a deterministic cycle that separates **game logic** (main loop) from **rendering updates** (NMI handler). The main loop runs game logic at a variable rate, while the NMI handler runs at a fixed 60 Hz (NTSC) rate to update the display. This separation ensures consistent frame timing and prevents rendering from blocking game logic.

## Subsystems Involved

* **CPU: Executes main loop and NMI handler
* **PPU: Triggers NMI at start of VBlank, receives rendering updates
* **APU: Updated during main loop or NMI (depending on audio engine)
* **RAM: Stores game state, frame flags, and temporary data
* **Controllers: Polled in main loop, state stored in RAM

## Step-by-Step Data Flow

1. **Reset: CPU starts at reset vector, initializes system
2. **Initialization: Clear RAM, initialize PPU, load initial game state
3. **Main Loop: 
   - Wait for `frame_ready` flag (set by NMI)
   - Clear `frame_ready` flag
   - Read controllers (input)
   - Update game state (physics, AI, collision)
   - Update audio (if not in NMI)
   - Loop back to wait
4. **NMI (VBlank):
   - Save CPU registers
   - Read $2002 (clear VBlank flag)
   - Update OAM (sprite data via DMA)
   - Update VRAM (name tables, palettes)
   - Update scroll registers ($2005)
   - Set `frame_ready` flag
   - Restore CPU registers
   - Return (RTI)
5. **Repeat: Main loop continues, waiting for next NMI

## Timing Implications

* **Frame rate: 60.098 Hz (NTSC) or 50.007 Hz (PAL) — fixed by hardware
* **Main loop timing: Variable (depends on game logic complexity)
* **NMI timing: Must complete in < ~2,000 cycles (VBlank duration)
* **Frame synchronization: Main loop waits for NMI, ensuring 60 Hz game logic
* **Input polling: Typically once per frame (in main loop)
* **Audio updates: Once per frame (in main loop or NMI)

## Why This Pattern Exists on NES Specifically

* **VBlank constraint: VRAM can only be safely updated during VBlank
* **NMI synchronization: Hardware provides frame-synchronized interrupt
* **Deterministic timing: Fixed frame rate enables frame-perfect gameplay
* **Separation of concerns: Rendering (NMI) separate from logic (main loop) prevents blocking
* **Resource constraints: Limited CPU time requires efficient frame-based updates

## Failure Modes and Visible Symptoms

* **Long NMI handler: Delays main loop, causes frame drops, input lag
* **Game logic in NMI: Causes inconsistent frame timing, makes debugging difficult
* **Missing frame_ready flag: Main loop may run multiple times per frame or skip frames
* **VRAM updates outside VBlank: Visual corruption, tile/sprite glitches
* **Not reading $2002 in NMI: VBlank flag remains set, may cause multiple NMI calls
* **Infinite loops in main loop: Game freezes, no rendering updates

## Minimal Example

```asm
; Reset handler
reset:
    SEI
    CLD
    LDX #$FF
    TXS
    INX
    STX $2000
    STX $2001
    STX $4010
    
    ; Wait for PPU
    BIT $2002
vblank_wait1:
    BIT $2002
    BPL vblank_wait1
    
    ; Clear RAM
    LDA #0
clear_ram:
    STA $0000,X
    STA $0100,X
    STA $0200,X
    STA $0300,X
    STA $0400,X
    STA $0500,X
    STA $0600,X
    STA $0700,X
    INX
    BNE clear_ram
    
    ; Wait for second VBlank
vblank_wait2:
    BIT $2002
    BPL vblank_wait2
    
    ; Initialize PPU
    LDA #%10000000
    STA $2000
    LDA #%00011110
    STA $2001
    
    ; Initialize game state
    JSR init_game
    
    ; Enter main loop
    JMP main_loop

; NMI handler (rendering updates only)
nmi:
    PHA
    TXA
    PHA
    TYA
    PHA
    
    LDA $2002       ; Clear VBlank flag
    
    ; Update OAM
    LDA #0
    STA $2003
    LDA #>oam_buffer
    STA $4014       ; OAM DMA
    
    ; Update scroll
    LDA scroll_x
    STA $2005
    LDA scroll_y
    STA $2005
    
    ; Update PPU control
    LDA ppu_ctrl
    STA $2000
    
    ; Set frame ready flag
    LDA #1
    STA frame_ready
    
    PLA
    TAY
    PLA
    TAX
    PLA
    RTI

; Main loop (game logic)
main_loop:
    ; Wait for frame
    LDA frame_ready
    BEQ main_loop
    
    ; Clear frame flag
    LDA #0
    STA frame_ready
    
    ; Read input
    JSR read_controllers
    
    ; Update game state
    JSR update_player
    JSR update_enemies
    JSR update_collisions
    
    ; Update audio
    JSR update_audio
    
    ; Loop
    JMP main_loop

; Zero page variables
frame_ready = $00
scroll_x = $01
scroll_y = $02
ppu_ctrl = $03
oam_buffer = $0200
```

## Cross-References

- Related Fundamentals: 1.1 (NES System Overview), 1.2 (6502 CPU Fundamentals)
- Related Advanced Fundamentals: 2.1 (CPU Timing), 2.2 (NMI & VBlank Discipline)
- Related Core Concepts: 3.2 (Data-Oriented Design), 3.3 (Rendering Architecture), 3.4 (Input → State → Output)
- Related Cheatsheets: 4.4 (Timing Cheatsheets)
