# 3.4 Input → State → Output Pipeline

## System Applicability

**This document applies to:
- ✅ **NES: Primary focus
- ✅ **: Fully compatible (same input/output architecture)
- ⚠️ **SNES: Conceptually similar but different implementation (different controller protocol, different output systems)

**Note: SNES follows similar pipeline patterns but uses different controller communication and has different audio/video output systems. This document covers NES/ pipeline.

## Concept Definition

The Input → State → Output pipeline is a deterministic, frame-based data flow where **controller input** is read once per frame, **game state** is updated based on input and previous state, and **output** (rendering, audio) is generated from the current state. This pipeline ensures consistent, reproducible gameplay and separates input handling from state management from rendering.

## Subsystems Involved

* **Controllers: Provide input via $4016/$4017
* **CPU: Reads input, updates state, triggers output
* **RAM: Stores input state, game state, output queues
* **PPU: Receives rendering output (OAM, VRAM updates)
* **APU: Receives audio output (register updates)

## Step-by-Step Data Flow

1. **Input Phase** (Main Loop):
   - Strobe controllers ($4016)
   - Read 8 buttons from $4016 (controller 1) and $4017 (controller 2)
   - Store button states in RAM (0 = pressed, 1 = released)
   - Detect button transitions (pressed this frame, released this frame)

2. **State Update Phase** (Main Loop):
   - Process input: Map button presses to game actions
   - Update game state: Player position, enemy AI, physics, collisions
   - Update state machines: Animation states, game modes, timers
   - Apply game rules: Win/lose conditions, score, lives

3. **Output Phase** (Main Loop + NMI):
   - **Rendering: Build OAM buffer, background update queue (main loop)
   - **Rendering: Apply updates to PPU (NMI handler)
   - **Audio: Update APU registers (main loop or NMI)
   - **State persistence: Save state if needed (battery-backed RAM)

## Timing Implications

* **Input polling: Once per frame (60 Hz) for consistent responsiveness
* **State updates: Once per frame, deterministic (same input → same output)
* **Output generation: Rendering in NMI (60 Hz), audio updates per frame
* **Frame synchronization: All phases complete before next frame
* **Input lag: Minimum 1 frame (16.67 ms NTSC) from button press to screen update

## Why This Pattern Exists on NES Specifically

* **Frame-based design: NES is inherently frame-synchronized (60 Hz)
* **Deterministic gameplay: Enables frame-perfect inputs, TAS (Tool-Assisted Speedrun)
* **Separation of concerns: Input, logic, and rendering are independent
* **Resource constraints: Limited CPU requires efficient, predictable updates
* **Reproducibility: Same inputs produce same outputs (essential for debugging)

## Failure Modes and Visible Symptoms

* **Input read multiple times per frame: Inconsistent state, input lag variation
* **State updates in NMI: Causes frame timing issues, makes debugging difficult
* **Non-deterministic state: Random number generation without seed causes desyncs
* **Output in wrong phase: Rendering updates outside VBlank cause corruption
* **Missing input transitions: Can't detect "just pressed" or "just released" events
* **State desync: Different execution paths cause different game states

## Minimal Example

```asm
; Input state storage
buttons_prev = $10      ; Zero page: previous frame buttons
buttons_curr = $11      ; Zero page: current frame buttons
buttons_pressed = $12   ; Zero page: buttons pressed this frame (edge detection)

; Game state
player_x = $0200        ; Player X position
player_y = $0201        ; Player Y position
player_vx = $0202      ; Player X velocity
player_vy = $0203      ; Player Y velocity

; Input phase
read_input:
    ; Save previous frame
    LDA buttons_curr
    STA buttons_prev
    
    ; Strobe controller
    LDA #$01
    STA $4016
    LDA #$00
    STA $4016
    
    ; Read 8 buttons into buttons_curr
    LDX #8
    LDY #0
read_loop:
    LDA $4016
    LSR A
    ROL buttons_curr
    DEY
    BNE read_loop
    
    ; Detect button presses (edge detection)
    LDA buttons_prev
    EOR #$FF           ; Invert (1 = was pressed)
    AND buttons_curr   ; AND with current (1 = pressed now)
    STA buttons_pressed ; Buttons just pressed this frame
    
    RTS

; State update phase
update_game_state:
    ; Process input: Move player
    LDA buttons_curr
    AND #%00000001     ; A button (bit 0)
    BEQ check_b
    
    ; A pressed: Jump
    LDA #$F0           ; Negative velocity (up)
    STA player_vy
    
check_b:
    LDA buttons_curr
    AND #%00000010     ; B button (bit 1)
    BEQ check_left
    
    ; B pressed: Run (increase horizontal speed)
    LDA player_vx
    CMP #$02           ; Max speed
    BEQ check_left
    INC player_vx
    
check_left:
    LDA buttons_curr
    AND #%01000000     ; Left (bit 6)
    BEQ check_right
    
    ; Left pressed: Move left
    LDA player_vx
    SEC
    SBC #$01
    STA player_vx
    
check_right:
    LDA buttons_curr
    AND #%10000000     ; Right (bit 7)
    BEQ apply_physics
    
    ; Right pressed: Move right
    LDA player_vx
    CLC
    ADC #$01
    STA player_vx
    
apply_physics:
    ; Update position based on velocity
    LDA player_x
    CLC
    ADC player_vx
    STA player_x
    
    LDA player_y
    CLC
    ADC player_vy
    STA player_y
    
    ; Apply gravity
    LDA player_vy
    CLC
    ADC #$01           ; Gravity
    STA player_vy
    
    ; Check collisions (simplified)
    JSR check_collisions
    
    RTS

; Output phase (rendering preparation)
prepare_output:
    ; Build OAM buffer with player sprite
    LDA player_y
    STA oam_buffer+0   ; Sprite Y
    LDA #$00
    STA oam_buffer+1   ; Sprite tile
    LDA #%00000000
    STA oam_buffer+2   ; Sprite attributes
    LDA player_x
    STA oam_buffer+3   ; Sprite X
    
    ; Update audio (play jump sound if A was pressed)
    LDA buttons_pressed
    AND #%00000001     ; A just pressed
    BEQ output_done
    
    ; Play jump sound
    LDA #%10001111     ; Pulse 1: duty 50%, volume 15
    STA $4000
    LDA #<$0C00        ; Frequency
    STA $4002
    LDA #>$0C00
    STA $4003
    
output_done:
    RTS

; Main loop integration
main_loop:
    LDA frame_ready
    BEQ main_loop
    
    LDA #0
    STA frame_ready
    
    ; Input → State → Output pipeline
    JSR read_input
    JSR update_game_state
    JSR prepare_output
    
    JMP main_loop
```

## Cross-References

- Related Fundamentals: 1.2 (6502 CPU Fundamentals), 1.3 (Memory Fundamentals)
- Related Advanced Fundamentals: 2.4 (Controller I/O)
- Related Core Concepts: 3.1 (Game Loop), 3.2 (Data-Oriented Design), 3.3 (Rendering Architecture)
- Related Cheatsheets: 4.1 (CPU Cheatsheets)
